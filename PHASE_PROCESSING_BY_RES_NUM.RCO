***************************
* IDENTIFICATION DIVISION *
***************************

identification division.
program-id.			PHASE_PROCESSING_BY_RES_NUM.
author.				Phil Van Kley.
date-written.			27-Jan-1996.

* ********************** *
* nexTIS Refunds Changes *
* ********************** *
*
* In preparation for the move to nexTIS refunds, the following changes
* have been made to this program.  
*
* First, the transaction(s) start using the nexTIS schema, so all
* dml statements now include the database handle to indicate which
* schema the referenced table belongs to (property or nextis).
*
* Like MCT, nexTIS refunds creates a separate Refund Slip for each
* reso phase.  At the beginning of the phase, a call is made to create
* the nexTIS Refund Slip.  Each refund created is associated with this
* slip.  The actual refunds are created by the reapply_pmts subroutine
* so the slip id is passed to the subroutine.  This required a change
* to the subroutine linkage.
*
* The current plan will be to initially implement this where both the
* MCT and nexTIS refunds are created simultaneously so that we can begin
* to get real live test data early on.  When the time comes we can delete
* all of the MCT refund processing.
*
* The real action is in the reapply_pmts subroutine.
*
*
* November 2004 - Put resolution interest in either the secured res
* interest apportionment bucket or the unsecured res interest apportionment
* bucket, depending on the account and tax year.
*

************************
* ENVIRONMENT DIVISION *
************************

environment division.
configuration section.
source-computer.   VAX.
object-computer.   VAX.
special-names.
	SYMBOLIC CHARACTERS FF IS 13.

input-output section.
file-control.

select LETTER_TOTAL_RPT		assign TO LETTER_REPORT.

select LETTER_INPUT_FILE        assign TO RES_LETTER_FILE.

select LETTER_RESTART_FILE      assign TO RES_LETTER_FILE.

select RES_AUDIT_RPT            assign TO RES_AUDIT_REPORT.
select RES_AUDIT_RESTART_RPT    assign TO RES_AUDIT_REPORT.

select RES_CSH_TOTALS_RPT       assign TO RES_CSH_TOTALS_REPORT.

select RES_IMPOUND_RPT          assign TO RES_IMPOUND_REPORT.
select RES_IMPOUND_RESTART_RPT  assign TO RES_IMPOUND_REPORT.
                                                                           
* ************************************************************************ *
* This Report is no longer printed/used.  The SQL Reject report at         *
* the end of the Phase Processing command projedure produces the necessary *
* stuff.  bobJuan - October 2001.  This report is defined as NL: in the    *
* command procedure                                                        *
* ************************************************************************ *

select RES_REJECT_RPT                   assign TO RES_REJECT_REPORT.
select optional RES_REJECT_RESTART_RPT  assign TO RES_REJECT_REPORT.

select SUMMARY_RPT            assign TO RES_SUMMARY_REPORT.
select SUMMARY_RESTART_RPT
                              assign TO RES_SUMMARY_REPORT.

select SUMMARY_PARCEL_RPT     assign TO RES_SUMMARY_PARCEL_REPORT.

select RES_MTG_REF_RPT        assign TO RES_MTG_REF_REPORT.

select SUMMARY_IN_FIL         ASSIGN TO SUMMARY_IN_FILE.
SELECT SUMMARY_RESTART_IN_FIL ASSIGN TO SUMMARY_IN_FILE.
select SUMMARY_OUT_FIL        ASSIGN TO SUMMARY_OUT_FILE.
select SUMMARY_SORT_FIL       ASSIGN TO SUMMARY_SORT_FILE.
select RES_NUM_WORK_FIL       ASSIGN TO RES_NUM_WORK_FILE.

*****************
* DATA DIVISION *
*****************

data division.

file section.

/
* this REC is used for storing our letter data to be written out.     
FD  LETTER_INPUT_FILE. 
    COPY "RES$CDD.FILREC.LETTER_INPUT_REC" FROM DICTIONARY.  

FD  LETTER_RESTART_FILE.
    COPY "RES$CDD.FILREC.LETTER_INPUT_REC" FROM DICTIONARY
		REPLACING LETTER_INPUT_REC BY LETTER_RESTART_REC.

/
FD  RES_AUDIT_RPT is external.
01  AUDIT_RPT_REC	pic x(132).

FD  RES_AUDIT_RESTART_RPT.
01  AUDIT_RESTART_REC   pic x(132).

/
FD  RES_IMPOUND_RPT is external.
01  IMPOUND_RPT_REC	pic x(132).


FD  RES_IMPOUND_RESTART_RPT.
01  IMPOUND_RESTART_REC pic x(132).

/
FD  RES_REJECT_RPT.
01  REJ_RPT_REC		pic x(132).


FD  RES_REJECT_RESTART_RPT.
01  REJ_RESTART_REC     pic x(132).

/
FD  SUMMARY_RPT.
01  SUMMARY_LINE	pic x(132).


FD  SUMMARY_RESTART_RPT.
01  SUMMARY_RESTART_REC pic x(132).

FD  SUMMARY_PARCEL_RPT.
01  SUMMARY_PARCEL_LINE	pic x(132).

/
SD  SUMMARY_SORT_FIL
    DATA RECORD IS SUMMARY_SORT_REC.

01  SUMMARY_SORT_REC.
    05  PARCEL_NUM.
	10  PARCEL_BMI		PIC 9(8).
	10  PARCEL_SPLIT	PIC X.
    05  SUMMARY_RPT_DETAIL	PIC X(132).

FD  SUMMARY_RESTART_IN_FIL
    DATA RECORD IS SUMMARY_RESTART_IN_REC.

01  SUMMARY_RESTART_IN_REC.
    05  PARCEL_NUM.
	10  PARCEL_BMI		PIC 9(8).
	10  PARCEL_SPLIT	PIC X.
    05  SUMMARY_RPT_DETAIL	PIC X(132).

FD  SUMMARY_IN_FIL
    DATA RECORD IS SUMMARY_IN_REC.

01  SUMMARY_IN_REC.
    05  PARCEL_NUM.
	10  PARCEL_BMI		PIC 9(8).
	10  PARCEL_SPLIT	PIC X.
    05  SUMMARY_RPT_DETAIL	PIC X(132).

FD  SUMMARY_OUT_FIL
    DATA RECORD IS SUMMARY_OUT_REC.

01  SUMMARY_OUT_REC.
    05  PARCEL_NUM.
	10  PARCEL_BMI		PIC 9(8).
	10  PARCEL_SPLIT	PIC X.
    05  SUMMARY_RPT_DETAIL	PIC X(132).

/
FD  RES_CSH_TOTALS_RPT.
01  CSH_TOTALS_RPT_REC	pic x(132).
/
FD  RES_MTG_REF_RPT is external
    value OF id is WS_RES_MTG_REF_RPT_SPEC.
01  MTG_REF_RPT_REC	pic x(132).

FD  RES_NUM_WORK_FIL.
01  RES_NUM_WORK_REC.
	10  RES_NUM			PIC 9(5).
	10  ITEM_CNT			PIC 9(4).
	10  GROUP_TYPE                  PIC S9(4) COMP.
            88  SPLIT_COMBINE_TYPE       VALUE 1.
            88  COMMON_TYPE              VALUE 2.
            88  NO_GROUP_TYPE            VALUE 3.
	

FD  LETTER_TOTAL_RPT
    RECORD VARYING FROM 0 TO 80 CHARACTERS DEPENDING ON WS_LETTER_REC_LEN.

01  LETTER_TOTAL_RPT_REC		PIC X(80).

/

working-storage section.

&RDB& invoke database global property = filename 'prop$db:property'

&RDB& invoke database global nextis = filename 'nextis$db'

/
01	COM_ERR_STRUCTURE	external.
	copy "COM$CDD.wsrec.ERR_COMMON" from dictionary
		replacing 04 by 05
			  03 by 04
		   	  02 by 03
			  01 by 02.
/
copy "cobol$copylib:ERROR_CODES".
/
copy "cobol$copylib:REASON_CODES".
/
copy "cobol$copylib:GBL_PARAM_VALUES".
/
copy "com$cdd.linkrec.GET_PARCEL_LKG" from dictionary.
/
copy "com$cdd.linkrec.GET_CURRENT_NAME_ADDR_LKG" from dictionary. 
/
copy "com$cdd.linkrec.get_current_parcel_na_lkg" from dictionary.
/
copy "COM$CDD.LINKREC.GET_SELECT_GBL_PARAMS_LKG" from dictionary.
/
copy "com$cdd.linkrec.GET_TAX_EXT_DATA_LKG" from dictionary.
/
copy "com$cdd.dbrec.RES_PHASE_LIST_REC" from dictionary.
/
copy "com$cdd.linkrec.GET_RES_PROP117_CHANGE_LKG" from dictionary.
/
copy "com$cdd.dbrec.RESOLUTIONS_REAPPLY_REC" from dictionary.
/
copy "com$cdd.linkrec.TRANSLATE_LOGICAL_LKG" from dictionary.
/
copy "com$cdd.linkrec.GET_CP_LKG" from dictionary.
/
copy "com$cdd.linkrec.GET_RESOLUTIONS_REC_LKG" from dictionary.
/
copy "com$cdd.linkrec.DETERMINE_BTX_CP_CODE_LKG" from dictionary.
/
copy "res$cdd.linkrec.MOD_RESOLUTIONS_REC_LKG" from dictionary.
/
copy "com$cdd.include.NUMBERS_AND_LETTERS" from dictionary.
/
copy "res$cdd.linkrec.STORE_MTG_CO_REFUNDS_LKG" from dictionary.
/
copy "res$cdd.linkrec.RESTORE_PMTS_LKG" from dictionary.
/
copy "res$cdd.linkrec.CANCEL_TAX_LKG" from dictionary.
/
copy "res$cdd.linkrec.ARCHIVE_LKG" from dictionary.
/
copy "res$cdd.linkrec.POST_NEW_TAX_LKG" from dictionary.
/
copy "res$cdd.linkrec.REAPPLY_PMTS_LKG" from dictionary.
/
copy "res$cdd.linkrec.REAPPLY_SPLIT_PMTS_LKG" from dictionary.
/
copy "res$cdd.linkrec.WRITE_TO_IMPOUND_LKG" from dictionary.
/
copy "com$cdd.linkrec.GET_CURRENT_DATE_TIME_LKG" from dictionary.
/
copy "com$cdd.linkrec.PROG_RESTART_LKG" from dictionary.
/
copy "COM$CDD.INCLUDE.TAX_SPEC_DIST_DEFINITION" from dictionary.
/
copy "COM$CDD.INCLUDE.TAX_AREA_CODE_DEFINITION" from dictionary.
/
COPY "COM$CDD.LINKREC.GET_MINIMUM_FULL_TAX_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.REFUND_SLIP_DB_LKG" FROM DICTIONARY.
/
COPY "RES$CDD.LINKREC.DISAPPROVE_RES_NUM_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.REPLACE_STRING_LKG" FROM DICTIONARY. 
/
COPY "COM$CDD.LINKREC.JULCAL_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.CALC_SECURED_DUE_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.CALJUL_LKG" FROM DICTIONARY. 
/
COPY "COM$CDD.DBREC.LP_DETAIL_REC" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.CALC_PERS_PROP_DUE_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.DATE_CONVERT_LKG" FROM DICTIONARY. 
/
COPY "COM$CDD.LINKREC.GET_UPPS_LEVY_TYPE_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.MCT_WAIT_LKG" FROM DICTIONARY.
/
COPY "RES$CDD.LINKREC.RECALC_RESINT_PCTS_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.GLOBAL_PARAM_LKG" FROM DICTIONARY.
/
COPY "COM$CDD.LINKREC.GET_CFD_PARCEL_LKG" FROM DICTIONARY.
/
*
*   local work area values
*
01  IS_TRANS_ACTIVE			pic x.
    88 TRANS_ACTIVE     value is "Y".
    88 TRANS_NOT_ACTIVE value is "N".

01  WS_NUM_SPEC_DIST			PIC 99.
01  WS_RES_MTG_REF_RPT_SPEC		PIC X(100) EXTERNAL.
01  WS_RES_INT_PRI			pic s9(16)v9(2).
01  WS_RES_INT_SEC			pic s9(16)v9(2).
01  WS_AREA_CODE_PRIMARY_INT		pic s9(16)v9(2).
01  WS_AREA_CODE_SECONDARY_INT		pic s9(16)v9(2).
01  WS_TOT_SPEC_INT			pic s9(16)v9(2).
01  WS_TOTAL_SPEC_INT			pic s9(16)v9(2).
01  WS_FLOOD_INT			pic s9(16)v9(2).
01  WS_INT_BUCKET_FOUND			pic x(3).
01  WS_DISP_INT				PIC Z(15)9.99-.
01  WS_INDX				pic 99.
01  WS_DIST_INT				pic s9(16)v9(2).
01  WS_DIST_INTX REDEFINES WS_DIST_INT  PIC 9(16)V9(2)-.
01  WS_HALF_TAX				PIC S9(16)V9(2).
01  WS_AMT_X				PIC ZZZ,ZZ9.99.

01  WS_EXCEPTION_TXT			PIC X(60).

01  WS_FIRST_PAGE			PIC X(3).
01  WS_READ_CNT				PIC 9(9).
01  WS_REAPPLY_SPLIT_PMT_FLG		PIC X.

01  WS_BTX_CTX_FLG			pic x.
01  WS_RES_INT_BUCKET_FLG		PIC X.

01  WS_RUN_MODE_FLG			PIC X.
    88  EDIT_MODE_RUN			 VALUE "E".
    88  UPDATE_MODE_RUN			 VALUE "U".

01  WS_TRANS_MODE			PIC X.
    88  RO_TRANS			 VALUE "R".
    88  RW_TRANS			 VALUE "W".
01  WS_PARCEL_COUNT_TOT			PIC 999999	VALUE 0.
01  WS_PARCELS_PROCESSED		PIC 999999	VALUE 0.
01  WS_PARCELS_SINCE_TIME		PIC 999		VALUE 0.

                   
01  SD_IX				pic 99.
01  WS_MAX_NUM_SD			pic 99 value 10.
01  PMT_IX				PIC 9(3).
01  DETAIL_IX				PIC 9(4).

01	WS_TAX_YEAR				pic 9(4).
01	WS_RES_DATE			       	pic s9(4) comp.
01	WS_RES_PHASE_NUM			pic 9(4).
01	WS_RES_NUM				pic 9(5).
01	WS_RES_REASON				pic 9(2).
01	WS_CTR_NUM				pic 9(5).
01	WS_ASSESSED_TAX_CANCELED		pic 9(16)v99.
01	WS_RES_INT_TMP				pic s9(16)v9(2).
01  	WS_NEW_ASSESSED_TAX			PIC 9(16)V9(2).

01	WS_RES_NUM_RESTORE_AMT			PIC 9(16)V9(2).
01	WS_RES_NUM_REAPPLY_AMT			PIC 9(16)V9(2).
01	WS_RES_NUM_NEW_ASSESSED_TAX		PIC 9(16)V9(2).

01	WS_TMP_AMT				PIC 9(16)V9(2).

01  WS_LOAN_NUM.
    02  WS_LOAN_NUM_1_8		pic x(8).
    02  WS_LOAN_NUM_9_12	pic x(4).

01  DISPLAY_PARCEL.
    03  NUM_PART     		PIC 9(8).
    03  SPLIT_PART		PIC X.

01  WS_BOOK_MAP_ITEM		pic 9(8).
01  FILLER	redefines WS_BOOK_MAP_ITEM.
    02  WS_PARCEL_BOOK		pic 9(3).
    02  WS_PARCEL_MAP		pic 9(2).
    02  WS_PARCEL_ITEM		pic 9(3).

01  WS_AT_END_FLG 			pic x.
    88  AT_END_FLG	value "Y".

01  WS_LETTER_RESTART_EOF		PIC X.
    88  LETTER_RESTART_EOF		VALUE "Y".

01  WS_REJ_RPT_STATUS			pic x.
    88  REJECT_RPT_OPEN      value "Y".
    88  REJECT_RPT_NOT_OPEN  value "N".

01  CP_STATUS				pic x.
    88  STATE_CP	      value "S".
    88  NO_CP		      value "N".
    88  PARCEL_HAS_CP_HOLDER  value "Y".
    88  PARCEL_HAS_PENDING_CP value "P".

01  WS_RESTORE_PMTS_ERROR		pic x.
    88  RESTORE_PMTS_ERROR value "Y".
01  WS_CANCEL_TAX_ERROR			pic x.
    88  CANCEL_TAX_ERROR  value "Y".
01  WS_INT_AREA_CODE			PIC X(6).

01  WS_SKIP_THIS_PARCEL			PIC X(3).
01  WS_UNSECURED_PHASE			PIC X(3).

01  WS_RES_NUM_FLG			PIC X.
    88  ACCEPT_RES_NUM			 VALUE "Y".
    88  REJECT_RES_NUM			 VALUE "N".
01  WS_CURR_RES_NUM			PIC 9(5).
01  WS_CURR_PARCEL_NUM.
    05  WS_CURR_PARCEL_BMI		PIC 9(8).
    05  WS_CURR_PARCEL_SPLIT		PIC X.
01  REPROCESSING_DEADLOCKED_SW			PIC X VALUE "N".
	88	REPROCESSING_DEADLOCKED_DATA	VALUE "Y".
	88	NOT_REPROCESSING_DEADLOCK	VALUE "N".
01  RES_NUM_WORK_REC_SW			PIC X.
	88	RES_NUM_WORK_HAS_DATA	VALUE "Y".
	88	RES_NUM_WORK_NO_DATA	VALUE "N".
**01  RES_NUM_IX				PIC 9(4).
**01  RES_NUM_TABLE_CNT			PIC 9(4).
**01  RES_NUM_TABLE.
**    05  RES_NUM_TABLE_REC		OCCURS 5000 TIMES.
**	10  RES_NUM			PIC 9(5).
**	10  ITEM_CNT			PIC 9(4).
**	10  SPLIT_COMBINE_FLG		PIC X.

01  WS_RES_NUM_PMT_IX			PIC 9(5).
 COPY "RES$CDD.INCLUDE.PMT_TABLE_LARGE" FROM DICTIONARY
	REPLACING PMT_TABLE_LARGE BY WS_RES_NUM_PMT_TABLE.

01  IX                                  PIC 99.

01  WS_PROG_RESTART_DBKEY		PIC X(8).
01  WS_RESTART_FOUND_FLG		PIC X.

01  WS_LETTER_REC_LEN			PIC 9(4) COMP.

01  WS_CFD_CANCEL_FLG			PIC X.
01  WS_CFD_NEW_CNT			PIC 9(4) COMP.

/
*********************
* WS_RESTART_BUFFER *
*********************

01  WS_RESTART_BUFFER.
    05  WS_PHASE_NUM			PIC 9(4).
    05  WS_RES_YEAR			PIC 9(4).
    05  WS_RUN_MODE			PIC X.
    05  WS_PREV_AREA_CODE		PIC X(6).
    05  WS_TOTALS.
	10  WS_NUM_RECS_READ		PIC 9(6).
	10  WS_TOT_RESTORED_PMTS	PIC 9(16)V9(2).
	10  WS_TOT_CANCELLED_TAX	PIC 9(16)V9(2).
	10  WS_TOT_NEW_TAX		PIC 9(16)V9(2).
	10  WS_TOT_REAPPLIED_PMTS	PIC 9(16)V9(2).
	10  WS_TOT_PREPMT_IMPOUND	PIC 9(16)V9(2).
	10  WS_TOT_LIT_IMPOUND		PIC 9(16)V9(2).
	10  WS_TOT_RES_IMPOUND		PIC 9(16)V9(2).
	10  WS_TOT_RES_INTEREST		PIC 9(16)V9(2).
        10  WS_TOT_OVER_UNDER_IMPOUND	PIC S9(16)V9(2).
	10  WS_TOT_RES_FEE_AMT		PIC 9(16)V9(2).
    05  WS_LAST_RES_NUM			PIC 9(5).
    05  WS_NEXTIS_SLIP_ID               PIC 9(9).
    05  FILLER				PIC X(37).

* ***********************************************************
* The following variables are added to support nexTIS Refunds
* ***********************************************************

01  WS_RESO_REFUND_TYPE_ID              PIC S9(4) COMP VALUE 4.
01  WS_WORKING_SLIP_TYPE_ID             PIC S9(4) COMP VALUE 2.
01  WS_RESO_PHASE_USER_ID               PIC S9(4) COMP VALUE 58.
01  WS_SLIP_READY_STATUS_ID             PIC S9(4) COMP VALUE 1.
01  WS_REFUND_SLIP_ID                   PIC S9(9) COMP.
01  WS_NEXTIS_DATE                      PIC X(10).
01  WS_MONTH                            PIC X(2).

/
01  DCL_SYMBOL_VALUE                        PIC --------9.
01  DCL_TABLE_IND                           PIC S9(9) COMP
                                            VALUE EXTERNAL LIB$K_CLI_GLOBAL_SYM.
*
*
COPY "COBOL$COPYLIB:RES_PHASE_HDR_DATA".

01  SUM_LINE_CTR	pic 999.
01  MAX_SUM_LINE_CTR	pic 999 value 57.
01  SUM_PAGE_CTR	pic 999 value 0.
01  SUM_NUM_PARCELS     PIC 9(9).
01  SUMMARY_PCOUNT_LINE.
    02  FILLER PIC X(19) VALUE "Number of Parcels: ".
    02  TOTS_PARCELS PIC ZZZ,ZZ9. 

01  SUM_HEADER_1.
    02  FILLER                            PIC X(43)
          VALUE "PROGRAM ID: RES PHASE_PROCESSING_BY_RES_NUM".
    02  FILLER                            PIC X(78) VALUE SPACES.
    02  RPT_HDR1_DATE			  PIC X(11).

01  SUM_HEADER_2.
    02  FILLER                            PIC X(31) VALUE SPACES.
    02  FILLER                            PIC X(64)
       VALUE "M A R I C O P A  C O U N T Y  T R E A S U R E R ' S  O F F I C E".
    02  FILLER                            PIC X(26) VALUE SPACES.
    02  FILLER                            PIC X(7) VALUE "PAGE:  ".
    02  PAGE_NUM                          PIC ZZZ9.
    
01  SUM_HEADER_3.
    02  FILLER                            PIC X(34) VALUE SPACES.
    02  FILLER                            PIC X(59)
          VALUE "RESOLUTION SUMMARY REPORT (BY RESOLUTION NUMBER) FOR PHASE ".
    02  SUM_HEADER_3_INFO		PIC X(30).

01  SUM_PARCEL_HEADER_3.
    02  FILLER                            PIC X(37) VALUE SPACES.
    02  FILLER                            PIC X(55)
          VALUE "RESOLUTION SUMMARY REPORT (BY PARCEL NUMBER) FOR PHASE ".
    02  SUM_PARCEL_HEADER_3_INFO	PIC X(30).

01  SUM_HEADER_4.
    02  FILLER			      	  PIC X(31) VALUE
           "             TAX    RES  REASON".
    02  FILLER			      	  PIC X(66) VALUE SPACES.
    02  FILLER				  PIC X(10) VALUE
           "RESOLUTION".

01  SUM_HEADER_5.
    02  FILLER				  PIC X(66) VALUE
           "PARCEL NUM   YEAR   NUM   CODE     CANCELED TAX    ASSESSED TAX   ".
    02  FILLER				  PIC X(56) VALUE
           "RESTORED PMTS  REAPPLIED PMTS   INTEREST         RESULTS".
01  SUM_HEADER_6.
    02  FILLER				  PIC X(78) VALUE
           "----------  ----  -----  ----   --------------  --------------  --------------".
    02  FILLER				  PIC X(53) VALUE
           "  --------------  ----------  -----------------------" .

01  SUMMARY_RPT_LINE.
    02  BOOK		pic 9(3).
    02  DASH1 		pic x     value "-".
    02  MAP 		pic 9(2).
    02  DASH2 	      	pic x     value "-".
    02  ITEM		pic 9(3).
    02  SPLIT  		pic x.
    02  FILLER		pic x(2) value spaces.
    02  TAX_YEAR	pic 9(4).
    02  FILLER		pic x(2) value spaces.
    02  RES_NUM		pic 9(5).
    02  FILLER		pic x(3) value spaces.
    02  REASON_CODE	pic 9(2).
    02  FILLER		pic x(4) value spaces.
    02  CANCELED_TAX	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2)  value spaces.
    02  NEW_TAX		pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2)  value spaces.
    02  RESTORED_PMTS	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2)  value spaces.
    02  REAPPLIED_PMTS	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2)  value spaces.
    02  RES_INTEREST	pic ZZZ,ZZZ.ZZ.
    02  FILLER		pic x(2)  value spaces.
    02  PMT_DIFF	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2)  value spaces.
    02  RESULT		pic x(7).
        88  REFUND_RESULT	 value "Refund ".
        88  RES_IMPOUND_RESULT	 value "Fund 33".
        88  LIT_IMPOUND_RESULT	 value "Fund 34".
	88  PREPMT_IMPOUND_RESULT
				 value "Fund 94".
        88  UNDER_PAYMENT_RESULT value "Due    ".
        88  OVER_UNDER_RESULT    value "Fund 28".
        88  NO_EFFECT_RESULT	 value spaces.

01  SUMMARY_DASHES.
    02  FILLER		pic x(33) value spaces.
    02  FILLER		pic x(16) value "--------------  ".
    02  FILLER		pic x(16) value "--------------  ".
    02  FILLER		pic x(16) value "--------------  ".
    02  FILLER		pic x(16) value "--------------  ".
    02  FILLER		pic x(16) value "  --------------".

01  SUMMARY_TOTAL_LINE.
    02  FILLER		pic x(33) value spaces.
    02  TOT_CAN_TAX	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2) value spaces.
    02  TOT_NEW_TAX	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2) value spaces.
    02  TOT_REST_PMTS	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2) value spaces.
    02  TOT_REAP_PMTS	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(2) value spaces.
    02  TOT_RES_INT	pic ZZZ,ZZZ,ZZ9.99.

/

01  REJ_CTR		pic 999.
01  MAX_REJ_CTR		pic 999 value 7.
01  REJ_PAGE_CTR	pic 999.
01  MAX_REJ_SD_VALUE	pic 9(4) comp value 3.
01  REJ_SD_IX		pic 9(4) comp.

01  REJ_HEADER_1.
    02  FILLER                            PIC X(43)
          VALUE "PROGRAM ID: RES PHASE_PROCESSING_BY_RES_NUM".
    02  FILLER                            PIC X(78) VALUE SPACES.
    02  RPT_HDR1_DATE			  PIC X(11).

01  REJ_HEADER_2.
    02  FILLER                            PIC X(31) VALUE SPACES.
    02  FILLER                            PIC X(64)
       VALUE "M A R I C O P A  C O U N T Y  T R E A S U R E R ' S  O F F I C E".
    02  FILLER                            PIC X(26) VALUE SPACES.
    02  FILLER                            PIC X(7) VALUE "PAGE:  ".
    02  PAGE_NUM                          PIC ZZZ9.

01  REJ_HEADER_3.
    02  FILLER                            PIC X(44) VALUE SPACES.
    02  FILLER                            PIC X(35)
          VALUE "RESOLUTION REJECT REPORT FOR PHASE ".
    02  REJ_HEADER_3_INFO		PIC X(30).

01  REJ_RPT_LINE_1H1.
    02  FILLER		pic x(40) value
		"  Parcel Number   Year    AC    Land  Im".
    02  FILLER		pic x(40) value
		"prove  Resid %   AC Primary Tax     Floo".
    02  FILLER		pic x(40) value
		"d Tax        Other Tax       Reason".

01  REJ_RPT_LINE_1H2.
    02  FILLER		pic x(40) value
		"  -------------   ----  ------  ----  --".
    02  FILLER		pic x(40) value
		"-----  -------   --------------   ------".
    02  FILLER		pic x(52) value
		"--------   --------------   ------------------------".
01  THE_REJECT_REASON	PIC X(24) VALUE SPACES.
01  REJ_RPT_LINE_1.
    02  FILLER		pic x(3).
    02  PARCEL_BOOK     pic 9(3).
    02  DASH1		pic x.
    02  PARCEL_MAP	pic 9(2).
    02  DASH2		pic x.
    02  PARCEL_ITEM	pic 9(3).
    02  PARCEL_SPLIT	pic x.
    02  FILLER		pic x(4).
    02  TAX_YEAR	pic 9(4).
    02  FILLER		pic x(2).
    02  AREA_CODE	pic x(6).
    02  FILLER		pic x(3).
    02  LAND_CLASS_CODE	pic 9(2).
    02  FILLER		pic x(6).
    02  IMPROVE_CLASS_CODE pic 9(2).
    02  FILLER		pic x(6).
    02  RESID_PCT	pic 9.9(2).
    02  FILLER		pic x(4).
    02  PRIMARY_TAX	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(3).
    02  FLOOD_TAX	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		pic x(3).
    02  OTHER_TAX	pic ZZZ,ZZZ,ZZ9.99.
    02  FILLER		PIC X(3).
    02  REJ_RPT_REASON	PIC X(24).
01  REJ_RPT_LINE_2H1.
    02  FILLER		pic x(44) value
		"            ------------------------ PRIMARY".
    02  FILLER		pic x(44) value
		" -------------------------    --------------".
    02  FILLER		pic x(44) value
		"--------- SECONDARY ------------------------".

01  REJ_RPT_LINE_2H2.
    02  FILLER		pic x(44) value
		"            Full Cash Value   Ratio   Assess".
    02  FILLER		pic x(44) value
		"ed Value    Exempt Amount    Full Cash Value".
    02  FILLER		pic x(44) value
		"   Ratio   Assessed Value    Exempt Amount".

01  REJ_RPT_LINE_2.
    02  FILLER		pic x(10).
        88  LAND_TYPE		value "LAND:".
        88  IMPROVE_TYPE	value "IMPROVE:".
        88  PERS_PROP_TYPE	value "PERS PROP:".
    02  FILLER		pic x(2).
    02  PRI_FCV		pic ZZZZ,ZZZ,ZZZ,ZZ9.
    02  FILLER		pic x(3).
    02  PRI_RATIO	pic 9(3).
    02  FILLER		pic x(3).
    02  PRI_ASSD_VALUE	pic ZZZZ,ZZZ,ZZZ,ZZ9.
    02  FILLER		pic x(2).
    02  PRI_EXEMPT_AMT	pic ZZZZ,ZZZ,ZZZ,ZZ9.
    02  FILLER		pic x(2).
    02  SEC_FCV		pic ZZZZ,ZZZ,ZZZ,ZZ9.
    02  FILLER		pic x(3).
    02  SEC_RATIO	pic 9(3).
    02  FILLER		pic x(3).
    02  SEC_ASSD_VALUE	pic ZZZZ,ZZZ,ZZZ,ZZ9.
    02  FILLER		pic x(2).
    02  SEC_EXEMPT_AMT	pic ZZZZ,ZZZ,ZZZ,ZZ9.

01  REJ_RPT_LINE_3H1.
    02  FILLER		pic x(44) value
		"   DIST       Assessed          Tax Amt     ".
    02  FILLER		pic x(44) value
		"   DIST       Assessed          Tax Amt     ".
    02  FILLER		pic x(44) value
		"   DIST       Assessed          Tax Amt     ".

01  REJ_RPT_LINE_3H2.
    02  FILLER		pic x(44) value
		"   -----  ----------------  ----------------".
    02  FILLER		pic x(44) value
		"   -----  ----------------  ----------------".
    02  FILLER		pic x(44) value
		"   -----  ----------------  ----------------".

01  REJ_RPT_LINE_3.
    02  REJ_RPT_LINE_3_DETAIL occurs 3 times.
        03  FILLER		pic x(3).
        03  DIST		pic x(5).
        03  FILLER		pic x(2).
        03  ASSR_ACRES_VALUE	pic ZZZZ,ZZZ,ZZZ,ZZ9.
        03  ASSR_ACRES_FLG	pic x.
        03  FILLER		pic x.
        03  SPEC_DIST_TAX_AMT 	pic z,ZZZ,ZZZ,ZZ9.99.

/
01  CSH_HEADER_1.
    02  FILLER                            PIC X(43)
          VALUE "PROGRAM ID: RES PHASE_PROCESSING_BY_RES_NUM".
    02  FILLER                            PIC X(78) VALUE SPACES.
    02  RPT_HDR1_DATE			  PIC X(11).

01  CSH_HEADER_2.
    02  FILLER                            PIC X(31) VALUE SPACES.
    02  FILLER                            PIC X(64)
       VALUE "M A R I C O P A  C O U N T Y  T R E A S U R E R ' S  O F F I C E".

01  CSH_HEADER_3.
    02  FILLER                            PIC X(48) VALUE SPACES.
    02  FILLER                            PIC X(28)
          VALUE "TOTALS FOR RESOLUTION PHASE ".
    02  CSH_HEADER_3_INFO		PIC X(30).
01  CSH_DETAIL_LINE.
    02  FILLER		pic x(28) value spaces.
    02  FILLER	   	pic x(20).
        88  CTX_FLG		value "Current Tax Payments".
        88  BTX_FLG		value "   Back Tax Payments".
        88  RES_FEE		value "      Reapplied Fees".
        88  RES_IMP		value "  Resolution Impound".
        88  LIT_IMP		value "  Litigation Impound".
	88  PREPMT_IMP		value "  Prepayment Impound".
	88  OVER_UNDER_IMP	value "  Over/Under Impound".
        88  RES_CTR		value "     Cash Transfer #".
        88  RES_INT		value " Resolution Interest".
        88  RES_CAN		value "        Canceled Tax".
        88  RES_NEW		value "             New Tax".
	88  RESTORE_TOT		value "   Restored Payments".
    02  CTR_NUM		pic ZZZZZ.
    02  FILLER		pic x(5) value spaces.
    02  TRANS_AMT	pic ZZZ,ZZZ,ZZ9.99-.

01  WS_TIMESTAMP        PIC X(23).

/
********************************************************
* The following definitions are for Resolution Letters *
******************************************************** 
* this structure holds the information that allows me to determine what kind
* of letter I need to write.  It also holds some extra information for the
* amounts due and due dates.

01  WS_PROC_LETTER.
    02	RES_REASON		    PIC S9(2) COMP.
    	88  JUDGEMENT               VALUE IS 19.
    	88  EXEMPT_STATUS_CHG       VALUE IS 8.
    02	ASSR_EXEMPT_CODE 	    PIC X.
	88 FULL_EXEMPT              VALUES ARE "E" "S".
	88 PART_EXEMPT              VALUE IS "P".
    02  AMT_DUE_1ST_HALF            PIC S9(16)V9(2) COMP.
    02  AMT_DUE_2ND_HALF            PIC S9(16)V9(2) COMP.    
    02  DUE_DATE_1ST_HALF           PIC X(18). 
    02  DUE_DATE_2ND_HALF           PIC X(18). 
    02	TOTAL_DUE 		    PIC S9(16)V9(2) COMP.	
    02 	DUE_FLG			    PIC X.
	88 SECOND_HALF 		    VALUE IS "S".
	88 FULL_YEAR 		    VALUE IS "F".       
    02  AMT_IMPOUNDED               PIC S9(16)V9(2) COMP.	
    02	REF_APPROVED_FLG	    PIC X.
    02  TITLE_CO_FLG                PIC X. 
    02  REFUND_CLERK_ID		    PIC X(3).    
    02  RESULT_TYPE                 PIC X. 
        88  UNDER_PAYMENT_RESULT    VALUE IS SPACES.
        88  REFUND_RESULT   	    VALUE IS "R".
        88  LIT_IMPOUND_RESULT      VALUE IS "L".
        88  RES_IMPOUND_RESULT      VALUE IS "I".
        88  PREPMT_RESULT           VALUE IS "P".
        88  NO_EFFECT_RESULT        VALUE IS "N".
        88  OVER_UNDER_RESULT       VALUE IS "O". 
    02  CTX_BTX_VAL		    PIC X(3).
        88  CTX			    VALUE IS "CTX".
        88  BTX		  	    VALUE IS "BTX".
    02  TAX_DUE_1ST_HALF            PIC S9(16)V9(2) COMP.
    02  TAX_DUE_2ND_HALF            PIC S9(16)V9(2) COMP.
    02  TAX_DUE 	            PIC S9(16)V9(2) COMP.
    02  INT_DUE_1ST_HALF 	    PIC S9(16)V9(2) COMP.
    02  INT_DUE_2ND_HALF	    PIC S9(16)V9(2) COMP.
    02  INT_DUE 		    PIC S9(16)V9(2) COMP.
    02  FEES_DUE_1ST_HALF	    PIC S9(16)V9(2) COMP.
    02  FEES_DUE_2ND_HALF	    PIC S9(16)V9(2) COMP.
    02	FEES_DUE                    PIC S9(16)V9(2) COMP. 
    02  SPEC_INT_FLG                PIC X. 
    02  SPEC_INT_EXPIRE_DATE	    PIC S9(4) COMP. 

/
01  WS_LETTER_COUNTERS.
    02  FULL_YEAR			PIC 9(5).      
    02  2ND_HALF			PIC 9(5).      
    02  ZERO_DUE			PIC 9(5).  
    02  REFUND				PIC 9(5).   
    02  3RD_PARTY_REFUND		PIC 9(5).  
    02  REFUND_CHECK			PIC 9(5).  
    02  PART_EXEMPT_FULL_YEAR		PIC 9(5).  
    02  PART_EXEMPT_2ND_HALF		PIC 9(5).  
    02  PART_EXEMPT_ZERO	        PIC 9(5).  
    02  PART_EXEMPT_REFUND 		PIC 9(5).  
    02  PART_EXEMPT_3RD_PARTY_REFUND    PIC 9(5).
    02  PART_EXEMPT_REFUND_CHECK        PIC 9(5).
    02  EXEMPT   			PIC 9(5).
    02  EXEMPT_REFUND  		 	PIC 9(5).
    02  EXEMPT_3RD_PARTY_REFUND		PIC 9(5).
    02  EXEMPT_REFUND_CHECK		PIC 9(5).
    02  UNKNOWN				PIC 9(5). 
    02  FULL_YEAR_TOT			PIC 9(5).
    02  2ND_HALF_TOT			PIC 9(5).
    02  ZERO_DUE_TOT      		PIC 9(5).
    02  REFUND_TOT   	       	  	PIC 9(5).  
    02  3RD_PARTY_REFUND_TOT		PIC 9(5). 
    02  REFUND_CHECK_TOT		PIC 9(5). 
    02  GRAND_TOT			PIC 9(5). 

* these will be added for group letters. 
*   02  SPLIT_EXEMPT   			PIC 9(5).
*   02  COMMON_REFUND  			PIC 9(5).
*   02  COMMON_ZERO			PIC 9(5).  
*   02  SPLIT_ZERO			PIC 9(5).  
*   02  SPLIT_PART_EXEMPT_ZERO		PIC 9(5).  
*   02  COMMON_2ND_HALF			PIC 9(5).  
*   02  SPLIT_2ND_HALF			PIC 9(5).  
*   02  SPLIT_PART_EXEMPT_2ND_HALF      PIC 9(5).  
*   02  COMMON_FULL_YEAR		PIC 9(5).  
*   02  SPLIT_PART_EXEMPT_FULL_YEAR	PIC 9(5).  
*   02  SPLIT_FULL_YEAR			PIC 9(5).  

01  WS_DISPLAY_COUNTER                           PIC ZZ,ZZ9.


/
*  The WS_RES_LETTER_TYPE value is used for 3 reasons
*  a. To discern what to store in the reso type 
*     letter field (standard, partial exemption,full exemption, etc) 
*  b. The values of the 88's correspond with the letter text 
*     id's in the database.  Once I know what kind of a letter
*     I need to write I set this value and later on I get the text
*     for that letter using this value. 
*  c. This helps increment the counter after the letter has been 
*     written. Since I know what kind of letter I have I can easily 
*     increment the counters in the structure above (WS_LETTER_COUNTERS).
*  You might notice that EXEMPT has an odd looking number.  This number does
*  not follow the pattern because it does not require letter text in the 
*  database, so it was assigned a number outside of the forseeable range of 
*  letter text id's. 
 
01  WS_RES_LETTER_TYPE		      PIC 9(3).
    88  TAX_BILL		      VALUE IS 1. 
    88  FULL_YEAR	 	      VALUE IS 2.
    88  2ND_HALF 		      VALUE IS 3. 
    88  ZERO_DUE    	              VALUE IS 4.   
    88  REFUND			      VALUE IS 5.
    88  3RD_PARTY_REFUND              VALUE IS 6. 
    88  REFUND_CHECK		      VALUE IS 7.  
    88  PART_EXEMPT_FULL_YEAR         VALUE IS 8. 
    88  PART_EXEMPT_2ND_HALF          VALUE IS 9. 
    88  PART_EXEMPT_ZERO	      VALUE IS 10. 
    88  PART_EXEMPT_REFUND            VALUE IS 11.
    88  PART_EXEMPT_3RD_PARTY_REFUND  VALUE IS 12. 
    88  PART_EXEMPT_REFUND_CHECK      VALUE IS 13.  
    88  EXEMPT_REFUND 	   	      VALUE IS 14.
    88  EXEMPT_3RD_PARTY_REFUND       VALUE IS 15. 
    88  EXEMPT_REFUND_CHECK           VALUE IS 16. 
    88  EXEMPT			      VALUE IS 50. 	

/
* this table holds the text for the letters
01  WS_RES_LETTER_TEXT.
    02  MY_TABLE OCCURS 50 TIMES
	INDEXED BY LETTER_INDEX.
    	03  LETTER_ID	    PIC 9(3).
    	03  LETTER_DESC     PIC X(40).
    	03  LETTER_TEXT	    PIC X(500).
    
01  WS_TEXT_INDEX      PIC 9(3).     
  
/
* misc res letter working storage 
01  WS_PARCEL_NO.
    02  BOOK       PIC 9(3).
    02  DASH1      PIC X.
    02  MAP        PIC 9(2).
    02  DASH2      PIC X.
    02  ITEM       PIC 9(3).

01  WS_TEMP_AMT              PIC 9(16)V99.
01  WS_TEMP_AMT_Z            PIC Z,ZZZ,ZZZ,ZZZ,ZZ9.99.
01  WS_LP_AMT                REDEFINES WS_TEMP_AMT_Z PIC X(20). 

01  WS_PHASE_Z               PIC Z(5).
01  WS_PHASE                 REDEFINES WS_PHASE_Z PIC X(5).       

01  WS_POS		     PIC 9(4) COMP.
01  WS_LENGTH		     PIC 9(4) COMP. 

01  WS_TAX_YR_INT	     PIC 9(4). 
01  WS_TAX_YR                REDEFINES WS_TAX_YR_INT PIC X(20). 

01  WS_TAX_BILL_TEXT         PIC X(500).

01  WS_DEADLOCK              PIC X.

01  WS_DAY_X                 PIC X(2). 
01  WS_DAY                   REDEFINES WS_DAY_X PIC 9(2). 

01  WS_YEAR_X                PIC X(4).  
01  WS_YEAR                  REDEFINES WS_YEAR_X PIC 9(4).

01  WS_NEXT_MONTH_PMT_DATE   PIC S9(4) COMP.

01  WS_FEES_DUE_1ST_HALF     PIC S9(16)V9(2) COMP. 
01  WS_FEES_DUE_2ND_HALF     PIC S9(16)V9(2) COMP. 

01  WS_ERR_RES_NUM	     PIC X(5). 
01  WS_ERR_BMI		     PIC 9(8). 
01  WS_ERR_SPLIT	     PIC X. 

01  WS_DELINQ_NOTICE_DATE    PIC S9(4) COMP. 

01  WS_PARCEL_NO_INT         PIC 9(8). 
01  WS_PARCEL_NO_X           REDEFINES WS_PARCEL_NO_INT PIC X(8).

01  WS_R_RES_NUM_X           PIC X(5). 
01  WS_R_RES_NUM             REDEFINES WS_R_RES_NUM_X PIC 9(5). 

01  WS_DATE_FULL	     PIC X(18). 

01  WS_RTC_COUNT             PIC S9(4) COMP. 

01  WS_TDS_COUNT             PIC 9(5). 

01  FF_LINE.
    05  FILLER				PIC X VALUE FF.
    05  FILLER				PIC X(131) VALUE SPACES.
01  BLANK_LINE				PIC X(132) VALUE SPACES.

01  WS_CFD_COUNT                        PIC 9(9).
01  CFD_IX				PIC 9(4).

01  WS_TODAY_ANSI                       PIC S9(11)V9(7) COMP.

01  WS_FULL_YEAR_INT_DATE_JUL		PIC S9(4) COMP.
01  WS_FULL_YEAR_INT_DATE_ANSI		PIC X(10).
01  WS_LETTER_CALC_DATE			PIC S9(4) COMP.

/

* ********************************************** *
* Judgment Interest - September 2011 - Tar 26004 *
* ********************************************** *

 copy "com$cdd.dbrec.res_phase_rec" from dictionary.
 copy "com$cdd.dbrec.judgment_case_rec" from dictionary.
 copy "com$cdd.dbrec.judgment_case_exception_rec" from dictionary.
 copy "com$cdd.dbrec.judgment_parcel_rec" from dictionary.
 COPY "COBOL$COPYLIB:RES_JUDGE_APPEAL_CODES".

* A recap of the rules coded here in September, 2011.
* 
* 1.  Judgments on/after July 20th, 2011 will be paid pursuant to the rate
*     stated in the Judgment.
* 2.  Judgments before July 20th, 2011 will be paid 10%.
* 3.  Assessor and BOE Claims or Notice of Errors will be paid pursuant to
*     the DOR rate.
* 3.  All other resolutions will be paid zero.
*
* For Judgments we will retrieve the rate from the Judgment Case information
* That is stored in either the JudgmentCaseException table (first place to
* look) or the JudgmentCase table.
*
* For Appeals, the DOR Rate is stored for the phase in the ResPhase row.
*
* For all others, we will use the global ResIntRate which has been changed
* to Zero.
*
*   The program retrieves the global parameter Res Interest Rate during
*   startup (sits in GBL_PARAM_VALUES).  If we have a judgment or appeal 
*   resolution we need to use
*   a different rate when calculating interest for refunds.  These
*   calculations are done in REAPPLY_PMTS and REAPPLY_SPLIT_PMTS.
*   This program passes the correct rate to use as RES_INTEREST_RATE in the
*   subroutine linkage.
*
*   By definition these (judgments/appeals) are all handled through 
*   ProcessSingleReso since these are not group/split/combine resos.  
*   In that paragraph we will determine if we need to get another rate or
*   use the global param value and move the correct one to WS_RES_INT_RATE.
*   This will be used in the ReapplyPmtsLkg instead of the global
*
01  WS_RES_INT_RATE                        PIC S9(2)V9(4).
01  WS_ITEM_FOUND                          PIC X(3).

/
***************************
*** PROCEDURE DIVISION  ***
***************************

procedure division.

DECLARATIVES.

AUDIT_FILE_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_AUDIT_RPT.
HANDLE_AUDIT_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_AUDIT_RPT
                           BY REFERENCE RMS_STV IN RES_AUDIT_RPT.
      MOVE RMS_STS IN RES_AUDIT_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

IMPOUND_FILE_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_IMPOUND_RPT.
HANDLE_IMPOUND_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_IMPOUND_RPT
                           BY REFERENCE RMS_STV IN RES_IMPOUND_RPT.
      MOVE RMS_STS IN RES_IMPOUND_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

LETTER_FILE_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON LETTER_INPUT_FILE.
HANDLE_LETTER_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN LETTER_INPUT_FILE
                           BY REFERENCE RMS_STV IN LETTER_INPUT_FILE.
      MOVE RMS_STS IN LETTER_INPUT_FILE TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

SUMMARY_FILE_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON SUMMARY_RPT.
HANDLE_SUMMARY_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN SUMMARY_RPT
                           BY REFERENCE RMS_STV IN SUMMARY_RPT.
      MOVE RMS_STS IN SUMMARY_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

CSH_FILE_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_CSH_TOTALS_RPT.
HANDLE_CSH_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_CSH_TOTALS_RPT
                           BY REFERENCE RMS_STV IN RES_CSH_TOTALS_RPT.
      MOVE RMS_STS IN RES_CSH_TOTALS_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

SUMMARY_IN_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON SUMMARY_IN_FIL.
HANDLE_CSH_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN SUMMARY_IN_FIL
                           BY REFERENCE RMS_STV IN SUMMARY_IN_FIL.
      MOVE RMS_STS IN SUMMARY_IN_FIL TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

SUMMARY_OUT_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON SUMMARY_OUT_FIL.
HANDLE_CSH_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN SUMMARY_OUT_FIL
                           BY REFERENCE RMS_STV IN SUMMARY_OUT_FIL.
      MOVE RMS_STS IN SUMMARY_OUT_FIL TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

REJECT_FILE_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_REJECT_RPT.
HANDLE_REJECT_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_REJECT_RPT
                           BY REFERENCE RMS_STV IN RES_REJECT_RPT.
      MOVE RMS_STS IN RES_REJECT_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

LETTER_RESTART_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON LETTER_RESTART_FILE.
HANDLE_LETTER_RESTART_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN LETTER_RESTART_FILE
                           BY REFERENCE RMS_STV IN LETTER_RESTART_FILE.
      MOVE RMS_STS IN LETTER_RESTART_FILE TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

AUDIT_RESTART_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_AUDIT_RESTART_RPT.
HANDLE_AUDIT_RESTART_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_AUDIT_RESTART_RPT
                           BY REFERENCE RMS_STV IN RES_AUDIT_RESTART_RPT.
      MOVE RMS_STS IN RES_AUDIT_RESTART_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

IMPOUND_RESTART_ERR SECTION.                              
      USE AFTER STANDARD ERROR PROCEDURE ON RES_IMPOUND_RESTART_RPT.
HANDLE_IMPOUND_RESTART_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_IMPOUND_RESTART_RPT
                           BY REFERENCE RMS_STV IN RES_IMPOUND_RESTART_RPT.
      MOVE RMS_STS IN RES_IMPOUND_RESTART_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

REJECT_RESTART_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_REJECT_RESTART_RPT.
HANDLE_REJECT_RESTART_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_REJECT_RESTART_RPT
                           BY REFERENCE RMS_STV IN RES_REJECT_RESTART_RPT.
      MOVE RMS_STS IN RES_REJECT_RESTART_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.
                             
SUMMARY_RESTART_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON SUMMARY_RESTART_RPT.
HANDLE_SUMMARY_RESTART_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN SUMMARY_RESTART_RPT
                           BY REFERENCE RMS_STV IN SUMMARY_RESTART_RPT.
      MOVE RMS_STS IN SUMMARY_RESTART_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

RES_NUM_WORK_FIL_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON RES_NUM_WORK_FIL.
RES_NUM_WORK_FIL_ERRS.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN RES_NUM_WORK_FIL
                           BY REFERENCE RMS_STV IN RES_NUM_WORK_FIL.
      MOVE RMS_STS IN RES_NUM_WORK_FIL TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.

LETTER_REPORT_ERR SECTION.
      USE AFTER STANDARD ERROR PROCEDURE ON LETTER_TOTAL_RPT.
HANDLE_LETTER_RPT_ERRS.
      MOVE "ERROR WITH LETTER_TOTAL_RPT FILE" TO ERR_FUNCTION_DETAIL.
      CALL "COB_ERR" USING BY REFERENCE RMS_STS IN LETTER_TOTAL_RPT
                           BY REFERENCE RMS_STV IN LETTER_TOTAL_RPT.
      MOVE RMS_STS IN LETTER_TOTAL_RPT TO DCL_SYMBOL_VALUE.
      CALL "LIB$SET_SYMBOL" USING BY DESCRIPTOR "PROG_ERR"
                                  BY DESCRIPTOR DCL_SYMBOL_VALUE
                                  BY REFERENCE DCL_TABLE_IND
                            GIVING RETURN_STATUS.
      IF RETURN_STATUS NOT EQUAL 1
            DISPLAY "ERROR SETTING PROG_ERR"
            DISPLAY "RETURN_STATUS - ", RETURN_STATUS WITH CONVERSION.
      CALL "SYS$EXIT" USING BY VALUE ZERO.
      STOP RUN.


END DECLARATIVES.
/
*******************************************************************************
*******************************************************************************

***************************
MAIN_LINE SECTION.
***************************

***************************
MAIN_LINE_ROUTINE.
***************************

	PERFORM MAIN_STARTUP THRU MAIN_STARTUP_EXIT.

	PERFORM BUILD_RES_NUM_TABLE THRU  BUILD_RES_NUM_TABLE_EXIT.
        
	OPEN INPUT RES_NUM_WORK_FIL.
	PERFORM SHOW_TIME_AND_PARCELS
	   THRU SHOW_TIME_AND_PARCELS_EXIT.
	SET NOT_REPROCESSING_DEADLOCK TO TRUE.
        PERFORM CREATE_REFUND_SLIP THRU CREATE_REFUND_SLIP_EXIT.
*       Judgment Interest Project.  We added the RES_PHASE table to
*       store ResPhase specific attributes.
	PERFORM GET_RES_PHASE_REC THRU GET_RES_PHASE_REC_EXIT.
	PERFORM PROCESS_THE_PHASE THRU PROCESS_THE_PHASE_EXIT.
	PERFORM SHOW_TIME_AND_PARCELS
	   THRU SHOW_TIME_AND_PARCELS_EXIT.
	DISPLAY "Parcel count may differ , but data still be correct".
	DISPLAY "  if any resource deadlock messages appear above".
	DISPLAY " parcel count, time given to estimate job completion time".

	PERFORM STORE_RES_BAL_REC THRU STORE_RES_BAL_REC_EXIT.
	PERFORM STORE_MTG_CO_REFUNDS THRU STORE_MTG_CO_REFUNDS_EXIT.

	SET RW_TRANS TO TRUE.
	PERFORM START_TRANS THRU START_TRANS_EXIT.
	PERFORM WRITE_TOTALS THRU WRITE_TOTALS_EXIT.
	PERFORM DISPLAY_LETTER_COUNTS THRU DISPLAY_LETTER_COUNTS_EXIT.

	close RES_AUDIT_RPT.
	close RES_IMPOUND_RPT.
	close LETTER_INPUT_FILE.
	close RES_MTG_REF_RPT.
	IF REJECT_RPT_OPEN
		WRITE REJ_RPT_REC FROM BLANK_LINE
		MOVE "       End of Report" to REJ_RPT_REC
		WRITE REJ_RPT_REC
		close RES_REJECT_RPT
	END-IF.
	close SUMMARY_RPT.
	CLOSE SUMMARY_IN_FIL.

	perform COMMIT_TRAN thru COMMIT_TRAN_EXIT.

	SORT SUMMARY_SORT_FIL ON ASCENDING KEY PARCEL_NUM IN SUMMARY_SORT_REC
		USING SUMMARY_IN_FIL
		GIVING SUMMARY_OUT_FIL.

	PERFORM WRITE_SUMMARY_BY_PARCEL THRU
		WRITE_SUMMARY_BY_PARCEL_EXIT.

	IF TRANS_ACTIVE
&RDB&		ROLLBACK
	END-IF.

	PERFORM CLEANUP_RESTART THRU
		CLEANUP_RESTART_EXIT.

        CALL "SYS$EXIT" USING BY VALUE 1.

	STOP RUN.

*******************************************************************************
*******************************************************************************

/
**********************
* APPORTION_INTEREST *
**********************

APPORTION_INTEREST.

* This paragraph was modified in December, 2011 (Tar #26158) to use
* the RECALC_RESINT_PCTS_LKG instead of ARCHIVE_LKG.
* The RECALC_RESINT_PCTS routine recalculates a parel's percentage
* if there are any CFD districts.  The Treasurer's CFDs (28940, 28941...)
* do NOT pay Resolution Interest.
* The AreaCode still comes from the ArchiveLkg.

	MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC.

	IF WS_SKIP_THIS_PARCEL = "YES" THEN GO TO APPORTION_INTEREST_EXIT.

	IF WS_RES_INT_TMP = ZERO
		GO TO APPORTION_INTEREST_EXIT.

	MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC.

* Determine if the resolution interest should be processed through the
* secured interest buckets or the unsecured interest buckets.

	IF PARCEL_BOOK_MAP_ITEM IN RECALC_RESINT_PCTS_LKG < 90000000 THEN
		MOVE "I" TO WS_RES_INT_BUCKET_FLG
	ELSE
		MOVE PARCEL_BOOK_MAP_ITEM IN RECALC_RESINT_PCTS_LKG TO
			PARCEL_BOOK_MAP_ITEM IN GET_UPPS_LEVY_TYPE_LKG
		MOVE PARCEL_SPLIT IN RECALC_RESINT_PCTS_LKG TO
			PARCEL_SPLIT IN GET_UPPS_LEVY_TYPE_LKG
		MOVE TAX_YEAR IN RECALC_RESINT_PCTS_LKG TO
			TAX_YEAR IN GET_UPPS_LEVY_TYPE_LKG
		CALL "GET_UPPS_LEVY_TYPE" USING GET_UPPS_LEVY_TYPE_LKG
			GIVING RETURN_STATUS
		IF RETURN_STATUS < 1 THEN
			IF RDB_DEADLOCK THEN
				GO TO APPORTION_INTEREST_EXIT
			END-IF
			GO TO HANDLE_ERRORS
		END-IF
		IF LEVY_TYPE IN GET_UPPS_LEVY_TYPE_LKG = "U" THEN
			MOVE "J" TO WS_RES_INT_BUCKET_FLG
		ELSE
			MOVE "I" TO WS_RES_INT_BUCKET_FLG
		END-IF
	END-IF.

	IF AC_PRIMARY_PCT in RECALC_RESINT_PCTS_LKG > 0
	   multiply WS_RES_INT_TMP by 
	   AC_PRIMARY_PCT OF RECALC_RESINT_PCTS_LKG
	   GIVING WS_AREA_CODE_PRIMARY_INT rounded
	ELSE
	   MOVE zero TO WS_AREA_CODE_PRIMARY_INT
	END-IF.

	IF AC_SECONDARY_PCT OF RECALC_RESINT_PCTS_LKG > 0
	   multiply WS_RES_INT_TMP by 
	   AC_SECONDARY_PCT OF RECALC_RESINT_PCTS_LKG
	   GIVING WS_AREA_CODE_SECONDARY_INT rounded
	ELSE
	   MOVE zero TO WS_AREA_CODE_SECONDARY_INT
	END-IF.

	IF TOT_SPEC_DIST_PCT OF RECALC_RESINT_PCTS_LKG > 0
	   multiply WS_RES_INT_TMP by
	   TOT_SPEC_DIST_PCT OF RECALC_RESINT_PCTS_LKG
	   GIVING WS_TOT_SPEC_INT
	ELSE
	   MOVE zero TO WS_TOT_SPEC_INT
	END-IF.

	subtract WS_AREA_CODE_PRIMARY_INT,
	         WS_AREA_CODE_SECONDARY_INT,
                 WS_TOT_SPEC_INT from WS_RES_INT_TMP
	         GIVING WS_FLOOD_INT.

*  If this is unsecured resolution interest, then there is no flood district.
*  Put any rounding leftovers in the secondary area code bucket.

	IF PARCEL_BOOK_MAP_ITEM IN RECALC_RESINT_PCTS_LKG NOT < 90000000 THEN
		ADD WS_FLOOD_INT TO WS_AREA_CODE_SECONDARY_INT
		MOVE ZERO TO WS_FLOOD_INT
	END-IF.

	MOVE AREA_CODE IN ARCHIVE_LKG TO WS_INT_AREA_CODE.
	MOVE SPACES TO AREA_CODE_BASE_DEF OF TAX_AREA_CODE_DEFINITION.

TRY_AC_INT.

	IF WS_AREA_CODE_PRIMARY_INT not = ZERO OR
	   WS_AREA_CODE_SECONDARY_INT not = zero

*******************************************
*	MODIFY THE AREA_CODE BUCKET FIRST *
*******************************************

	MOVE "NO" TO WS_INT_BUCKET_FOUND

&RDB&   for X in PROPERTY.SECURED_PROP_APP_INPUT with
&RDB&      X.AREA_CODE_DIST_FLG = "A" and
&RDB&      X.AREA_CODE_DIST     = WS_INT_AREA_CODE and
&RDB&      X.TAX_YEAR           = TAX_YEAR  in RECALC_RESINT_PCTS_LKG and
&RDB&      X.SECURED_FLG        = WS_RES_INT_BUCKET_FLG and
&RDB&      X.COLLECTION_FLG     = "C"
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with FOR stmt on SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error

&RDB&      get
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with GET stmt on SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&         WS_RES_INT_PRI = X.TOT_PRIMARY_AMT;
&RDB&         WS_RES_INT_SEC = X.TOT_SECONDARY_AMT
&RDB&      END_get

	   subtract WS_AREA_CODE_PRIMARY_INT from WS_RES_INT_PRI
	   subtract WS_AREA_CODE_SECONDARY_INT from WS_RES_INT_SEC
	   MOVE "YES" TO WS_INT_BUCKET_FOUND

&RDB&      modIFy X USING
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with MODIFY stmt on SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&         X.TOT_PRIMARY_AMT = WS_RES_INT_PRI;
&RDB&         X.TOT_SECONDARY_AMT = WS_RES_INT_SEC;
&RDB&      END_modIFy
&RDB&   END_for

	IF WS_INT_BUCKET_FOUND = "NO"
		IF AREA_CODE_BASE_DEF OF TAX_AREA_CODE_DEFINITION = SPACES
		        MOVE AREA_CODE in ARCHIVE_LKG 
				TO AREA_CODE_BASE_DEF OF TAX_AREA_CODE_DEFINITION
			MOVE all "0" TO DISTRICT_INDICATOR OF TAX_AREA_CODE_DEFINITION
			MOVE AREA_CODE_BASE_DEF OF TAX_AREA_CODE_DEFINITION
					TO WS_INT_AREA_CODE
			GO TO TRY_AC_INT
		ELSE
			DISPLAY " "
			EVALUATE WS_RES_INT_BUCKET_FLG
                           WHEN "I"
				DISPLAY "SECURED BUCKET (I) NOT FOUND FOR AREA CODE INTEREST - ",
				 AREA_CODE IN ARCHIVE_LKG
                           WHEN "J"
				DISPLAY "UNSECURED BUCKET (J) NOT FOUND FOR AREA CODE INTEREST - ",
				 AREA_CODE IN ARCHIVE_LKG
                           WHEN OTHER
				DISPLAY "BUCKET NOT FOUND FOR AREA CODE INTEREST - ",
				 AREA_CODE IN ARCHIVE_LKG
                        END-EVALUATE
			MOVE WS_AREA_CODE_PRIMARY_INT TO WS_DISP_INT
			DISPLAY "PRIMARY AMOUNT - ", WS_DISP_INT
			MOVE WS_AREA_CODE_SECONDARY_INT TO WS_DISP_INT
			DISPLAY "SECONDARY AMOUNT - ", WS_DISP_INT
		END-IF
	END-IF
	END-IF.


	IF WS_FLOOD_INT NOT = ZERO

**************************************
* 	NOW, MODIFY THE FLOOD BUCKET *
**************************************

	MOVE "NO" TO WS_INT_BUCKET_FOUND

&RDB&   for X in PROPERTY.SECURED_PROP_APP_INPUT with
&RDB&      X.AREA_CODE_DIST_FLG = "S" and
&RDB&      X.AREA_CODE_DIST     = FLD_SPEC_DIST in TAX_SPEC_DIST_DEFINITION and
&RDB&      X.TAX_YEAR           = TAX_YEAR  in RECALC_RESINT_PCTS_LKG and
&RDB&      X.SECURED_FLG        = WS_RES_INT_BUCKET_FLG and
&RDB&      X.COLLECTION_FLG     = "C"
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with FOR stmt on FLOOD SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error

&RDB&      get
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with GET stmt on FLOOD SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&         WS_RES_INT_SEC = X.TOT_SECONDARY_AMT
&RDB&      END_get

	   subtract WS_FLOOD_INT from WS_RES_INT_SEC
	   MOVE "YES" TO WS_INT_BUCKET_FOUND

&RDB&      modIFy X USING
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with MODIFY stmt on FLOOD SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_INTEREST" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&         X.TOT_SECONDARY_AMT = WS_RES_INT_SEC
&RDB&      END_modIFy
&RDB&   END_for
	IF WS_INT_BUCKET_FOUND = "NO"
                SUBTRACT WS_FLOOD_INT from WS_RES_INT_SEC
                EVALUATE WS_RES_INT_BUCKET_FLG
                   WHEN "I"
			DISPLAY "COULDN'T FIND SECURED FLOOD BUCKET (I) FOR INTEREST - ",
			 FLD_SPEC_DIST in TAX_SPEC_DIST_DEFINITION
                   WHEN "J"
			DISPLAY "COULDN'T FIND UNSECURED FLOOD BUCKET (J) FOR INTEREST - ",
			 FLD_SPEC_DIST in TAX_SPEC_DIST_DEFINITION
                   WHEN OTHER
			DISPLAY "COULDN'T FIND FLOOD BUCKET FOR INTEREST - ",
			 FLD_SPEC_DIST in TAX_SPEC_DIST_DEFINITION
                END-EVALUATE
		MOVE WS_FLOOD_INT TO WS_DISP_INT
		DISPLAY "AMOUNT - ", WS_DISP_INT
	END-IF
	END-IF.

	IF WS_TOT_SPEC_INT = ZERO
		GO TO APPORTION_INTEREST_EXIT.
	MOVE WS_TOT_SPEC_INT TO WS_TOTAL_SPEC_INT.

	MOVE 1 TO WS_INDX.

APPORTION_SPEC_DIST_LOOP.

	IF DIST IN RECALC_RESINT_PCTS_LKG(WS_INDX) = SPACES
		GO TO CHECK_DIST_BALANCE.

	MULTIPLY WS_TOT_SPEC_INT BY SPEC_DIST_PCT IN RECALC_RESINT_PCTS_LKG(WS_INDX)
	         GIVING WS_DIST_INT ROUNDED.
	SUBTRACT WS_DIST_INT FROM WS_TOTAL_SPEC_INT.

	MOVE DIST IN RECALC_RESINT_PCTS_LKG(WS_INDX) TO SPEC_DIST_BASE_DEF.

	MOVE "NO" TO WS_INT_BUCKET_FOUND.

&RDB&   for X in PROPERTY.SECURED_PROP_APP_INPUT with
&RDB&      X.AREA_CODE_DIST_FLG = "S" and
&RDB&      X.AREA_CODE_DIST     = DIST IN RECALC_RESINT_PCTS_LKG(WS_INDX) and
&RDB&      X.TAX_YEAR           = TAX_YEAR  in RECALC_RESINT_PCTS_LKG and
&RDB&      X.SECURED_FLG        = WS_RES_INT_BUCKET_FLG and
&RDB&      X.COLLECTION_FLG     = "C"
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with FOR stmt on SPEC SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_SPEC_DIST_LOOP" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error

&RDB&      get
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with GET stmt on SPEC SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_SPEC_DIST_LOOP" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&         WS_RES_INT_SEC = X.TOT_SECONDARY_AMT;
&RDB&         WS_RES_INT_PRI = X.TOT_PRIMARY_AMT
&RDB&      END_get

          IF SPEC_DIST_PRIMARY
	      SUBTRACT WS_DIST_INT FROM WS_RES_INT_PRI
	   ELSE
	      SUBTRACT WS_DIST_INT FROM WS_RES_INT_SEC
	   END-IF
	   MOVE "YES" TO WS_INT_BUCKET_FOUND

&RDB&      modIFy X USING
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
                 MOVE "Error with MODIFY stmt on SPEC SECURED_PROP_APP_INPUT" TO
                       ERR_FUNCTION_DETAIL
                 MOVE "APPORTION_SPEC_DIST_LOOP" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&         X.TOT_SECONDARY_AMT = WS_RES_INT_SEC;
&RDB&	      X.TOT_PRIMARY_AMT = WS_RES_INT_PRI
&RDB&      END_modIFy
&RDB&   END_for

	IF WS_INT_BUCKET_FOUND = "NO"
		EVALUATE WS_RES_INT_BUCKET_FLG
                   WHEN "I"
			DISPLAY "SPECIAL DISTRICT SECURED INTEREST BUCKET (I) NOT FOUND - ",
			 DIST IN RECALC_RESINT_PCTS_LKG(WS_INDX)
                   WHEN "J"
			DISPLAY "SPECIAL DISTRICT UNSECURED INTEREST BUCKET (J) NOT FOUND - ",
			 DIST IN RECALC_RESINT_PCTS_LKG(WS_INDX)
                   WHEN OTHER
			DISPLAY "SPECIAL DISTRICT INTEREST BUCKET NOT FOUND - ",
			 DIST IN RECALC_RESINT_PCTS_LKG(WS_INDX)
                END-EVALUATE
		MOVE WS_DIST_INT TO WS_DISP_INT
		DISPLAY "AMOUNT - ", WS_DISP_INT
	END-IF.

	ADD 1 TO WS_INDX.
	GO TO APPORTION_SPEC_DIST_LOOP.

CHECK_DIST_BALANCE.

* GIVE ANY ROUNDING BALANCE TO THE FIRST DISTRICT IN THE LIST.

	IF WS_TOTAL_SPEC_INT NOT = ZERO
		MOVE WS_TOTAL_SPEC_INT TO WS_DIST_INT

&RDB&		for x in PROPERTY.secured_prop_app_input with
&RDB&		    X.AREA_CODE_DIST_FLG = "S" AND
&RDB&		    X.AREA_CODE_DIST = DIST IN
&RDB&                 RECALC_RESINT_PCTS_LKG(1) AND
&RDB&		    X.TAX_YEAR = TAX_YEAR IN RECALC_RESINT_PCTS_LKG AND
&RDB&		    X.SECURED_FLG = WS_RES_INT_BUCKET_FLG AND
&RDB&	            X.COLLECTION_FLG = "C"
&RDB&		ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
		    MOVE "ERROR WITH FOR STMT ON SPEC SECURED_PROP_APP_INPUT" TO
                         ERR_FUNCTION_DETAIL
		    MOVE "CHECK_DIST_BALANCE" TO ERR_FUNCTION_LOC
		    GO TO RDB_ERROR
&RDB&		END_ERROR
&RDB&		GET
&RDB&		ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO APPORTION_INTEREST_EXIT
		END-IF
		   MOVE "ERROR WITH GET STMT ON SPEC SECURED_PROP_APP_INPUT" TO
		         ERR_FUNCTION_DETAIL
		   MOVE "CHECK_DIST_BALANCE" TO ERR_FUNCTION_LOC
		   GO TO RDB_ERROR
&RDB&		END_ERROR
&RDB&		WS_RES_INT_SEC = X.TOT_SECONDARY_AMT;
&RDB&		WS_RES_INT_PRI = X.TOT_PRIMARY_AMT;
&RDB& 		END_GET

                MOVE DIST IN RECALC_RESINT_PCTS_LKG(1) TO 
                     SPEC_DIST_BASE_DEF

          IF SPEC_DIST_PRIMARY
			SUBTRACT WS_DIST_INT FROM WS_RES_INT_PRI
		ELSE
			SUBTRACT WS_DIST_INT FROM WS_RES_INT_SEC
		END-IF
&RDB&		MODIFY X USING
&RDB&		ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
			IF RDB_DEADLOCK THEN
				GO TO APPORTION_INTEREST_EXIT
			END-IF
			MOVE "ERROR MODIFYING SPEC SECURED_PROP_APP_INPUT" TO
			     ERR_FUNCTION_DETAIL
			MOVE "CHECK_DIST_BALANCE" TO ERR_FUNCTION_LOC
			GO TO RDB_ERROR
&RDB&		END_ERROR
&RDB&		X.TOT_SECONDARY_AMT = WS_RES_INT_SEC;
&RDB&		X.TOT_PRIMARY_AMT = WS_RES_INT_PRI
&RDB&		END_MODIFY
&RDB&		END_FOR
	END-IF.


APPORTION_INTEREST_EXIT.
	EXIT.

/
***********************
* BUILD_RES_NUM_TABLE *
***********************

BUILD_RES_NUM_TABLE.
	MOVE "BUILD_RES_NUM_TABLE" TO ERR_FUNCTION_LOC.

	SET RO_TRANS TO TRUE.
	PERFORM START_TRANS THRU START_TRANS_EXIT.

	INITIALIZE WS_CURR_RES_NUM.
	OPEN OUTPUT RES_NUM_WORK_FIL.
	INITIALIZE RES_NUM_WORK_REC.
	SET RES_NUM_WORK_NO_DATA TO TRUE.

&RDB&	FOR R IN PROPERTY.RES_PHASE_LIST WITH
&RDB&		R.RES_PHASE_NUM = WS_RES_PHASE_NUM AND
&RDB&		R.TAX_YEAR = WS_TAX_YEAR AND
&RDB&		R.RES_NUM > WS_LAST_RES_NUM AND
&RDB&		R.VALID_FLG = "Y"
&RDB&		SORTED BY R.RES_NUM
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		MOVE "ERROR IN FOR." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR

&RDB&	GET
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		MOVE "ERROR IN GET." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR
&RDB&	  RES_PHASE_LIST_REC = R.*
&RDB&	END_GET

	IF RES_NUM IN RES_PHASE_LIST_REC NOT = WS_CURR_RES_NUM
		IF RES_NUM_WORK_HAS_DATA
			WRITE RES_NUM_WORK_REC
		END-IF
		INITIALIZE RES_NUM_WORK_REC
		SET RES_NUM_WORK_HAS_DATA TO TRUE
		MOVE RES_NUM IN RES_PHASE_LIST_REC TO
			RES_NUM IN RES_NUM_WORK_REC
			WS_CURR_RES_NUM
                EVALUATE TRUE
                   WHEN (RES_REASON IN RES_PHASE_LIST_REC >= "09" AND
                         RES_REASON IN RES_PHASE_LIST_REC <= "11")
                      SET SPLIT_COMBINE_TYPE IN RES_NUM_WORK_REC TO TRUE
                   WHEN RES_REASON IN RES_PHASE_LIST_REC = "24"
                      SET COMMON_TYPE IN RES_NUM_WORK_REC TO TRUE
                   WHEN OTHER
                      SET NO_GROUP_TYPE IN RES_NUM_WORK_REC TO TRUE
                END-EVALUATE
	END-IF

	ADD 1 TO ITEM_CNT IN RES_NUM_WORK_REC
	ADD 1 TO WS_PARCEL_COUNT_TOT

&RDB&	END_FOR
	
	PERFORM COMMIT_TRAN THRU COMMIT_TRAN_EXIT.
	IF RES_NUM_WORK_HAS_DATA
		WRITE RES_NUM_WORK_REC.
	CLOSE RES_NUM_WORK_FIL.
	DISPLAY "TOTAL PARCEL COUNT TO PROCESS IS " WS_PARCEL_COUNT_TOT.
	DISPLAY " ".

*  Code was implemented to process splits/combines differently from other types
*  of resolutions due to the re-application of payments.  These are identified
*  by the reason code of 09, 10, or 11, and the existence of multiple parcels
*  with the same resolution number.  However, the Assessor also puts multiple
*  parcels onto the same resolution number for double assessments on related
*  parcels.  This is to cancel the parcels only.  They use reason code 17 for
*  this type of action.  ccd  This use of multiple parcels on one resol nbr
*  for reason code 17 is causing us problems, as the program wants to treat
*  the group as a split.  We are again only allowing multiple parcels on one
*  resol nbr for a split/combine reason.  04/16/97  ccd  

BUILD_RES_NUM_TABLE_EXIT.
	EXIT.

/
******************
CHECK_FOR_RESTART.
******************

	IF WS_UNSECURED_PHASE = "YES" THEN
		MOVE "MCT$PROC:UPPS_RES_PHASE.COM" TO
		      PROCEDURE_ID IN PROG_RESTART_LKG
	ELSE
		MOVE "MCT$PROC:SECURED_RES_PHASE.COM" TO
			PROCEDURE_ID in PROG_RESTART_LKG
	END-IF.

	MOVE "PHASE_PROCESSING_BY_RES_NUM" TO PROGRAM_ID IN PROG_RESTART_LKG.

CFR_TRAN.

	SET RW_TRANS TO TRUE.
	PERFORM START_TRANS THRU START_TRANS_EXIT.

	MOVE "N" TO WS_RESTART_FOUND_FLG.

&RDB&	FOR P IN PROG_RESTART WITH
&RDB&		P.PROCEDURE_ID = PROCEDURE_ID IN PROG_RESTART_LKG AND
&RDB&		P.PROGRAM_ID = PROGRAM_ID IN PROG_RESTART_LKG AND
&RDB&		P.JOB_BUSY_FLG = "N"
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO CFR_TRAN
		END-IF
		MOVE "ERROR IN PROG_RESTART FOR" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	    END_ERROR

&RDB&	GET
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO CFR_TRAN
		END-IF
		MOVE "ERROR IN PROG_RESTART GET" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	    END_ERROR
&RDB&	  PROG_RESTART_REC IN PROG_RESTART_LKG = P.*;
&RDB&	  WS_PROG_RESTART_DBKEY = P.RDB$DB_KEY
&RDB&	END_GET

	MOVE RESTART_BUFFER IN PROG_RESTART_LKG TO WS_RESTART_BUFFER
	IF WS_PHASE_NUM IN WS_RESTART_BUFFER = WS_RES_PHASE_NUM AND
	   WS_RES_YEAR IN WS_RESTART_BUFFER = WS_TAX_YEAR THEN
		MOVE "Y" TO WS_RESTART_FOUND_FLG
		MOVE "Y" TO JOB_BUSY_FLG IN PROG_RESTART_LKG
		MOVE "Y" TO RESTART_FLG IN PROG_RESTART_LKG
&RDB&		MODIFY P USING
&RDB&		    ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
			IF RDB_DEADLOCK THEN
				PERFORM HANDLE_DEADLOCK THRU
					HANDLE_DEADLOCK_EXIT
				GO TO CFR_TRAN
			END-IF
			MOVE "ERROR IN PROG_RESTART MODIFY" TO ERR_FUNCTION_DETAIL
			GO TO RDB_ERROR
&RDB&		    END_ERROR
&RDB&		  P.RESTART_FLG = RESTART_FLG IN PROG_RESTART_LKG;
&RDB&		  P.JOB_BUSY_FLG = JOB_BUSY_FLG IN PROG_RESTART_LKG
&RDB&		END_MODIFY
	END-IF

&RDB&	END_FOR

	IF WS_RESTART_FOUND_FLG = "N" THEN
		PERFORM CREATE_NEW_RESTART_REC THRU
			CREATE_NEW_RESTART_REC_EXIT
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO CFR_TRAN
		END-IF
	ELSE
		DISPLAY " "
		DISPLAY "PROG_RESTART FOUND - RESUMING PREVIOUS RUN..."
		DISPLAY " "
	END-IF.

	MOVE WS_RESTART_BUFFER TO RESTART_BUFFER IN PROG_RESTART_LKG.

	MOVE WS_RES_YEAR TO TAX_YEAR IN GET_MINIMUM_FULL_TAX_LKG.
	CALL "GET_MINIMUM_FULL_TAX" USING GET_MINIMUM_FULL_TAX_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN GO TO HANDLE_ERRORS.

&RDB&	COMMIT

	IF WS_LAST_RES_NUM = ZERO
		DISPLAY " "
		DISPLAY "Doing an INITIAL RUN..."
		DISPLAY " "
		OPEN OUTPUT RES_AUDIT_RPT
		OPEN OUTPUT RES_IMPOUND_RPT
		OPEN OUTPUT SUMMARY_RPT
		OPEN OUTPUT SUMMARY_IN_FIL
		OPEN OUTPUT LETTER_INPUT_FILE
		ADD 1 TO MAX_SUM_LINE_CTR GIVING SUM_LINE_CTR
	ELSE
		DISPLAY " "
		DISPLAY "Doing a RESTART RUN..."
		DISPLAY " "
		PERFORM RESTART_THIS_JOB THROUGH RESTART_THIS_JOB_EXIT
	END-IF.

	DISPLAY " ".
	DISPLAY "RESOLUTION TAX YEAR = ", WS_RES_YEAR.
	MOVE MINIMUM_FULL_TAX IN GET_MINIMUM_FULL_TAX_LKG TO WS_AMT_X.
	DISPLAY "MINIMUM FULL TAX = ", WS_AMT_X.
	DISPLAY " ".

CHECK_FOR_RESTART_EXIT.
	EXIT.

/
*********************
* CHECK_PARCEL_CFDS *
*********************

CHECK_PARCEL_CFDS.

* This parcel in the phase is associated with one or more CFD districts.
* We want to see if there is a situation where this parcel is being
* cancelled (NEW_ASSESSED_TAX = 0.00) and that the same CFD is not
* associated with any new parcels being created by the same resolution.
*
* If we see this situation, then the WS_CFD_CANCEL_FLG will be set to "Y"
* and the resolution will be disapproved.


* This call retrieves all the CFD districts associated with the 
* specified parcel # and tax year.

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
		PARCEL_BOOK_MAP_ITEM IN GET_CFD_PARCEL_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN GET_CFD_PARCEL_LKG.
	MOVE TAX_YEAR IN RES_PHASE_LIST_REC TO
		TAX_YEAR IN GET_CFD_PARCEL_LKG.
	CALL "GET_CFD_PARCEL" USING GET_CFD_PARCEL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		IF RDB_DEADLOCK THEN
			GO TO CHECK_PARCEL_CFDS_EXIT
		END-IF
		GO TO HANDLE_ERRORS
	END-IF.

* Spin through the CFD districts associated with this parcel.  For each
* CFD district, see if it is also being associated with any new parcels being
* created in the same resolution number.

	MOVE 1 TO CFD_IX.
	MOVE "N" TO WS_CFD_CANCEL_FLG.

CHECK_PARCEL_CFD_LOOP.

	IF CFD_IX > CFD_DIST_COUNT IN GET_CFD_PARCEL_LKG THEN
		GO TO CHECK_PARCEL_CFDS_EXIT
	END-IF.

	IF REMOVED_FLG IN GET_CFD_PARCEL_LKG(CFD_IX) = "Y" THEN
		ADD 1 TO CFD_IX
		GO TO CHECK_PARCEL_CFD_LOOP
	END-IF.

&RDB&	GET
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO CHECK_PARCEL_CFDS_EXIT
		END-IF
		MOVE "ERROR IN CFD_NEW_CNT GET" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	    END_ERROR
&RDB&	  WS_CFD_NEW_CNT = COUNT OF R IN RES_PHASE_LIST CROSS
&RDB&				    C IN CFD_PARCEL WITH
&RDB&			R.TAX_YEAR = WS_RES_YEAR AND
&RDB&			R.RES_PHASE_NUM = WS_PHASE_NUM AND
&RDB&			R.VALID_FLG = "Y" AND
&RDB&			R.NEW_PARCEL_FLG = "Y" AND
&RDB&			R.RES_NUM = WS_CURR_RES_NUM AND
&RDB&			R.PARCEL_BOOK_MAP_ITEM = C.PARCEL_BOOK_MAP_ITEM AND
&RDB&			R.PARCEL_SPLIT = C.PARCEL_SPLIT AND
&RDB&			R.TAX_YEAR = C.TAX_YEAR AND
&RDB&			C.DIST = DIST IN GET_CFD_PARCEL_LKG(CFD_IX) AND
&RDB&			C.ASSESS_AMT > 0 AND
&RDB&			C.REMOVED_FLG = "N"
&RDB&	END_GET

* If the parcel we're checking here is being cancelled by the resolution,
* is associated with a CFD district, and there is no assessment for the
* same CFD district being assessed on new parcels in the same resolution,
* then we have a problem here.  Set the WS_CFD_CANCEL_FLG to "Y" to
* indicate the condition.

	IF ORIG_ASSESSED_TAX IN RES_PHASE_LIST_REC > 0 AND
	   NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC = 0 AND
	   WS_CFD_NEW_CNT = 0 THEN
		MOVE "Y" TO WS_CFD_CANCEL_FLG
		GO TO CHECK_PARCEL_CFDS_EXIT
	END-IF.

	ADD 1 TO CFD_IX.

	GO TO CHECK_PARCEL_CFD_LOOP.

CHECK_PARCEL_CFDS_EXIT.
	EXIT.

/
********************
CLEANUP_RESTART.
********************

&RDB&	START_TRANSACTION READ_WRITE
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO CLEANUP_RESTART
		END-IF
		MOVE "ERROR IN START_TRANSACTION" TO ERR_FUNCTION_DETAIL
		MOVE "CLEANUP_RESTART" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR

&RDB&	FOR P IN PROG_RESTART WITH
&RDB&		P.RDB$DB_KEY = WS_PROG_RESTART_DBKEY
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO CLEANUP_RESTART
		END-IF
		MOVE "ERROR IN PROG_RESTART FOR" TO ERR_FUNCTION_DETAIL
		MOVE "CLEANUP_RESTART" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR

&RDB&	ERASE P
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO CLEANUP_RESTART
		END-IF
		MOVE "ERROR IN PROG_RESTART ERASE" TO ERR_FUNCTION_DETAIL
		MOVE "CLEANUP_RESTART" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR

&RDB&	END_FOR

&RDB&	COMMIT.

CLEANUP_RESTART_EXIT.
	EXIT.

/
************************
CREATE_NEW_RESTART_REC.
************************

	DISPLAY " ".
	DISPLAY "PROG_RESTART NOT FOUND - ASSUMING AN INITIAL RUN".
	DISPLAY " ".
	MOVE "N" TO ON_LINE_FLG IN PROG_RESTART_LKG.
	MOVE "00" TO PROG_FUNCTION_CODE IN PROG_RESTART_LKG.
	INITIALIZE WS_RESTART_BUFFER.
	MOVE WS_TAX_YEAR TO WS_RES_YEAR IN WS_RESTART_BUFFER.
	MOVE WS_RES_PHASE_NUM TO WS_PHASE_NUM IN WS_RESTART_BUFFER.
	MOVE WS_RUN_MODE_FLG TO WS_RUN_MODE IN WS_RESTART_BUFFER.
	MOVE WS_RESTART_BUFFER TO RESTART_BUFFER IN PROG_RESTART_LKG.
	CALL "CREATE_PROG_RESTART_REC" USING PROG_RESTART_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		IF RDB_DEADLOCK THEN
			GO TO CREATE_NEW_RESTART_REC_EXIT
		ELSE
			GO TO HANDLE_ERRORS
		END-IF
	END-IF.

&RDB&	START_STREAM P_STREAM USING P IN PROG_RESTART WITH
&RDB&		P.PROCEDURE_ID = PROCEDURE_ID IN PROG_RESTART_LKG AND
&RDB&		P.PROGRAM_ID = PROGRAM_ID IN PROG_RESTART_LKG AND
&RDB&		P.JOB_BUSY_FLG = "N"
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO CREATE_NEW_RESTART_REC_EXIT
		END-IF
		MOVE "ERROR IN PROG_RESTART START_STREAM" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	    END_ERROR

	MOVE "N" TO WS_RESTART_FOUND_FLG.

RESTART_LOOP.

&RDB&	FETCH P_STREAM
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO CREATE_NEW_RESTART_REC_EXIT
		END-IF
		MOVE "ERROR IN PROG_RESTART FETCH" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	    END_ERROR
&RDB&	    AT END
		GO TO RESTART_EOF
&RDB&	END_FETCH

&RDB&	GET
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO CREATE_NEW_RESTART_REC_EXIT
		END-IF
		MOVE "ERROR IN PROG_RESTART GET" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	    END_ERROR
&RDB&	  PROG_RESTART_REC IN PROG_RESTART_LKG = P.*;
&RDB&	  WS_PROG_RESTART_DBKEY = P.RDB$DB_KEY
&RDB&	END_GET

	MOVE RESTART_BUFFER IN PROG_RESTART_LKG TO WS_RESTART_BUFFER.
	IF WS_PHASE_NUM IN WS_RESTART_BUFFER = WS_RES_PHASE_NUM AND
	   WS_RES_YEAR IN WS_RESTART_BUFFER = WS_TAX_YEAR THEN
		MOVE "Y" TO WS_RESTART_FOUND_FLG
		GO TO RESTART_EOF
	END-IF

	GO TO RESTART_LOOP.

RESTART_EOF.

&RDB&	END_STREAM P_STREAM

	IF WS_RESTART_FOUND_FLG = "N" THEN
		DISPLAY " "
		DISPLAY "RE-READ OF PROG_RESTART RECORD AFTER CREATE FAILED."
		DISPLAY "ABORTING - CANNOT CONTINUE..."
		DISPLAY " "
		CALL "SYS$EXIT" USING BY VALUE ZERO
		STOP RUN
	END-IF.

CREATE_NEW_RESTART_REC_EXIT.
	EXIT.

/
***************
* COMMIT_TRAN *
***************

COMMIT_TRAN.
	MOVE "COMMIT_TRAN" TO ERR_FUNCTION_LOC.

	IF UPDATE_MODE_RUN
*                call "lib$date_time" using by descriptor ws_timestamp
*                display "committing at: ", ws_timestamp
&RDB&		COMMIT
*                call "lib$date_time" using by descriptor ws_timestamp
*                display "committed @: " ws_timestamp
	ELSE
&RDB&   	ROLLBACK
	END-IF.
	SET TRANS_NOT_ACTIVE TO TRUE.

COMMIT_TRAN_EXIT.
	EXIT.

/

* ****************** *
* CREATE_NEXTIS_DATE *
* ****************** *

CREATE_NEXTIS_DATE.

    EVALUATE DISP_MONTH IN GET_CURRENT_DATE_TIME_LKG
        WHEN "JAN"
            MOVE "01" TO WS_MONTH
        WHEN "FEB"
            MOVE "02" TO WS_MONTH
        WHEN "MAR"
            MOVE "03" TO WS_MONTH
        WHEN "APR"
            MOVE "04" TO WS_MONTH
        WHEN "MAY"
            MOVE "05" TO WS_MONTH
        WHEN "JUN"
            MOVE "06" TO WS_MONTH
        WHEN "JUL"
            MOVE "07" TO WS_MONTH
        WHEN "AUG"
            MOVE "08" TO WS_MONTH
        WHEN "SEP"
            MOVE "09" TO WS_MONTH
        WHEN "OCT"
            MOVE "10" TO WS_MONTH
        WHEN "NOV"
            MOVE "11" TO WS_MONTH
        WHEN OTHER
            MOVE "12" TO WS_MONTH
    END-EVALUATE.

    STRING DISP_YEAR DELIMITED BY SIZE,
           "-" DELIMITED BY SIZE,
           WS_MONTH DELIMITED BY SIZE,
           "-" DELIMITED BY SIZE,
           DISP_DAY DELIMITED BY SIZE INTO WS_NEXTIS_DATE.

CREATE_NEXTIS_DATE_EXIT.
/

* ****************** *
* CREATE_REFUND_SLIP *
* ****************** *

CREATE_REFUND_SLIP.

* This paragraph will create a nexTIS Refund Slip to hold all of the
* refunds for the phase.

    IF WS_NEXTIS_SLIP_ID > 0 THEN
*       RESTARTING
        MOVE WS_NEXTIS_SLIP_ID TO WS_REFUND_SLIP_ID
        GO TO CREATE_REFUND_SLIP_EXIT
    END-IF.

REF_SLIP_TRAN.

    SET RW_TRANS TO TRUE.
    PERFORM START_TRANS THRU START_TRANS_EXIT.

    INITIALIZE REFUND_SLIP_DB_LKG.
    SET DB_ADD_REQUEST IN REFUND_SLIP_DB_LKG TO TRUE.
    MOVE "Y" TO IS_NEW_FLG IN REFUND_SLIP_DB_LKG.
    MOVE ZERO TO SLIP_ID IN REFUND_SLIP_DB_LKG.
    MOVE WS_RESO_REFUND_TYPE_ID TO REFUND_TYPE_ID IN REFUND_SLIP_DB_LKG.
    MOVE WS_WORKING_SLIP_TYPE_ID TO SLIP_TYPE_ID IN REFUND_SLIP_DB_LKG.
    MOVE WS_RESO_PHASE_USER_ID TO OWNER_ID IN REFUND_SLIP_DB_LKG.
    MOVE WS_NEXTIS_DATE TO CREATE_DATE IN REFUND_SLIP_DB_LKG.
    MOVE WS_SLIP_READY_STATUS_ID TO STATUS_ID IN REFUND_SLIP_DB_LKG.
    MOVE WS_NEXTIS_DATE TO STATUS_DATE IN REFUND_SLIP_DB_LKG.
    MOVE ZERO TO APPROVER_ID IN REFUND_SLIP_DB_LKG.
    MOVE SPACES TO APPROVAL_DATE IN REFUND_SLIP_DB_LKG.
    MOVE SPACES TO TRANSLATE_DATE IN REFUND_SLIP_DB_LKG.
    STRING "RESO PHASE - " DELIMITED BY SIZE
            WS_TAX_YEAR DELIMITED BY SIZE,
            "." DELIMITED BY SIZE,
            WS_RES_PHASE_NUM DELIMITED BY SPACE INTO
            SLIP_DESC OF REFUND_SLIP_DB_LKG.
    CALL "REFUND_SLIP_DB" USING REFUND_SLIP_DB_LKG
                          GIVING RETURN_STATUS.
    IF RETURN_STATUS < 1 THEN
	IF RDB_DEADLOCK THEN
		PERFORM HANDLE_DEADLOCK THRU
			HANDLE_DEADLOCK_EXIT
		GO TO REF_SLIP_TRAN
	END-IF
        GO TO HANDLE_ERRORS
    END-IF.
    MOVE SLIP_ID IN REFUND_SLIP_DB_LKG TO WS_REFUND_SLIP_ID.
    MOVE SLIP_ID IN REFUND_SLIP_DB_LKG TO WS_NEXTIS_SLIP_ID.

    PERFORM COMMIT_TRAN THRU COMMIT_TRAN_EXIT.


CREATE_REFUND_SLIP_EXIT.

/
************************
* DISAPPROVE_THIS_RESO *
************************

DISAPPROVE_THIS_RESO.

	MOVE WS_TAX_YEAR TO TAX_YEAR IN DISAPPROVE_RES_NUM_LKG.
	MOVE WS_RES_PHASE_NUM TO RES_PHASE_NUM IN DISAPPROVE_RES_NUM_LKG.
	MOVE WS_CURR_RES_NUM TO RES_NUM IN DISAPPROVE_RES_NUM_LKG.
	MOVE WS_EXCEPTION_TXT TO EXCEPTION_TXT IN DISAPPROVE_RES_NUM_LKG.

&RDB&	START_TRANSACTION READ_WRITE RESERVING
&RDB&		RES_PHASE_LIST, PARCEL_MASTER, LAND_IMPROVE_VALUE,
&RDB&		PERSONAL_PROPERTY, PERS_PROP_CLASS_VALUE,
&RDB&           SPEC_DIST_VALUE, RESOLUTIONS,
&RDB&		CP, CTX_BTX_PMT_ACT, SPEC_DIST_PMT_ACT,
&RDB&		CP_BUYER_PMT_ACT, RESTORE_ACT, RESTORE_CP_ACT,
&RDB&		REDEMPTION_PMT_ACT, PARCEL_NA FOR PROTECTED WRITE
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO DISAPPROVE_THIS_RESO
		END-IF
		MOVE "ERROR IN START_TRANSACTION." TO ERR_FUNCTION_DETAIL
		MOVE "DISAPPROVE_THIS_RESO" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	   END_ERROR

	CALL "DISAPPROVE_RES_NUM" USING DISAPPROVE_RES_NUM_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		EVALUATE RETURN_STATUS
		    WHEN RDB_DEADLOCK_ERR_CODE
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO DISAPPROVE_THIS_RESO
		    WHEN OTHER
			MOVE "DISAPPROVE_THIS_RESO" TO ERR_FUNCTION_LOC
			GO TO HANDLE_ERRORS
		END-EVALUATE
	END-IF.

&RDB&	COMMIT
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO DISAPPROVE_THIS_RESO
		END-IF
		MOVE "COMMIT ERROR" TO ERR_FUNCTION_DETAIL
		MOVE "DISAPPROVE_THIS_RESO" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR.

DISAPPROVE_THIS_RESO_EXIT.
	EXIT.

/
*******************
* DO_A_RESOLUTION *
*******************

DO_A_RESOLUTION.
	MOVE "DO_A_RESOLUTION" TO ERR_FUNCTION_LOC.

*
* Note: A "Z" in split/combine means newly created parcel
*
	MOVE "NO" TO WS_SKIP_THIS_PARCEL.

	IF RES_SPLIT_COMBINE_FLG OF GET_PARCEL_LKG NOT = "Z" AND
           NEW_PARCEL_FLG IN RES_PHASE_LIST_REC NOT = "Y" THEN
		SET WRITE_AUDIT IN RESTORE_PMTS_LKG TO TRUE
		SET READ_WRITE IN RESTORE_PMTS_LKG TO TRUE
		PERFORM RESTORE_PMTS THRU RESTORE_PMTS_EXIT
		IF RDB_DEADLOCK
			GO TO DO_A_RESOLUTION_EXIT
		END-IF
		IF WS_SKIP_THIS_PARCEL = "YES"
			SET REJECT_RES_NUM TO TRUE
			MOVE "PROBLEM RESTORING PAYMENTS" TO WS_EXCEPTION_TXT
			GO TO DO_A_RESOLUTION_EXIT
		END-IF
		MOVE AMT_RESTORED IN RESTORE_PMTS_LKG TO
			RESTORED_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
		MOVE TOT_PMT_TAX IN RESTORE_PMTS_LKG TO
			RESTORED_TAX_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
		MOVE TOT_PMT_INT IN RESTORE_PMTS_LKG TO
			RESTORED_INT_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
		MOVE TOT_PMT_FEE IN RESTORE_PMTS_LKG TO
			RESTORED_FEE_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)

*		Here we are going to call RECALC_RESINT_PCTS to use the
*		pre-resolution version of the parcels' taxes for resolution
*		interest.  This routine will recalculate the parcel's 
*		percentages if there are any Treasurer-Type CFDs.  Otherwise
*		we use them straight from the DB (PM and SDV).
*		We do there here, right now so we can get the pre-reso
*		version of the percents, districts, etc.

		INITIALIZE RECALC_RESINT_PCTS_LKG
		MOVE PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG TO
                     PARCEL_BOOK_MAP_ITEM IN RECALC_RESINT_PCTS_LKG
		MOVE PARCEL_SPLIT IN GET_PARCEL_LKG TO
		     PARCEL_SPLIT IN RECALC_RESINT_PCTS_LKG
		MOVE TAX_YEAR IN GET_PARCEL_LKG TO
		     TAX_YEAR IN RECALC_RESINT_PCTS_LKG
		MOVE PARCEL_SEQ_NUM IN GET_PARCEL_LKG TO
		     PARCEL_SEQ_NUM IN RECALC_RESINT_PCTS_LKG
		CALL "RECALC_RESINT_PCTS" USING RECALC_RESINT_PCTS_LKG
		                          GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO DO_A_RESOLUTION_EXIT
		END-IF
		IF RETURN_STATUS < 1 THEN
		    GO TO HANDLE_ERRORS
		END-IF

		PERFORM CANCEL_TAX THRU CANCEL_TAX_EXIT
		IF RDB_DEADLOCK
			GO TO DO_A_RESOLUTION_EXIT
		END-IF
		IF WS_SKIP_THIS_PARCEL = "YES"
			SET REJECT_RES_NUM TO TRUE
			MOVE "PROBLEM CANCELING TAX" TO WS_EXCEPTION_TXT
			GO TO DO_A_RESOLUTION_EXIT
		END-IF

		PERFORM UPDATE_PARCEL_MASTER THRU UPDATE_PARCEL_MASTER_EXIT
		IF RDB_DEADLOCK
			GO TO DO_A_RESOLUTION_EXIT
		END-IF

		PERFORM ARCHIVE THRU ARCHIVE_EXIT
		IF RDB_DEADLOCK
			GO TO DO_A_RESOLUTION_EXIT
		END-IF
		IF WS_SKIP_THIS_PARCEL = "YES"
			SET REJECT_RES_NUM TO TRUE
			MOVE "PROBLEM ARCHIVING DATA" TO WS_EXCEPTION_TXT
			GO TO DO_A_RESOLUTION_EXIT
		END-IF
	END-IF.

	PERFORM POST_NEW_TAX THRU POST_NEW_TAX_EXIT.
	IF RDB_DEADLOCK
		GO TO DO_A_RESOLUTION_EXIT
	END-IF.
	IF WS_SKIP_THIS_PARCEL = "YES"
		SET REJECT_RES_NUM TO TRUE
		MOVE "PROBLEM POSTING NEW TAX" TO WS_EXCEPTION_TXT
		GO TO DO_A_RESOLUTION_EXIT
	END-IF.

	PERFORM REAPPLY_PMTS THRU REAPPLY_PMTS_EXIT.
	IF RDB_DEADLOCK
		GO TO DO_A_RESOLUTION_EXIT
	END-IF.
	IF WS_SKIP_THIS_PARCEL = "YES"
		SET REJECT_RES_NUM TO TRUE
		MOVE "PROBLEM REAPPLYING PAYMENTS" TO WS_EXCEPTION_TXT
		GO TO DO_A_RESOLUTION_EXIT
	END-IF.

	PERFORM UPDATE_PARCEL_MASTER THRU UPDATE_PARCEL_MASTER_EXIT.
	IF RDB_DEADLOCK
		GO TO DO_A_RESOLUTION_EXIT
	END-IF.

DO_A_RESOLUTION_EXIT.
	EXIT.

/
***********************
* DO_SPLIT_RESOLUTION *
***********************

DO_SPLIT_RESOLUTION.
	MOVE "DO_SPLIT_RESOLUTION" TO ERR_FUNCTION_LOC.

*
* Note: A "Z" in split/combine means newly created parcel
*
	MOVE "NO" TO WS_SKIP_THIS_PARCEL.

	IF RES_SPLIT_COMBINE_FLG OF GET_PARCEL_LKG NOT = "Z" AND
           NEW_PARCEL_FLG IN RES_PHASE_LIST_REC NOT = "Y" THEN
		SET WRITE_AUDIT IN RESTORE_PMTS_LKG TO TRUE
  		SET READ_WRITE IN RESTORE_PMTS_LKG TO TRUE
		PERFORM RESTORE_PMTS THRU RESTORE_PMTS_EXIT
		IF RDB_DEADLOCK
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF
		IF WS_SKIP_THIS_PARCEL = "YES"
			SET REJECT_RES_NUM TO TRUE
			MOVE "PROBLEM RESTORING PAYMENTS" TO WS_EXCEPTION_TXT
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF

*    TAR 50139
*		Check to see if the restores from this parcel can fit in the
*		existing PMT_TABLE_LARGE array in WS_RES_NUM_PMT_TABLE.  The
*		array size is 2000.  This array structure will contain all
*		the restored payments for all parcels in the current
*		resolution number group being processed.  As we add the
*		payments for each parcel into this array, check to be
*		sure there is enough room without overwriting the bounds
*		of the array.  (Prior to this tar update, the check
*		for this condition was not made at all.)

		IF NUM_PMTS_RESTORED IN WS_RES_NUM_PMT_TABLE +
		   NUM_PMTS_RESTORED IN RESTORE_PMTS_LKG > 2000 THEN
			MOVE TOO_MANY_RECS_ERR_CODE TO RETURN_STATUS
			STRING
				"RES NUM " DELIMITED BY SIZE,
				WS_CURR_RES_NUM DELIMITED BY SIZE,
				" HAS OVER 2000 PAYMENTS TO RESTORE."
					DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "DO_SPLIT_RESOLUTION" TO ERR_FUNCTION_LOC
			GO TO HANDLE_ERRORS
		END-IF

		ADD NUM_PMTS_RESTORED IN RESTORE_PMTS_LKG TO
			NUM_PMTS_RESTORED IN WS_RES_NUM_PMT_TABLE
		ADD TOT_PMT_TAX IN RESTORE_PMTS_LKG TO
			TOT_PMT_TAX IN WS_RES_NUM_PMT_TABLE
		ADD TOT_PMT_INT IN RESTORE_PMTS_LKG TO
			TOT_PMT_INT IN WS_RES_NUM_PMT_TABLE
		ADD TOT_PMT_FEE IN RESTORE_PMTS_LKG TO
			TOT_PMT_FEE IN WS_RES_NUM_PMT_TABLE
		MOVE 1 TO PMT_IX
		PERFORM WITH TEST BEFORE UNTIL PMT_IX > NUM_PMTS_RESTORED IN
							RESTORE_PMTS_LKG
			ADD 1 TO WS_RES_NUM_PMT_IX
			MOVE PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG TO
				PARCEL_BMI IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PARCEL_SPLIT IN GET_PARCEL_LKG TO
				PARCEL_SPLIT IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_TYPE IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_TYPE IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE DIST IN RESTORE_PMTS_LKG(PMT_IX) TO
				DIST IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_DATE IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_DATE IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_AMT IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_AMT IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_TAX IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_TAX IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_TAX_1ST_HALF IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_TAX_1ST_HALF IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_TAX_2ND_HALF IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_TAX_2ND_HALF IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_INT IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_INT IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_INT_1ST_HALF IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_INT_1ST_HALF IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_INT_2ND_HALF IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_INT_2ND_HALF IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			MOVE PMT_FEE IN RESTORE_PMTS_LKG(PMT_IX) TO
				PMT_FEE IN WS_RES_NUM_PMT_TABLE(WS_RES_NUM_PMT_IX)
			ADD 1 TO PMT_IX
		END-PERFORM
	
		MOVE AMT_RESTORED IN RESTORE_PMTS_LKG TO
			RESTORED_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
		MOVE TOT_PMT_TAX IN RESTORE_PMTS_LKG TO
			RESTORED_TAX_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
		MOVE TOT_PMT_INT IN RESTORE_PMTS_LKG TO
			RESTORED_INT_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
		MOVE TOT_PMT_FEE IN RESTORE_PMTS_LKG TO
			RESTORED_FEE_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)

		PERFORM CANCEL_TAX THRU CANCEL_TAX_EXIT
		IF RDB_DEADLOCK
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF
		IF WS_SKIP_THIS_PARCEL = "YES"
			SET REJECT_RES_NUM TO TRUE
			MOVE "PROBLEM CANCELING TAX" TO WS_EXCEPTION_TXT
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF

		PERFORM UPDATE_PARCEL_MASTER THRU UPDATE_PARCEL_MASTER_EXIT
		IF RDB_DEADLOCK
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF

		PERFORM ARCHIVE THRU ARCHIVE_EXIT
		IF RDB_DEADLOCK
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF
		IF WS_SKIP_THIS_PARCEL = "YES"
			SET REJECT_RES_NUM TO TRUE
			MOVE "PROBLEM ARCHIVING DATA" TO WS_EXCEPTION_TXT
			GO TO DO_SPLIT_RESOLUTION_EXIT
		END-IF
	END-IF.

	PERFORM POST_NEW_TAX THRU POST_NEW_TAX_EXIT.
	IF RDB_DEADLOCK
		GO TO DO_SPLIT_RESOLUTION_EXIT
	END-IF.
	IF WS_SKIP_THIS_PARCEL = "YES"
		SET REJECT_RES_NUM TO TRUE
		MOVE "PROBLEM POSTING NEW TAX" TO WS_EXCEPTION_TXT
		GO TO DO_SPLIT_RESOLUTION_EXIT
	END-IF.

	PERFORM UPDATE_PARCEL_MASTER THRU UPDATE_PARCEL_MASTER_EXIT.
	IF RDB_DEADLOCK
		GO TO DO_SPLIT_RESOLUTION_EXIT
	END-IF.

DO_SPLIT_RESOLUTION_EXIT.
	EXIT.

/
**************
* GET_GLOBAL *
**************

GET_GLOBAL.
	MOVE "GET_GLOBAL" TO ERR_FUNCTION_LOC.

	MOVE ALL "Y" TO GBL_SELECT_FLAGS IN GET_SELECT_GBL_PARAMS_LKG.
	SET GBL_PARAMS_ALL_TRUE TO TRUE.

	CALL "GET_SELECT_GBL_PARAMS" USING GET_SELECT_GBL_PARAMS_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		GO TO HANDLE_ERRORS
	END-IF.
	 
	INITIALIZE GLOBAL_PARAM_LKG.
	MOVE "P" TO DATABASE_FLG IN GLOBAL_PARAM_LKG.
	MOVE "FULL_YEAR_INT_DATE" TO GP_NAME IN GLOBAL_PARAM_LKG.
	MOVE 0 TO GP_YEAR IN GLOBAL_PARAM_LKG.
	CALL "GET_GLOBAL_PARAM" USING GLOBAL_PARAM_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		MOVE "ERROR GETTING FULL_YEAR_INT_DATE GLOBAL" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.
	MOVE GPV_DATE IN GLOBAL_PARAM_LKG TO WS_FULL_YEAR_INT_DATE_ANSI.
	MOVE GPV_DATE IN GLOBAL_PARAM_LKG TO DATE_ANSI_X IN DATE_CONVERT_LKG.
	SET IN_DATE_ANSI_X IN DATE_CONVERT_LKG TO TRUE.
	CALL "DATE_CONVERT" USING DATE_CONVERT_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		MOVE "ERROR CONVERTING FULL_YEAR_INT_DATE" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.
	MOVE JUL_DATE IN DATE_CONVERT_LKG TO WS_FULL_YEAR_INT_DATE_JUL.
	DISPLAY " ".
	DISPLAY "FULL YEAR INTEREST DATE:  ", WS_FULL_YEAR_INT_DATE_ANSI.
	DISPLAY " ".

GET_GLOBAL_EXIT.
	EXIT.

/
*******************
* GET_PARCEL_DATA *
*******************

GET_PARCEL_DATA.
	MOVE "GET_PARCEL_DATA" TO ERR_FUNCTION_LOC.
	IF REPROCESSING_DEADLOCKED_DATA
	          CONTINUE
	     ELSE ADD 1 TO WS_PARCELS_SINCE_TIME
	          ADD 1 TO WS_PARCELS_PROCESSED.
	IF WS_PARCELS_SINCE_TIME = 500
		PERFORM SHOW_TIME_AND_PARCELS
		   THRU SHOW_TIME_AND_PARCELS_EXIT.

* If this is a CFD Parcel, and the New AssessedTax is going to Zero.
* We'll disapprove this reso right now.

    MOVE ZERO TO WS_CFD_COUNT.

&RDB& GET
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO GET_PARCEL_DATA_EXIT
         ELSE
             MOVE "GET_PARCEL_DATA" TO ERR_FUNCTION_LOC
             MOVE "ERR GETTING CFD_COUNT" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& WS_CFD_COUNT = COUNT OF C IN CFD_PARCEL WITH
&RDB&                      C.PARCEL_BOOK_MAP_ITEM = 
&RDB&                        PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC AND
&RDB&                      C.PARCEL_SPLIT = 
&RDB&                        PARCEL_SPLIT IN RES_PHASE_LIST_REC AND
&RDB&                      C.TAX_YEAR = TAX_YEAR IN RES_PHASE_LIST_REC AND
&RDB&                      C.REMOVED_FLG = "N"
&RDB& END_GET

	IF WS_CFD_COUNT > 0 THEN
		PERFORM CHECK_PARCEL_CFDS THRU CHECK_PARCEL_CFDS_EXIT
		IF RDB_DEADLOCK THEN
			GO TO GET_PARCEL_DATA_EXIT
		END-IF
		IF WS_CFD_CANCEL_FLG = "Y" THEN
			MOVE "CANNOT CANCEL CFD TAX" TO WS_EXCEPTION_TXT
			DISPLAY "*** WARNING - CANNOT CANCEL CFD TAX FOR PARCEL - ", 
				WS_CURR_PARCEL_NUM,
				" RES #", WS_CURR_RES_NUM
			SET REJECT_RES_NUM TO TRUE
			GO TO GET_PARCEL_DATA_EXIT
		END-IF
	END-IF.

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
		PARCEL_BOOK_MAP_ITEM IN TAX_EXT_KEY_DATA IN GET_TAX_EXT_DATA_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN TAX_EXT_KEY_DATA IN GET_TAX_EXT_DATA_LKG.
	MOVE WS_TAX_YEAR TO TAX_YEAR IN TAX_EXT_KEY_DATA IN GET_TAX_EXT_DATA_LKG.
	MOVE WS_RES_PHASE_NUM TO
		RES_PHASE_NUM IN TAX_EXT_KEY_DATA IN GET_TAX_EXT_DATA_LKG.
	CALL "GET_TAX_EXT_DATA" USING GET_TAX_EXT_DATA_LKG
		GIVING RETURN_STATUS.
	IF RDB_DEADLOCK
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.
	IF REC_NOT_FOUND
		DISPLAY "*** TAX_EXT_MONEY NOT FOUND IN DATABASE - ",
			WS_CURR_PARCEL_NUM
		SET REJECT_RES_NUM TO TRUE
		MOVE "TAX EXTENSION DATA NOT FOUND" TO WS_EXCEPTION_TXT
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.
	IF RETURN_STATUS < 1
		STRING
			"*** Error from GET_TAX_EXT_DATA - " DELIMITED BY SIZE
			WS_CURR_PARCEL_NUM DELIMITED BY SIZE
		    INTO ERR_FUNCTION_DETAIL
		DISPLAY ERR_FUNCTION_DETAIL
		GO TO HANDLE_ERRORS
	END-IF.

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
		PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN GET_PARCEL_LKG.
	MOVE WS_TAX_YEAR TO TAX_YEAR IN GET_PARCEL_LKG.
	MOVE "0" TO PARCEL_SEQ_NUM IN GET_PARCEL_LKG.
	CALL "GET_PARCEL" USING GET_PARCEL_LKG GIVING RETURN_STATUS.
	IF RDB_DEADLOCK
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.
	IF REC_NOT_FOUND
		IF UPDATE_MODE_RUN
			DISPLAY "*** PARCEL_MASTER NOT FOUND IN DATABASE - ",
				WS_CURR_PARCEL_NUM
			SET REJECT_RES_NUM TO TRUE
			MOVE "PARCEL_MASTER NOT FOUND" TO WS_EXCEPTION_TXT
			GO TO GET_PARCEL_DATA_EXIT
		ELSE
			MOVE "R" TO PARCEL_SEQ_NUM IN GET_PARCEL_LKG
			CALL "GET_PARCEL" USING GET_PARCEL_LKG
				GIVING RETURN_STATUS
			IF RDB_DEADLOCK
				GO TO GET_PARCEL_DATA_EXIT
			END-IF
			IF REC_NOT_FOUND
				DISPLAY "*** PARCEL_MASTER NOT FOUND IN DATABASE - ",
					WS_CURR_PARCEL_NUM
				SET REJECT_RES_NUM TO TRUE
				MOVE "PARCEL_MASTER NOT FOUND" TO
					WS_EXCEPTION_TXT
				GO TO GET_PARCEL_DATA_EXIT
			ELSE
				IF RETURN_STATUS < 1
					STRING
						"*** Error from GET_PARCEL - "
							DELIMITED BY SIZE
						WS_CURR_PARCEL_NUM
							DELIMITED BY SIZE
					    INTO ERR_FUNCTION_DETAIL
					DISPLAY ERR_FUNCTION_DETAIL
					GO TO HANDLE_ERRORS
				END-IF
			END-IF
		END-IF
	ELSE
		IF RETURN_STATUS < 1
			STRING
				"*** Error from GET_PARCEL - " DELIMITED BY SIZE
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			DISPLAY ERR_FUNCTION_DETAIL
			GO TO HANDLE_ERRORS
		END-IF
	END-IF.

	IF RES_CODE OF GET_PARCEL_LKG NOT = "A" AND UPDATE_MODE_RUN
		DISPLAY "*** PARCEL NOT APPROVED FOR RESOLUTION PROCESSING - ",
			WS_CURR_PARCEL_NUM
		SET REJECT_RES_NUM TO TRUE
		MOVE "PARCEL NOT APPROVED" TO WS_EXCEPTION_TXT
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.

*  The following statement is trapping a known bug in the resolution process
*  and correcting the RES_SPLIT_COMBINE_FLG value for new parcels.

	IF NEW_PARCEL_FLG IN RES_PHASE_LIST_REC = "Y" AND
	   RES_SPLIT_COMBINE_FLG IN GET_PARCEL_LKG NOT = "Z" THEN
                MOVE "Z" TO RES_SPLIT_COMBINE_FLG IN GET_PARCEL_LKG
		DISPLAY "*** INFORMATIONAL:  NEW PARCEL'S RES_SPLIT_COMBINE_FLG NOT = 'Z' - ",
			WS_CURR_PARCEL_NUM
		DISPLAY "                    PARCEL WILL BE PROCESSED AS A NEW PARCEL."
	END-IF.

	IF NEW_PARCEL_FLG IN RES_PHASE_LIST_REC NOT = "Y" AND
	   RES_SPLIT_COMBINE_FLG IN GET_PARCEL_LKG = "Z"
		DISPLAY "*** INFORMATIONAL:  PARCEL'S RES_SPLIT_COMBINE_FLG = 'Z', BUT NEW_PARCEL_FLG NOT = 'Y' - ",
			WS_CURR_PARCEL_NUM
		DISPLAY "                    PARCEL WILL BE PROCESSED AS A NEW PARCEL."
	END-IF.

	MOVE PARCEL_KEY OF GET_PARCEL_LKG TO
		PARCEL_KEY OF GET_RESOLUTIONS_REC_LKG.
	MOVE WS_RES_PHASE_NUM TO RES_PHASE_NUM IN GET_RESOLUTIONS_REC_LKG.
	CALL "GET_RESOLUTIONS_REC" USING GET_RESOLUTIONS_REC_LKG
		GIVING RETURN_STATUS.
	IF RDB_DEADLOCK
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.
	IF REC_NOT_FOUND
		DISPLAY "*** RESOLUTIONS NOT FOUND IN DATABASE - ",
			WS_CURR_PARCEL_NUM
		SET REJECT_RES_NUM TO TRUE
		MOVE "RESOLUTIONS RECORD NOT FOUND" TO WS_EXCEPTION_TXT
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.
	IF RETURN_STATUS < 1
		STRING
			"*** Error from GET_RESOLUTIONS_REC - " DELIMITED BY SIZE
			WS_CURR_PARCEL_NUM DELIMITED BY SIZE
		    INTO ERR_FUNCTION_DETAIL
		DISPLAY ERR_FUNCTION_DETAIL
		GO TO HANDLE_ERRORS
	END-IF.

	MOVE PARCEL_MASTER_REC  OF GET_PARCEL_LKG TO
		PARCEL_MASTER_REC  OF POST_NEW_TAX_LKG.

	MOVE 0 TO
		AC_PRIMARY_TAX   OF POST_NEW_TAX_LKG,
		AC_SECONDARY_TAX OF POST_NEW_TAX_LKG,
		FLOOD_TAX        OF POST_NEW_TAX_LKG,
		TOT_SD_TAX       OF POST_NEW_TAX_LKG,
		SD_IX.

	PERFORM PROCESS_LAND_IMPROVE_REC THRU PROCESS_LAND_IMPROVE_REC_EXIT.

	IF TAX_EXT_PERS_PROP_CNT IN GET_TAX_EXT_DATA_LKG > ZERO
		PERFORM PROCESS_PERS_PROP_REC THRU PROCESS_PERS_PROP_REC_EXIT
	END-IF.

	MOVE 1 TO SD_IX.
	PERFORM WITH TEST BEFORE UNTIL SD_IX > TAX_EXT_SPEC_DIST_CNT IN
							GET_TAX_EXT_DATA_LKG
		PERFORM PROCESS_SPEC_DIST_REC THRU PROCESS_SPEC_DIST_REC_EXIT
		ADD 1 TO SD_IX
	END-PERFORM.

	ADD
		AC_PRIMARY_TAX IN POST_NEW_TAX_LKG,
		AC_SECONDARY_TAX IN POST_NEW_TAX_LKG,
		FLOOD_TAX IN POST_NEW_TAX_LKG,
		TOT_SD_TAX IN POST_NEW_TAX_LKG
	    GIVING
		WS_NEW_ASSESSED_TAX.

	IF WS_NEW_ASSESSED_TAX NOT = NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC
		DISPLAY "*** COMPUTED NEW ASSESSED TAX NOT = NEW_ASSESSED_TAX IN RES_PHASE_LIST - "
			WS_CURR_PARCEL_NUM 
                " COMPUTED " WS_NEW_ASSESSED_TAX " RES PHASE LIST AMT " 
                NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC WITH CONVERSION
		SET REJECT_RES_NUM TO TRUE
		MOVE "PROBLEM COMPUTING NEW ASSESSED TAX" TO WS_EXCEPTION_TXT
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.

	SET NO_CP TO TRUE.
	MOVE PARCEL_NUM OF PARCEL_MASTER_REC OF GET_PARCEL_LKG TO
		PARCEL_NUM OF GET_CP_LKG.
	MOVE TAX_YEAR OF PARCEL_MASTER_REC OF GET_PARCEL_LKG TO
		TAX_YEAR OF GET_CP_LKG.
	CALL "GET_CP" USING GET_CP_LKG GIVING RETURN_STATUS.
	IF REC_NOT_FOUND
		MOVE 1 TO RETURN_STATUS
		GO TO GET_PARCEL_DATA_EXIT
	END-IF.
	IF RETURN_STATUS < 1
		STRING
			"*** Error from GET_CP - " DELIMITED BY SIZE
			WS_CURR_PARCEL_NUM DELIMITED BY SIZE
		    INTO ERR_FUNCTION_DETAIL
		GO TO HANDLE_ERRORS
	END-IF.

* If this is an outstanding State CP, set the flag STATE_CP so that
* we can update the CPs principal amount after we adjust the taxes.
* If this is an outstanding BuyerCP or the CP is here because of
* a pending purchase, we must reject the resolution.

	IF SAI_CODE OF GET_CP_LKG = SPACES AND
            REDEEMED_FLG OF GET_CP_LKG = "N"
		SET STATE_CP TO TRUE
	ELSE
		IF BTS_FLG OF GET_CP_LKG = "Y"
			SET PARCEL_HAS_PENDING_CP TO TRUE
		ELSE
			IF REDEEMED_FLG OF GET_CP_LKG = "N"
				SET PARCEL_HAS_CP_HOLDER TO TRUE
			END-IF
		END-IF
	END-IF.

GET_PARCEL_DATA_EXIT.
	EXIT.

/
***************
* INIT_PARAMS *
***************

INIT_PARAMS.
	MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC.

	SET RO_TRANS TO TRUE.
	perform START_TRANS thru START_TRANS_EXIT. 

	perform GET_GLOBAL thru GET_GLOBAL_EXIT.

	MOVE "UPPS_PROCESSING" TO LOGICAL_NAME IN TRANSLATE_LOGICAL_LKG.
	CALL "TRANSLATE_LOGICAL" USING TRANSLATE_LOGICAL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS = 1 THEN
		MOVE "YES" TO WS_UNSECURED_PHASE
		display " "
		display " PROCESSING UNSECURED PHASE"
	ELSE
		MOVE "NO" TO WS_UNSECURED_PHASE
		display " PROCESSING SECURED PHASE"
	END-IF.
	display " ".

	MOVE "RUN_EDIT" TO LOGICAL_NAME in TRANSLATE_LOGICAL_LKG.
	CALL "TRANSLATE_LOGICAL" USING TRANSLATE_LOGICAL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		display "ERROR TRANSLATING RUN_EDIT LOGICAL"
		MOVE "ERROR TRANSLATING RUN_EDIT LOGICAL" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.
	EVALUATE EQUIVALENCE_VALUE(1:3)
	    WHEN "YES"
		SET EDIT_MODE_RUN TO TRUE
		display " "
		display "*********************************************************"
		display " "
		display "RUNNING PHASE IN EDIT MODE.  NO DATABASE CHANGES WILL
-			" BE MADE."
		display " "
		display "*********************************************************"
		display " "
	    WHEN "NO "
		SET UPDATE_MODE_RUN TO TRUE
		display " "
		display "*********************************************************"
		display " "
		display "RUNNING PHASE IN UPDATE MODE."
		display " "
		display "*********************************************************"
		display " "
	    WHEN OTHER
		DISPLAY "*****************************************************"
		DISPLAY " "
		DISPLAY "RUN_EDIT LOGICAL HAS AN INVALID VALUE.  ABORTING."
		DISPLAY " "
		DISPLAY "*****************************************************"
                CALL "SYS$EXIT" USING BY VALUE ZERO
		STOP RUN
	END-EVALUATE.
	MOVE SPACES TO RES_PHASE_HDR_DATA.
	SET RES_PHASE_HDR_FROM_PHASE_PROC TO TRUE.
	MOVE "-" TO RES_PHASE_HDR_DASH_1.
	IF EDIT_MODE_RUN MOVE "(EDIT ONLY)" TO RES_PHASE_HDR_RUN_TYPE.
	IF UPDATE_MODE_RUN MOVE "(UPDATE RUN)" TO RES_PHASE_HDR_RUN_TYPE.

	MOVE "RES_YEAR" TO LOGICAL_NAME in TRANSLATE_LOGICAL_LKG.
	CALL "TRANSLATE_LOGICAL" USING TRANSLATE_LOGICAL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		display "ERROR TRANSLATING RES_YEAR LOGICAL"
		MOVE "Error translatting RES_YEAR Logical" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.

	IF EQUIVALENCE_VALUE(1:4) not numeric
		display "ERROR TRANSLATING RES_YEAR_LOGICAL, NON-NUMERIC"
		STRING "Invalid value in RES_YEAR " delimited by size 
			EQUIVALENCE_VALUE(1:4) delimited by size
				INTO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		MOVE 99 TO RETURN_STATUS
		GO TO HANDLE_ERRORS
	END-IF.

	MOVE EQUIVALENCE_VALUE(1:4) TO WS_TAX_YEAR.
	IF WS_TAX_YEAR = CURRENT_YEAR IN GBL_PARAM_VALUES
		MOVE "C" TO WS_BTX_CTX_FLG
	ELSE
		MOVE "B" TO WS_BTX_CTX_FLG
	END-IF.                        
	MOVE WS_TAX_YEAR TO RES_PHASE_HDR_YEAR.

	MOVE "RES_PHASE_NUM" TO LOGICAL_NAME in TRANSLATE_LOGICAL_LKG.
	CALL "TRANSLATE_LOGICAL" USING TRANSLATE_LOGICAL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		display "ERROR TRANSLATING RES_PHASE_NUM LOGICAL" 
		MOVE "Error translatting RES_PHASE_NUM Logical" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.

	IF EQUIVALENCE_VALUE(1:4) not numeric
		display "ERROR TRANSLATING RES_PHASE_NUM LOGICAL, NON-NUMERIC"
		STRING "Invalid value in RES_PHASE_NUM " delimited by size
			EQUIVALENCE_VALUE(1:4) delimited by size
				INTO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		MOVE 99 TO RETURN_STATUS
		GO TO HANDLE_ERRORS
	END-IF.

	MOVE EQUIVALENCE_VALUE(1:4) TO WS_RES_PHASE_NUM.
	MOVE WS_RES_PHASE_NUM TO RES_PHASE_HDR_PH_NUM.
	MOVE RES_PHASE_HDR_INFO TO SUM_HEADER_3_INFO.
	MOVE RES_PHASE_HDR_INFO TO SUM_PARCEL_HEADER_3_INFO.
	MOVE RES_PHASE_HDR_INFO TO REJ_HEADER_3_INFO.
	MOVE RES_PHASE_HDR_INFO TO CSH_HEADER_3_INFO.

	MOVE "RES_CTR_NUM" TO LOGICAL_NAME in TRANSLATE_LOGICAL_LKG.
	CALL "TRANSLATE_LOGICAL" USING TRANSLATE_LOGICAL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		display "ERROR TRANSLATING RES_CTR_NUM LOGICAL"
		MOVE "Error translatting RES_CTR_NUM Logical" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.

	IF EQUIVALENCE_VALUE(1:5) not numeric
		display "ERROR TRANSLATING RES_CTR_NUM LOGICAL, NON-NUMERIC"
		STRING "Invalid value in RES_CTR_NUM " delimited by size
			EQUIVALENCE_VALUE(1:5) delimited by size
			INTO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		MOVE 99 TO RETURN_STATUS
		GO TO HANDLE_ERRORS
	END-IF.

	MOVE EQUIVALENCE_VALUE(1:5) TO WS_CTR_NUM.

       	PERFORM COMMIT_TRAN THRU COMMIT_TRAN_EXIT. 

	CALL "GET_CURRENT_DATE_TIME" USING GET_CURRENT_DATE_TIME_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		MOVE "Error from GET_CURRENT_DATE_TIME" TO ERR_FUNCTION_DETAIL
		MOVE "INIT_PARAMS" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.

      	MOVE DISP_DATE OF GET_CURRENT_DATE_TIME_LKG TO
		RPT_HDR1_DATE OF CSH_HEADER_1,
		RPT_HDR1_DATE OF REJ_HEADER_1,
		RPT_HDR1_DATE OF SUM_HEADER_1.

       MOVE NEXT_TRANS_DATE IN GBL_PARAM_VALUES TO 
                WS_RES_DATE. 

* CREATE A NEXTIS DATE FORMAT.

    PERFORM CREATE_NEXTIS_DATE THRU CREATE_NEXTIS_DATE_EXIT.

* Get ANSI date to use in RES_LCV_PENALTY update.

	INITIALIZE DATE_CONVERT_LKG.
	SET USE_CURRENT_DATE IN INPUT_DATE_TYPE IN DATE_CONVERT_LKG TO TRUE.
	CALL "DATE_CONVERT" USING DATE_CONVERT_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN DISPLAY "ERR GETTING TODAY'S DATE".
	MOVE DATE_ANSI IN DATE_CONVERT_LKG TO WS_TODAY_ANSI.

INIT_PARAMS_EXIT.
	EXIT.

/
****************
* MAIN_STARTUP *
****************

MAIN_STARTUP.

	MOVE "MAIN_STARTUP" TO ERR_FUNCTION_LOC.

	INITIALIZE COM_ERR_STRUCTURE.
	MOVE "RES" TO ERR_SUBSYSTEM.
	SET BATCH_RUN TO TRUE.

	PERFORM INIT_PARAMS THRU INIT_PARAMS_EXIT.

*-----------------      
* letter startup -
*---------------------------------------------------------------------------
	
	PERFORM FETCH_LETTER_TEXT THRU FETCH_LETTER_TEXT_EXIT.   
        PERFORM GET_DATE_FULL THRU GET_DATE_FULL_EXIT.
 
* --------------------------------------------------------------------------   
* end letter startup -
*---------------------

	MOVE SPACES TO WS_AT_END_FLG, WS_PREV_AREA_CODE.
	SET REJECT_RPT_NOT_OPEN TO TRUE.
	MOVE 0 TO WS_NUM_RECS_READ

	MOVE "RES_MTG_REF_REPORT" TO LOGICAL_NAME IN TRANSLATE_LOGICAL_LKG.
	CALL "TRANSLATE_LOGICAL" USING TRANSLATE_LOGICAL_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		MOVE "MAIN_LINE_ROUTINE" TO ERR_FUNCTION_LOC
		MOVE "ERROR TRANSLATING RES_MTG_REF_REPORT" TO ERR_FUNCTION_DETAIL
		DISPLAY "ERROR TRANSLATING RES_MTG_REF_REPORT LOGICAL"
		GO TO HANDLE_ERRORS
	END-IF.

	MOVE EQUIVALENCE_VALUE(1:EQUIVALENCE_LENGTH) TO WS_RES_MTG_REF_RPT_SPEC.
	OPEN OUTPUT RES_MTG_REF_RPT.
     
	PERFORM ZERO_FIELDS THRU ZERO_FIELDS_EXIT.
	INITIALIZE WS_RESTART_BUFFER.
	PERFORM CHECK_FOR_RESTART THRU CHECK_FOR_RESTART_EXIT.

	IF REJECT_RPT_NOT_OPEN
		OPEN OUTPUT RES_REJECT_RPT
		SET REJECT_RPT_OPEN TO TRUE
		MOVE 0 TO REJ_PAGE_CTR
		PERFORM WRITE_REJ_HEADER THRU WRITE_REJ_HEADER_EXIT
	END-IF.

MAIN_STARTUP_EXIT.
	EXIT.

/
****************************
* PROCESS_LAND_IMPROVE_REC *
****************************

PROCESS_LAND_IMPROVE_REC.
	MOVE "PROCESS_LAND_IMPROVE_REC" TO ERR_FUNCTION_LOC.

	MOVE PRIMARY_LAND_ASSESSED_VALUE OF TAX_EXT_MONEY_REC TO
		PRIMARY_LAND_ASSD_VALUE OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_IMPROVE_ASSESSED_VALUE OF TAX_EXT_MONEY_REC TO
		PRIMARY_IMPROVE_ASSD_VALUE OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE WID_VET_EXEMPT_AMT OF TAX_EXT_MONEY_REC TO
		PRIMARY_WID_VET_EXEMPT_AMT OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_LAND_ASSESSED_CLASS OF TAX_EXT_MONEY_REC TO
		LAND_CLASS_CODE OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_LAND_ASSESSED_RATIO OF TAX_EXT_MONEY_REC TO
		PRIMARY_LAND_RATIO OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_LAND_FULL_CASH_VALUE OF TAX_EXT_MONEY_REC TO
		PRIMARY_LAND_FCV OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_IMPROVE_ASSESSED_CLASS OF TAX_EXT_MONEY_REC TO
		IMPROVE_CLASS_CODE OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_IMPROVE_ASSESSED_RATIO OF TAX_EXT_MONEY_REC TO
		PRIMARY_IMPROVE_RATIO OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE PRIMARY_IMPROVE_FULL_CASH_VALUE OF TAX_EXT_MONEY_REC TO
		PRIMARY_IMPROVE_FCV OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.

	MOVE SEC_LAND_ASSESSED_VALUE OF TAX_EXT_MONEY_REC TO
		SECONDARY_LAND_ASSD_VALUE OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE SEC_IMPROVE_ASSESSED_VALUE OF TAX_EXT_MONEY_REC TO
		SECONDARY_IMPROVE_ASSD_VALUE OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE SEC_WID_VET_EXEMPT_AMT OF TAX_EXT_MONEY_REC TO
		SECONDARY_WID_VET_EXEMPT_AMT OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE SEC_LAND_FULL_CASH_VALUE OF TAX_EXT_MONEY_REC TO
		SECONDARY_LAND_FCV OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE SEC_IMPROVE_FULL_CASH_VALUE OF TAX_EXT_MONEY_REC TO
		SECONDARY_IMPROVE_FCV OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE SEC_LAND_RATIO OF TAX_EXT_MONEY_REC TO
		SECONDARY_LAND_RATIO OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.
	MOVE SEC_IMPROVE_RATIO OF TAX_EXT_MONEY_REC TO
		SECONDARY_IMPROVE_RATIO OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.

	MOVE RESIDEN_PCT OF TAX_EXT_MONEY_REC TO
		RESID_PCT OF LAND_IMPROVE_VALUE_REC OF POST_NEW_TAX_LKG.

	MOVE RES_REASON OF TAX_EXT_MONEY_REC TO WS_RES_REASON.
	MOVE AREA_CODE OF TAX_EXT_MONEY_REC TO
		AREA_CODE OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.
	MOVE ASSR_EXEMPT_CODE OF TAX_EXT_MONEY_REC TO
		ASSR_EXEMPT_CODE OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.
	MOVE LOAN_NUM_1_8 OF TAX_EXT_MONEY_REC TO WS_LOAN_NUM_1_8.
	MOVE LOAN_NUM_9_12 OF TAX_EXT_MONEY_REC TO WS_LOAN_NUM_9_12.
	MOVE WS_LOAN_NUM TO
		LOAN_NUM OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.
	MOVE MTG_CODE OF TAX_EXT_MONEY_REC TO
		MTG_CODE OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.
	MOVE BT_CP_CODE OF TAX_EXT_MONEY_REC TO
		BTX_CP_CODE OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.

	IF PART_EXEMPT OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG or
	   FULL_EXEMPT OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG
		MOVE 0.0 TO
			AC_PRIMARY_TAX OF POST_NEW_TAX_LKG,
			AC_SECONDARY_TAX OF POST_NEW_TAX_LKG,
			FLOOD_TAX        OF POST_NEW_TAX_LKG
		go TO PROCESS_LAND_IMPROVE_REC_EXIT
	END-IF.

	ADD
		STATE_TAX      OF TAX_EXT_MONEY_REC,
		COUNTY_TAX     OF TAX_EXT_MONEY_REC,
		JR_COLLEGE_TAX OF TAX_EXT_MONEY_REC,
		SCHOOL_TAX     OF TAX_EXT_MONEY_REC,
		CITY_TAX       OF TAX_EXT_MONEY_REC
	    GIVING AC_PRIMARY_TAX OF POST_NEW_TAX_LKG.

	SUBTRACT
		ELEM_STATE_AID_AMT	OF TAX_EXT_MONEY_REC,
		HS_STATE_AID_AMT		OF TAX_EXT_MONEY_REC,
		ADDNL_ELEM_STATE_AID_AMT  OF TAX_EXT_MONEY_REC,
		ADDNL_HS_STATE_AID_AMT	OF TAX_EXT_MONEY_REC,
                ELEM_EAF                OF TAX_EXT_MONEY_REC,
                HS_EAF                  OF TAX_EXT_MONEY_REC
	    FROM
		AC_PRIMARY_TAX		OF POST_NEW_TAX_LKG.

	ADD
		CAWCD_TAX     OF TAX_EXT_MONEY_REC,
		BOND_TAX      OF TAX_EXT_MONEY_REC,
		OTHER_TAX     OF TAX_EXT_MONEY_REC,
		FIRE_DIST_TAX OF TAX_EXT_MONEY_REC,
		LIBRARY_TAX   OF TAX_EXT_MONEY_REC,
		HEALTH_TAX    OF TAX_EXT_MONEY_REC,
		ELEM_SEC_TAX  OF TAX_EXT_MONEY_REC,
		HS_SEC_TAX    OF TAX_EXT_MONEY_REC
	    GIVING
		AC_SECONDARY_TAX OF POST_NEW_TAX_LKG.

	MOVE FLOOD_TAX OF TAX_EXT_MONEY_REC TO
		FLOOD_TAX OF POST_NEW_TAX_LKG.

PROCESS_LAND_IMPROVE_REC_EXIT.
	EXIT.

/
***********************
* PROCESS_SINGLE_RESO *
***********************

PROCESS_SINGLE_RESO.
	MOVE "PROCESS_SINGLE_RESO" TO ERR_FUNCTION_LOC.

	INITIALIZE WS_RES_NUM_PMT_TABLE, WS_RES_NUM_PMT_IX,
		RES_NUM_PARCEL_TABLE, RES_NUM_PARCEL_CNT.

*	DISPLAY "Processing Res Num #", WS_CURR_RES_NUM WITH NO ADVANCING.

&RDB&	GET
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		MOVE "ERROR IN GET TOTAL." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR
&RDB&	  WS_RES_NUM_NEW_ASSESSED_TAX = TOTAL R.NEW_ASSESSED_TAX OF
&RDB&		R IN PROPERTY.RES_PHASE_LIST WITH
&RDB&		R.RES_PHASE_NUM = WS_RES_PHASE_NUM AND
&RDB&		R.TAX_YEAR = WS_TAX_YEAR AND
&RDB&		R.RES_NUM = WS_CURR_RES_NUM AND
&RDB&		R.VALID_FLG = "Y"
&RDB&	END_GET

	IF COMMON_TYPE IN RES_NUM_WORK_REC AND
	   WS_RES_NUM_NEW_ASSESSED_TAX = ZERO THEN
		DISPLAY " "
		DISPLAY "*** COMMON AREA RESOLUTION WITH NO NEW TAXES!"
		SET REJECT_RES_NUM TO TRUE
		MOVE "COMMON AREA RESOLUTION HAS NO NEW ASSESSED TAX" TO
			WS_EXCEPTION_TXT
		GO TO PROCESS_SINGLE_RESO_EXIT
	END-IF.

&RDB&	START_STREAM RES_NUM_STREAM USING R IN PROPERTY.RES_PHASE_LIST WITH
&RDB&		R.RES_PHASE_NUM = WS_RES_PHASE_NUM AND
&RDB&		R.TAX_YEAR = WS_TAX_YEAR AND
&RDB&		R.RES_NUM = WS_CURR_RES_NUM AND
&RDB&		R.VALID_FLG = "Y"
&RDB&		SORTED BY R.PARCEL_BOOK_MAP_ITEM, R.PARCEL_SPLIT
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		MOVE "ERROR IN START_STREAM." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR.

RES_NUM_FETCH.
	MOVE "RES_NUM_FETCH" TO ERR_FUNCTION_LOC.

&RDB&	FETCH RES_NUM_STREAM
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		MOVE "ERROR IN FETCH." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR
&RDB&	   AT END
		GO TO END_SINGLE_RES_NUM_STREAM
&RDB&	END_FETCH

&RDB&	GET
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		MOVE "ERROR IN GET." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR
&RDB&	  RES_PHASE_LIST_REC = R.*
&RDB&	END_GET

	ADD 1 TO RES_NUM_PARCEL_CNT.
	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
		PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE RES_REASON IN RES_PHASE_LIST_REC TO
		RES_REASON IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC TO
		NEW_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	ADD NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC TO
		WS_RES_NUM_NEW_ASSESSED_TAX.
	MOVE NEW_SPLIT_COMBINE_TAX_PCT IN RES_PHASE_LIST_REC TO
		REAPPLY_PCT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).

	IF RES_NUM_PARCEL_CNT > 1
		DISPLAY " "
		DISPLAY "*** MORE THAN 1 PARCEL WITH SAME RES NUM (NOT A SPLIT/COMBINE)"
		SET REJECT_RES_NUM TO TRUE
		MOVE "INVALID REASON FOR RES NUM WITH MULTIPLE PARCELS" TO
			WS_EXCEPTION_TXT
		GO TO END_SINGLE_RES_NUM_STREAM
	END-IF.

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO WS_CURR_PARCEL_BMI.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO WS_CURR_PARCEL_SPLIT.

*       By Default we'll use the global param value for resolution interest.
*	If this is a Judgment or Appeal however, we gotta go get a different
*       juan.
	MOVE RES_INT_RATE IN GBL_PARAM_VALUES TO WS_RES_INT_RATE.

	MOVE RES_REASON IN RES_PHASE_LIST_REC TO JUDGMENT_CODE_TEST.
	IF IS_JUDGMENT THEN
	    PERFORM GET_JUDGMENT_RATE THRU GET_JUDGMENT_RATE_EXIT
	    IF RDB_DEADLOCK THEN
		GO TO PROCESS_SINGLE_RESO_EXIT
	    END-IF
	END-IF.
	MOVE RES_REASON IN RES_PHASE_LIST_REC TO APPEAL_CODE_TEST.
	IF IS_APPEAL THEN
	    DIVIDE DOR_RATE_PCT IN RES_PHASE_REC BY 100 GIVING WS_RES_INT_RATE
	END-IF.

*	DISPLAY " - Parcel #", WS_CURR_PARCEL_NUM.

	PERFORM ZERO_FIELDS THRU ZERO_FIELDS_EXIT.

	PERFORM GET_PARCEL_DATA THRU GET_PARCEL_DATA_EXIT.
	IF RDB_DEADLOCK
		GO TO PROCESS_SINGLE_RESO_EXIT
	END-IF.
	IF REJECT_RES_NUM
		GO TO END_SINGLE_RES_NUM_STREAM
	END-IF.

	MOVE ASSESSED_TAX IN GET_PARCEL_LKG TO
		PREV_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE DB_KEY IN GET_PARCEL_LKG TO
		PM_DBKEY IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).

	IF PARCEL_HAS_CP_HOLDER
		MOVE "CP HOLDER" TO THE_REJECT_REASON.
	IF PARCEL_HAS_PENDING_CP
		MOVE "PENDING CP" TO THE_REJECT_REASON.
	IF STATE_CP
		MOVE "STATE CP" TO THE_REJECT_REASON.

	IF PARCEL_HAS_CP_HOLDER OR PARCEL_HAS_PENDING_CP OR STATE_CP
		PERFORM WRITE_REJECT_RPT THRU WRITE_REJECT_RPT_EXIT
		SET REJECT_RES_NUM TO TRUE
		MOVE "PARCEL HAS EXISTING OR PENDING CP" TO WS_EXCEPTION_TXT
        ELSE
		PERFORM DO_A_RESOLUTION THRU DO_A_RESOLUTION_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		PERFORM APPORTION_INTEREST THRU APPORTION_INTEREST_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		PERFORM UPDATE_RESOLUTION_REC THRU UPDATE_RESOLUTION_REC_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF
		PERFORM UPDATE_BTX_CP_CODES THRU UPDATE_BTX_CP_CODES_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SINGLE_RESO_EXIT
		END-IF

*               For Judgments, we clear the Litig Pend Flag on the
*               Update Run.  It was set by CratePhaseList during the
*               Edit Run.  This flag is used to drive where overpayments
*               are placed.  When the Litigation Pending Flag is set,
*               ReapplyPmts subroutine will move the overpayments to the
*               Litigation Impound.  Afterwards, the flag serves no further
*               purpose for us, so we'll clear it now.
		IF UPDATE_MODE_RUN AND IS_JUDGMENT THEN
		    PERFORM UPDATE_LIT_FLG THRU UPDATE_LIT_FLG_EXIT
		    IF RDB_DEADLOCK THEN
			GO TO PROCESS_SINGLE_RESO_EXIT
		    END-IF
		END-IF

*		Tar 41897, Civil Penalty.
		IF UPDATE_MODE_RUN AND (RES_REASON IN RES_PHASE_LIST_REC = "25"
		   OR RES_REASON IN RES_PHASE_LIST_REC = "26") THEN
			PERFORM UPDATE_LCV_PENALTY_REC THRU
			        UPDATE_LCV_PENALTY_REC_EXIT
			IF RDB_DEADLOCK THEN
				GO TO PROCESS_SINGLE_RESO_EXIT
			END-IF
			IF RETURN_STATUS < 1 THEN
                            GO TO HANDLE_ERRORS
                        END-IF
		END-IF

		MOVE 1 TO RES_NUM_PARCEL_IX
	
		PERFORM WRITE_SUMMARY_RPT_LINE THRU
		     WRITE_SUMMARY_RPT_LINE_EXIT
* Tar 41897, don't create letters for Civil Penalty.
		PERFORM PROCESS_SINGLE_LETTER THRU
		     PROCESS_SINGLE_LETTER_EXIT

        END-IF.

        PERFORM ZERO_FIELDS THRU ZERO_FIELDS_EXIT.

* Since this is a SINGLE reso, we will not use the cursor.
* simply end the stream.  bobJuan 5/21/2002.
             
END_SINGLE_RES_NUM_STREAM.
	MOVE "END_SINGLE_RES_NUM_STREAM" TO ERR_FUNCTION_LOC.

&RDB&	END_STREAM RES_NUM_STREAM.

PROCESS_SINGLE_RESO_EXIT.
	EXIT.

/
*************************
* PROCESS_SPLIT_COMBINE *
*************************

PROCESS_SPLIT_COMBINE.
	MOVE "PROCESS_SPLIT_COMBINE" TO ERR_FUNCTION_LOC.

	INITIALIZE WS_RES_NUM_PMT_TABLE, WS_RES_NUM_PMT_IX,
		RES_NUM_PARCEL_TABLE, RES_NUM_PARCEL_CNT,
		RESTORE_PMTS_LKG, CANCEL_TAX_LKG, POST_NEW_TAX_LKG,
		REAPPLY_SPLIT_PMTS_LKG.
*
*  This flag will prevent any payments from being reapplied for a certain
*  resolution number.  If any parcel record in the RES_PHASE_LIST table
*  for the resolution number has the REAPPLY_FLG set to "N", then this
*  variable (WS_REAPPLY_SPLIT_PMT_FLG) will be set to "N" and all restored
*  funds will be impounded.
*
	MOVE "Y" TO WS_REAPPLY_SPLIT_PMT_FLG.

*	DISPLAY "Processing Res Num #", WS_CURR_RES_NUM.

&RDB&	GET
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF
		MOVE "ERROR IN GET TOTAL." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR
&RDB&	  WS_RES_NUM_NEW_ASSESSED_TAX = TOTAL R.NEW_ASSESSED_TAX OF
&RDB&		R IN PROPERTY.RES_PHASE_LIST WITH
&RDB&		R.RES_PHASE_NUM = WS_RES_PHASE_NUM AND
&RDB&		R.TAX_YEAR = WS_TAX_YEAR AND
&RDB&		R.RES_NUM = WS_CURR_RES_NUM AND
&RDB&		R.VALID_FLG = "Y"
&RDB&	END_GET

	IF COMMON_TYPE IN RES_NUM_WORK_REC AND
	   WS_RES_NUM_NEW_ASSESSED_TAX = ZERO THEN
		DISPLAY " "
		DISPLAY "*** COMMON AREA RESOLUTION WITH NO NEW TAXES!"
		SET REJECT_RES_NUM TO TRUE
		MOVE "COMMON AREA RESOLUTION HAS NO NEW ASSESSED TAX" TO
			WS_EXCEPTION_TXT
		GO TO PROCESS_SPLIT_COMBINE_EXIT
	END-IF.

&RDB&	START_STREAM RES_NUM_STREAM USING R IN PROPERTY.RES_PHASE_LIST WITH
&RDB&		R.RES_PHASE_NUM = WS_RES_PHASE_NUM AND
&RDB&		R.TAX_YEAR = WS_TAX_YEAR AND
&RDB&		R.RES_NUM = WS_CURR_RES_NUM AND
&RDB&		R.VALID_FLG = "Y"
&RDB&		SORTED BY R.PARCEL_BOOK_MAP_ITEM, R.PARCEL_SPLIT
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF
		MOVE "ERROR IN START_STREAM." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR.

RES_NUM_SPLIT_FETCH.
	MOVE "RES_NUM_SPLIT_FETCH" TO ERR_FUNCTION_LOC.

&RDB&	FETCH RES_NUM_STREAM
&RDB&	   ON ERROR
	       	CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF
		MOVE "ERROR IN FETCH." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR                                           
&RDB&	   END_ERROR
&RDB&	   AT END
		GO TO END_SPLIT_RES_NUM_STREAM
&RDB&	END_FETCH

&RDB&	GET
&RDB&	   ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF
		MOVE "ERROR IN GET." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR
&RDB&	   END_ERROR
&RDB&	  RES_PHASE_LIST_REC = R.*
&RDB&	END_GET

	ADD 1 TO RES_NUM_PARCEL_CNT.
	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
		PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE RES_REASON IN RES_PHASE_LIST_REC TO
		RES_REASON IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC TO
		NEW_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	ADD NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC TO
		WS_RES_NUM_NEW_ASSESSED_TAX.
	MOVE NEW_SPLIT_COMBINE_TAX_PCT IN RES_PHASE_LIST_REC TO
		REAPPLY_PCT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO WS_CURR_PARCEL_BMI.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO WS_CURR_PARCEL_SPLIT.

	IF REAPPLY_FLG IN RES_PHASE_LIST_REC = "N"
		MOVE "N" TO WS_REAPPLY_SPLIT_PMT_FLG
	END-IF.

	INITIALIZE RESTORE_PMTS_LKG, CANCEL_TAX_LKG, POST_NEW_TAX_LKG.

	PERFORM GET_PARCEL_DATA THRU GET_PARCEL_DATA_EXIT.
	IF RDB_DEADLOCK
		GO TO PROCESS_SPLIT_COMBINE_EXIT
	END-IF.
	IF REJECT_RES_NUM
		GO TO END_SPLIT_RES_NUM_STREAM
	END-IF.

	MOVE ASSESSED_TAX IN GET_PARCEL_LKG TO
		PREV_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	ADD ASSESSED_TAX IN GET_PARCEL_LKG TO
		TOTAL_PREV_ASSESSED_TAX IN REAPPLY_SPLIT_PMTS_LKG.
	ADD NEW_ASSESSED_TAX IN RES_PHASE_LIST_REC TO
		TOTAL_NEW_ASSESSED_TAX IN REAPPLY_SPLIT_PMTS_LKG.
	MOVE DB_KEY IN GET_PARCEL_LKG TO
		PM_DBKEY IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).

	IF PARCEL_HAS_CP_HOLDER
		MOVE "CP HOLDER" TO THE_REJECT_REASON.
	IF PARCEL_HAS_PENDING_CP
		MOVE "PENDING CP" TO THE_REJECT_REASON.
	IF STATE_CP
		MOVE "STATE CP" TO THE_REJECT_REASON.

	IF PARCEL_HAS_CP_HOLDER OR PARCEL_HAS_PENDING_CP OR STATE_CP
		PERFORM WRITE_REJECT_RPT THRU WRITE_REJECT_RPT_EXIT
		SET REJECT_RES_NUM TO TRUE
		MOVE "PARCEL HAS EXISTING OR PENDING CP" TO WS_EXCEPTION_TXT
        ELSE
		PERFORM DO_SPLIT_RESOLUTION THRU DO_SPLIT_RESOLUTION_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF
		PERFORM UPDATE_RESOLUTION_REC THRU UPDATE_RESOLUTION_REC_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF
        END-IF.

	GO TO RES_NUM_SPLIT_FETCH.
             
END_SPLIT_RES_NUM_STREAM.

	MOVE "END_SPLIT_RES_NUM_STREAM" TO ERR_FUNCTION_LOC.

&RDB&	END_STREAM RES_NUM_STREAM

	IF REJECT_RES_NUM
		GO TO PROCESS_SPLIT_COMBINE_EXIT
	END-IF.

	PERFORM REAPPLY_SPLIT_PMTS THRU REAPPLY_SPLIT_PMTS_EXIT.
	IF RDB_DEADLOCK
		GO TO PROCESS_SPLIT_COMBINE_EXIT
	END-IF.
	IF WS_SKIP_THIS_PARCEL = "YES"
		SET REJECT_RES_NUM TO TRUE
		MOVE "PROBLEM REAPPLYING GROUP PAYMENTS" TO WS_EXCEPTION_TXT
		GO TO PROCESS_SPLIT_COMBINE_EXIT
	END-IF.

	MOVE 1 TO RES_NUM_PARCEL_IX.
	PERFORM WITH TEST BEFORE UNTIL RES_NUM_PARCEL_IX > RES_NUM_PARCEL_CNT
		MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG
		MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_SPLIT IN GET_PARCEL_LKG
		MOVE WS_TAX_YEAR TO TAX_YEAR IN GET_PARCEL_LKG

* During an Edit Run, new parcels will have an "R" in their PARCEL_SEQ_NUM.
* On this get below, we need to account for that.  

                IF EDIT_MODE_RUN THEN
                    PERFORM GET_EDIT_RUN_PARCEL THROUGH
                            GET_EDIT_RUN_PARCEL_EXIT
                ELSE
		    MOVE "0" TO PARCEL_SEQ_NUM IN GET_PARCEL_LKG
		    CALL "GET_PARCEL" USING GET_PARCEL_LKG
			    GIVING RETURN_STATUS
                END-IF

                IF RETURN_STATUS < 1 THEN
                    IF RETURN_STATUS = REC_NOT_FOUND_ERR_CODE THEN
                        SET REJECT_RES_NUM TO TRUE
                        MOVE "PROBLEM REAPPLYING GROUP PAYMENTS" TO
                              WS_EXCEPTION_TXT
                        GO TO PROCESS_SPLIT_COMBINE_EXIT
                    ELSE
                        GO TO HANDLE_ERRORS
                    END-IF
                END-IF

		IF ASSESSED_TAX IN GET_PARCEL_LKG > MINIMUM_FULL_TAX IN
						 GET_MINIMUM_FULL_TAX_LKG
			DIVIDE ASSESSED_TAX IN GET_PARCEL_LKG BY 2
				GIVING WS_HALF_TAX ROUNDED
			IF REAPPLY_TAX_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) >
				WS_HALF_TAX
				MOVE WS_HALF_TAX TO
					ASSESSED_TAX_PAID_1ST_HALF IN
						GET_PARCEL_LKG
				SUBTRACT WS_HALF_TAX FROM
					REAPPLY_TAX_AMT IN
					RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
				    GIVING ASSESSED_TAX_PAID_2ND_HALF IN
					GET_PARCEL_LKG
			ELSE
				MOVE REAPPLY_TAX_AMT IN
					RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
					TO ASSESSED_TAX_PAID_1ST_HALF IN
						GET_PARCEL_LKG
				MOVE ZERO TO
					ASSESSED_TAX_PAID_2ND_HALF IN
						GET_PARCEL_LKG
			END-IF
		ELSE
			MOVE REAPPLY_TAX_AMT IN
				RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
				ASSESSED_TAX_PAID_1ST_HALF IN GET_PARCEL_LKG
			MOVE ZERO TO
				ASSESSED_TAX_PAID_2ND_HALF IN GET_PARCEL_LKG
		END-IF

		SET RES_COMPLETED IN GET_PARCEL_LKG TO TRUE
		PERFORM UPDATE_BTX_CP_CODES THRU UPDATE_BTX_CP_CODES_EXIT
		IF RDB_DEADLOCK
			GO TO PROCESS_SPLIT_COMBINE_EXIT
		END-IF

		MOVE RES_INT_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			WS_RES_INT_TMP

		IF WS_RES_INT_TMP > ZERO

*			Unfortunately, in a Split/Combine situation, we cannot
*			use the pre-version of the parcel's percentages
*			for Resolution Interest calculations.

			INITIALIZE RECALC_RESINT_PCTS_LKG
			MOVE PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG TO
				PARCEL_BOOK_MAP_ITEM IN RECALC_RESINT_PCTS_LKG
			MOVE PARCEL_SPLIT IN GET_PARCEL_LKG TO
				PARCEL_SPLIT IN RECALC_RESINT_PCTS_LKG
			MOVE TAX_YEAR IN GET_PARCEL_LKG TO
				TAX_YEAR IN RECALC_RESINT_PCTS_LKG
			MOVE PARCEL_SEQ_NUM IN GET_PARCEL_LKG TO
				PARCEL_SEQ_NUM IN RECALC_RESINT_PCTS_LKG
			MOVE AREA_CODE IN GET_PARCEL_LKG TO
				AREA_CODE IN ARCHIVE_LKG
			CALL "RECALC_RESINT_PCTS" USING RECALC_RESINT_PCTS_LKG
				GIVING RETURN_STATUS
			IF RDB_DEADLOCK THEN
				GO TO PROCESS_SPLIT_COMBINE_EXIT
			END-IF
			IF RETURN_STATUS < 1 THEN
				GO TO HANDLE_ERRORS
			END-IF
			PERFORM APPORTION_INTEREST THRU
				APPORTION_INTEREST_EXIT
			IF RDB_DEADLOCK THEN
				GO TO PROCESS_SPLIT_COMBINE_EXIT
			END-IF
		END-IF


		PERFORM WRITE_SUMMARY_RPT_LINE THRU
			WRITE_SUMMARY_RPT_LINE_EXIT

*		PERFORM PROCESS_GROUP_LETTER THRU
*			PROCESS_GROUP_LETTER_EXIT

		ADD 1 TO RES_NUM_PARCEL_IX

	END-PERFORM.


PROCESS_SPLIT_COMBINE_EXIT.

/
*************************
* PROCESS_PERS_PROP_REC *
*************************

PROCESS_PERS_PROP_REC.

*
* There may be more than one PERS_PROP_REC in the GetTaxExtDataLkg.
* We'll break um down here and move the data into the PostNewTaxLkg.
*

    MOVE "PROCESS_PERS_PROP_REC" TO ERR_FUNCTION_LOC.

    MOVE PARCEL_BOOK_MAP_ITEM IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO
         PARCEL_BOOK_MAP_ITEM IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE PARCEL_SPLIT IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO
         PARCEL_SPLIT IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE TAX_YEAR IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO
         TAX_YEAR IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE "0" TO PARCEL_SEQ_NUM IN PERSONAL_PROPERTY_REC IN
         POST_NEW_TAX_LKG.
    MOVE RESIDEN_PCT IN GET_TAX_EXT_DATA_LKG TO
         RESID_PCT IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    IF WS_UNSECURED_PHASE = "YES" THEN
        MOVE ACCOUNT_TYPE_CODE IN TAX_EXT_PERS_PROP_DATA IN
             GET_TAX_EXT_DATA_LKG(1) TO ACCOUNT_TYPE_CODE IN
             PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG
    ELSE
        MOVE 5 TO ACCOUNT_TYPE_CODE IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG
    END-IF.
    MOVE PENALTY_PCT IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO 
         PENALTY_PCT IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE PRORATE_PCT IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO 
         PRORATE_PCT IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE DELINQ_DATE IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO 
         DELINQ_DATE IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE LEASE_COMPANY_ID IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(1) TO
         LEASE_COMPANY_ID IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG.
    MOVE PRIMARY_WID_VET_EXEMPT_AMT IN TAX_EXT_PERS_PROP_REC IN
         GET_TAX_EXT_DATA_LKG(1) TO
         PRIMARY_WID_VET_EXEMPT_AMT IN PERSONAL_PROPERTY_REC IN
         POST_NEW_TAX_LKG.
    MOVE SEC_WID_VET_EXEMPT_AMT IN TAX_EXT_PERS_PROP_REC IN
         GET_TAX_EXT_DATA_LKG(1) TO
         SECONDARY_WID_VET_EXEMPT_AMT IN PERSONAL_PROPERTY_REC IN 
         POST_NEW_TAX_LKG.

* The Tax Amounts are the same in each element of the array.

    ADD STATE_TAX      OF TAX_EXT_PERS_PROP_REC(1),
        COUNTY_TAX     OF TAX_EXT_PERS_PROP_REC(1),
        JR_COLLEGE_TAX OF TAX_EXT_PERS_PROP_REC(1),
        SCHOOL_TAX     OF TAX_EXT_PERS_PROP_REC(1),
        CITY_TAX       OF TAX_EXT_PERS_PROP_REC(1) TO 
                       AC_PRIMARY_TAX OF POST_NEW_TAX_LKG.


    SUBTRACT ELEM_STATE_AID_AMT OF TAX_EXT_PERS_PROP_REC(1),
             HS_STATE_AID_AMT OF TAX_EXT_PERS_PROP_REC(1),
             ADDNL_ELEM_STATE_AID_AMT OF TAX_EXT_PERS_PROP_REC(1),
             ADDNL_HS_STATE_AID_AMT OF TAX_EXT_PERS_PROP_REC(1),
             ELEM_EAF OF TAX_EXT_PERS_PROP_REC(1),
             HS_EAF OF TAX_EXT_PERS_PROP_REC(1)
        FROM AC_PRIMARY_TAX OF POST_NEW_TAX_LKG.

    ADD CAWCD_TAX      OF TAX_EXT_PERS_PROP_REC(1),
        BOND_TAX       OF TAX_EXT_PERS_PROP_REC(1),
        OTHER_TAX      OF TAX_EXT_PERS_PROP_REC(1),
        FIRE_DIST_TAX  OF TAX_EXT_PERS_PROP_REC(1),
        LIBRARY_TAX    OF TAX_EXT_PERS_PROP_REC(1),
        HEALTH_TAX     OF TAX_EXT_PERS_PROP_REC(1),
	ELEM_SEC_TAX   OF TAX_EXT_PERS_PROP_REC(1),
	HS_SEC_TAX     OF TAX_EXT_PERS_PROP_REC(1) TO 
                       AC_SECONDARY_TAX OF POST_NEW_TAX_LKG.



    MOVE ZERO TO IX.

PERS_PROP_DETAIL_LOOP.

    ADD 1 TO IX.
    IF IX > TAX_EXT_PERS_PROP_CNT IN GET_TAX_EXT_DATA_LKG THEN
        GO TO DONE_PERS_PROP_LOOP
    END-IF.

    MOVE PARCEL_KEY IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG TO
         PARCEL_KEY IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE TAX_YEAR IN PERSONAL_PROPERTY_REC IN POST_NEW_TAX_LKG TO
         TAX_YEAR IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE "0" TO PARCEL_SEQ_NUM IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE PRIMARY_ASSESSED_CLASS IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(IX) TO
         ASSESSMENT_CLASS IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE PRIMARY_ASSESSED_RATIO IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(IX) TO 
         ASSESSMENT_RATIO IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE LEGISLATIVE_CLASS IN TAX_EXT_PERS_PROP_DATA IN
         GET_TAX_EXT_DATA_LKG(ix) TO 
         LEGISLATIVE_CLASS IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).

    MOVE PRIMARY_ASSESSED_VALUE IN TAX_EXT_PERS_PROP_REC IN 
         GET_TAX_EXT_DATA_LKG(IX) TO 
         PRIMARY_ASSESSED_VALUE IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE PRIMARY_FULL_CASH_VALUE IN TAX_EXT_PERS_PROP_REC IN 
         GET_TAX_EXT_DATA_LKG(IX) TO
         PRIMARY_VALUE IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE SEC_ASSESSED_VALUE IN TAX_EXT_PERS_PROP_REC IN 
         GET_TAX_EXT_DATA_LKG(IX) TO
         SECONDARY_ASSESSED_VALUE IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE SEC_ASSESSED_FULL_CASH_VALUE IN TAX_EXT_PERS_PROP_REC IN 
         GET_TAX_EXT_DATA_LKG(IX) TO 
         SECONDARY_VALUE IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE PRIMARY_EXEMPT_AMT IN TAX_EXT_PERS_PROP_REC IN
         GET_TAX_EXT_DATA_LKG(IX) TO
         PRIMARY_EXEMPT_AMT IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE SECONDARY_EXEMPT_AMT IN TAX_EXT_PERS_PROP_REC IN
         GET_TAX_EXT_DATA_LKG(IX) TO
         SECONDARY_EXEMPT_AMT IN PERS_PROP_CLASS_TABLE IN POST_NEW_TAX_LKG(IX).
    MOVE IX TO PERS_PROP_CLASS_CNT IN POST_NEW_TAX_LKG.

    IF PART_EXEMPT OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG OR
       FULL_EXEMPT OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG
		GO TO DONE_PERS_PROP_LOOP
    END-IF.

    GO TO PERS_PROP_DETAIL_LOOP.

DONE_PERS_PROP_LOOP.

PROCESS_PERS_PROP_REC_EXIT.
	EXIT.

/
*************************
* PROCESS_SPEC_DIST_REC *
*************************

PROCESS_SPEC_DIST_REC.
	MOVE "PROCESS_SPEC_DIST_REC" TO ERR_FUNCTION_LOC.

	MOVE AREA_CODE OF TAX_EXT_SPEC_DIST_REC(SD_IX)(2:5) TO
		DIST OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX)
		SPEC_DIST_BASE_DEF.
	MOVE ASSR_ACRES_INDICATOR OF TAX_EXT_SPEC_DIST_REC(SD_IX) TO
		ASSR_ACRES_FLG OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX).
	MOVE ASSESSED_VALUE OF TAX_EXT_SPEC_DIST_REC(SD_IX) TO
		ASSR_ACRES_VALUE OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX).
	MOVE SPEC_DIST_TAX OF TAX_EXT_SPEC_DIST_REC(SD_IX) TO
		SPEC_DIST_TAX_AMT OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX).
	MOVE 0.00 TO TOT_AMT_PAID OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX).
	MOVE 0.00 TO SPEC_DIST_PCT OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX).

	IF SPEC_DIST_PRIMARY
		MOVE "P" TO PRI_SEC_FLG OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX)
	ELSE
		MOVE "S" TO  PRI_SEC_FLG OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX)
	END-IF.

	IF FULL_EXEMPT OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG
		MOVE 0.00 TO
			SPEC_DIST_TAX_AMT OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX)
	END-IF.

	ADD SPEC_DIST_TAX_AMT OF SPEC_DIST_ENTRY OF POST_NEW_TAX_LKG(SD_IX) TO
		TOT_SD_TAX OF POST_NEW_TAX_LKG.

PROCESS_SPEC_DIST_REC_EXIT.
	EXIT.

/
*********************
* PROCESS_THE_PHASE *
*********************
PROCESS_THE_PHASE.
	MOVE "PROCESS_THE_PHASE" TO ERR_FUNCTION_LOC.

	READ RES_NUM_WORK_FIL
	        AT END CLOSE RES_NUM_WORK_FIL
	        GO TO PROCESS_THE_PHASE_EXIT.

RESTART_TRAN.

	PERFORM ZERO_FIELDS THRU ZERO_FIELDS_EXIT.

	INITIALIZE WS_RES_NUM_RESTORE_AMT, WS_RES_NUM_REAPPLY_AMT,
		WS_RES_NUM_NEW_ASSESSED_TAX.

	SET RW_TRANS TO TRUE.
	PERFORM START_TRANS THRU START_TRANS_EXIT.

	SET ACCEPT_RES_NUM TO TRUE.

	MOVE RES_NUM IN RES_NUM_WORK_REC TO WS_CURR_RES_NUM.

	IF ITEM_CNT IN RES_NUM_WORK_REC = 1
		IF SPLIT_COMBINE_TYPE IN RES_NUM_WORK_REC THEN
			DISPLAY "SPLIT/COMBINE WITH ONLY 1 PARCEL."
			SET REJECT_RES_NUM TO TRUE
			MOVE "SPLIT/COMBINE RESO ONLY HAS ONE PARCEL" TO
				WS_EXCEPTION_TXT
		ELSE
			PERFORM PROCESS_SINGLE_RESO THRU
				PROCESS_SINGLE_RESO_EXIT
			IF RDB_DEADLOCK THEN
				PERFORM HANDLE_DEADLOCK THRU
					HANDLE_DEADLOCK_EXIT
				SET REPROCESSING_DEADLOCKED_DATA TO TRUE
				GO TO RESTART_TRAN
			END-IF
		END-IF
	ELSE
		IF NO_GROUP_TYPE IN RES_NUM_WORK_REC 
			DISPLAY "MULTIPLE PARCELS WITH SAME RES NUM, BUT NOT SPLIT/COMBINE."
			SET REJECT_RES_NUM TO TRUE
			MOVE "INVALID REASON FOR RES NUM WITH MULTIPLE PARCELS"
				TO WS_EXCEPTION_TXT
		ELSE
*                       Judgments and Appeals
*                       are not Group Type of resolutions.  We use the
*                       default Inerest Rate from the Global Parameters
*                       for these.  Whice right now, is zero.
                        MOVE RES_INT_RATE IN GBL_PARAM_VALUES TO
                             WS_RES_INT_RATE
			PERFORM PROCESS_SPLIT_COMBINE THRU
				PROCESS_SPLIT_COMBINE_EXIT
			IF RDB_DEADLOCK THEN
				PERFORM HANDLE_DEADLOCK THRU
					HANDLE_DEADLOCK_EXIT
				SET REPROCESSING_DEADLOCKED_DATA TO TRUE
				GO TO RESTART_TRAN
			END-IF
		END-IF
	END-IF.

**	If reprocessing_deadlocked switch was set, record counts not incremented
**	   by get_parcel_data section which was performed by above process
	SET NOT_REPROCESSING_DEADLOCK TO TRUE.

	IF WS_RES_NUM_RESTORE_AMT NOT = WS_RES_NUM_REAPPLY_AMT
		DISPLAY " "
		DISPLAY "********************************************"
		DISPLAY "RES #", WS_CURR_RES_NUM, " IS OUT-OF-BALANCE."
		DISPLAY "  TOTAL RESTORE = ", WS_RES_NUM_RESTORE_AMT
		DISPLAY "  TOTAL REAPPLY = ", WS_RES_NUM_REAPPLY_AMT
		DISPLAY "********************************************"
		DISPLAY " "
	END-IF.

CHECK_REJECT.

	IF REJECT_RES_NUM
		DISPLAY " SKIPPING RES NUM #", WS_CURR_RES_NUM
		PERFORM ROLLBACK_TRAN THRU ROLLBACK_TRAN_EXIT
		IF UPDATE_MODE_RUN THEN
			DISPLAY " DISAPPROVING RES NUM #", WS_CURR_RES_NUM
			PERFORM DISAPPROVE_THIS_RESO THRU
				DISAPPROVE_THIS_RESO_EXIT
		END-IF
	ELSE
		MOVE WS_CURR_RES_NUM TO WS_LAST_RES_NUM IN WS_RESTART_BUFFER
		IF UPDATE_MODE_RUN
			PERFORM UPDATE_RESTART THRU
				UPDATE_RESTART_EXIT
			IF RDB_DEADLOCK THEN
				SET REPROCESSING_DEADLOCKED_DATA TO TRUE
				PERFORM HANDLE_DEADLOCK THRU
					HANDLE_DEADLOCK_EXIT
				GO TO PROCESS_THE_PHASE
			END-IF
		END-IF
	        PERFORM COMMIT_TRAN THRU COMMIT_TRAN_EXIT
	END-IF.

	GO TO PROCESS_THE_PHASE.

PROCESS_THE_PHASE_EXIT.
	EXIT.
SHOW_TIME_AND_PARCELS.
	CALL "GET_CURRENT_DATE_TIME" USING GET_CURRENT_DATE_TIME_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		MOVE "Error from GET_CURRENT_DATE_TIME" TO ERR_FUNCTION_DETAIL
		MOVE "PROCESS_THE_PHASE" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.
	DISPLAY " PROCESS COUNT = " WS_PARCELS_PROCESSED " AT " DISP_TIME.
	MOVE 0 TO WS_PARCELS_SINCE_TIME.
SHOW_TIME_AND_PARCELS_EXIT.  EXIT.

/
****************************
RESTART_AUDIT_RPT.
****************************

	DISPLAY "REBUILDING AUDIT REPORT...".

	OPEN INPUT RES_AUDIT_RESTART_RPT.
	OPEN OUTPUT RES_AUDIT_RPT.

AUDIT_RPT_LOOP.

	READ RES_AUDIT_RESTART_RPT
	    AT END
		GO TO FINISH_AUDIT_RPT
	END-READ.

	MOVE AUDIT_RESTART_REC TO AUDIT_RPT_REC.

	WRITE AUDIT_RPT_REC.

	GO TO AUDIT_RPT_LOOP.

FINISH_AUDIT_RPT.

	CLOSE RES_AUDIT_RESTART_RPT.

	INITIALIZE AUDIT_RPT_REC.
	WRITE AUDIT_RPT_REC FROM BLANK_LINE.
	MOVE "PHASE_PROCESSING_BY_RES_NUM was restarted at this point." TO
		AUDIT_RPT_REC.
	WRITE AUDIT_RPT_REC.

	INITIALIZE AUDIT_RPT_REC.
	WRITE AUDIT_RPT_REC FROM FF_LINE.
	
****************************
RESTART_AUDIT_RPT_EXIT.
****************************

/
****************************
RESTART_IMPOUND_RPT.
****************************

	DISPLAY "REBUILDING IMPOUND REPORT...".
              
	OPEN INPUT RES_IMPOUND_RESTART_RPT.
	OPEN OUTPUT RES_IMPOUND_RPT.

	MOVE "YES" TO WS_FIRST_PAGE.

IMPOUND_RPT_LOOP.

	READ RES_IMPOUND_RESTART_RPT
	    AT END
		GO TO FINISH_IMPOUND_RPT
	END-READ.

	MOVE IMPOUND_RESTART_REC TO IMPOUND_RPT_REC.

	WRITE IMPOUND_RPT_REC.

	GO TO IMPOUND_RPT_LOOP.

FINISH_IMPOUND_RPT.

	CLOSE RES_IMPOUND_RESTART_RPT.

	INITIALIZE IMPOUND_RPT_REC.
	WRITE IMPOUND_RPT_REC FROM BLANK_LINE.
	MOVE "PHASE_PROCESSING_BY_RES_NUM was restarted at this point." TO
		IMPOUND_RPT_REC.
	WRITE IMPOUND_RPT_REC.

	INITIALIZE IMPOUND_RPT_REC.
	WRITE IMPOUND_RPT_REC FROM FF_LINE.

	
****************************
RESTART_IMPOUND_RPT_EXIT.
****************************

/
****************************
RESTART_LETTER_FILE.
****************************

	DISPLAY "REBUILDING LETTER DATA FILE...".

	OPEN INPUT LETTER_RESTART_FILE.
	OPEN OUTPUT LETTER_INPUT_FILE.

	READ LETTER_RESTART_FILE
	    AT END                                                          
		SET LETTER_RESTART_EOF TO TRUE.

	MOVE RES_NUM IN LETTER_RESTART_REC TO WS_R_RES_NUM_X.

	PERFORM RESTART_LETTER_LOOP THROUGH RESTART_LETTER_LOOP_EXIT WITH
		TEST BEFORE UNTIL
		(WS_R_RES_NUM  > WS_LAST_RES_NUM IN WS_RESTART_BUFFER) OR
		(LETTER_RESTART_EOF).
                     
	CLOSE LETTER_RESTART_FILE.
                             
	GO TO RESTART_LETTER_FILE_EXIT.

RESTART_LETTER_LOOP.

	MOVE LETTER_RESTART_REC TO LETTER_INPUT_REC.

	WRITE LETTER_INPUT_REC.

	READ LETTER_RESTART_FILE
	    AT END
		SET LETTER_RESTART_EOF TO TRUE
		GO TO RESTART_LETTER_LOOP_EXIT.

	MOVE RES_NUM IN LETTER_RESTART_REC TO WS_R_RES_NUM_X.

RESTART_LETTER_LOOP_EXIT.

****************************
RESTART_LETTER_FILE_EXIT.
****************************

/
****************************
RESTART_REJECT_RPT.
****************************

	DISPLAY "REBUILDING REJECT REPORT...".

	OPEN INPUT RES_REJECT_RESTART_RPT.
	OPEN OUTPUT RES_REJECT_RPT.

	MOVE "YES" TO WS_FIRST_PAGE.
	MOVE ZERO TO WS_READ_CNT.

REJECT_RPT_LOOP.

	READ RES_REJECT_RESTART_RPT
	    AT END
		GO TO FINISH_REJECT_RPT
	END-READ.

	ADD 1 TO WS_READ_CNT.

	MOVE REJ_RESTART_REC TO REJ_RPT_REC.

	WRITE REJ_RPT_REC.

	GO TO REJECT_RPT_LOOP.

FINISH_REJECT_RPT.

	IF WS_READ_CNT = ZERO
		CALL "LIB$DELETE_FILE" USING
			BY DESCRIPTOR RMS-FILENAME OF RES_REJECT_RPT
		   GIVING RETURN_STATUS
		IF RETURN_STATUS < 1
			GO TO HANDLE_ERRORS
		END-IF
		CLOSE RES_REJECT_RPT
		CLOSE RES_REJECT_RESTART_RPT
		GO TO RESTART_REJECT_RPT_EXIT
	END-IF.

	CLOSE RES_REJECT_RESTART_RPT.

	INITIALIZE REJ_RPT_REC.
	WRITE REJ_RPT_REC FROM BLANK_LINE.
	MOVE "PHASE_PROCESSING_BY_RES_NUM was restarted at this point." TO
		REJ_RPT_REC.
	WRITE REJ_RPT_REC.

	INITIALIZE REJ_RPT_REC.
	WRITE REJ_RPT_REC FROM FF_LINE.

        MOVE 0 TO REJ_PAGE_CTR.
        SET REJECT_RPT_OPEN TO TRUE.
        perform WRITE_REJ_HEADER thru WRITE_REJ_HEADER_EXIT.

****************************
RESTART_REJECT_RPT_EXIT.
****************************

/
****************************
RESTART_SUMMARY_RPT.
****************************

	DISPLAY "REBUILDING SUMMARY REPORT...".

	OPEN INPUT SUMMARY_RESTART_RPT.
	OPEN OUTPUT SUMMARY_RPT.

	MOVE "YES" TO WS_FIRST_PAGE.

SUMMARY_RPT_LOOP.

	READ SUMMARY_RESTART_RPT
	    AT END
		GO TO FINISH_SUMMARY_RPT
	END-READ.

	MOVE SUMMARY_RESTART_REC TO SUMMARY_LINE.

	WRITE SUMMARY_LINE.

	GO TO SUMMARY_RPT_LOOP.

FINISH_SUMMARY_RPT.

	CLOSE SUMMARY_RESTART_RPT.

	INITIALIZE SUMMARY_LINE.
	WRITE SUMMARY_LINE FROM BLANK_LINE.
	MOVE "PHASE_PROCESSING_BY_RES_NUM was restarted at this point." TO
		SUMMARY_LINE.
	WRITE SUMMARY_LINE.

	WRITE SUMMARY_LINE FROM FF_LINE.

        ADD 1 TO MAX_SUM_LINE_CTR GIVING SUM_LINE_CTR.

****************************
RESTART_SUMMARY_RPT_EXIT.
****************************

/
****************************
RESTART_SUMMARY_IN_DATA.
****************************

	DISPLAY "REBUILDING SUMMARY DATA FILE...".

	OPEN INPUT SUMMARY_RESTART_IN_FIL.
	OPEN OUTPUT SUMMARY_IN_FIL.

SUMMARY_IN_LOOP.

	READ SUMMARY_RESTART_IN_FIL
	    AT END
		GO TO FINISH_SUMMARY_DATA
	END-READ.

	MOVE SUMMARY_RESTART_IN_REC TO SUMMARY_IN_REC.

	WRITE SUMMARY_IN_REC.

	GO TO SUMMARY_IN_LOOP.

FINISH_SUMMARY_DATA.

	CLOSE SUMMARY_RESTART_IN_FIL.

****************************
RESTART_SUMMARY_IN_DATA_EXIT.
****************************

/
****************************
RESTART_THIS_JOB.
****************************

	DISPLAY " ".
	DISPLAY "PHASE_PROCESSING_BY_RES_NUM job is resuming with parcel "
		TAX_EXT_PARCEL_NUM OF TAX_EXT_MONEY_REC.
	DISPLAY " ".

	PERFORM RESTART_LETTER_FILE THRU RESTART_LETTER_FILE_EXIT.

	PERFORM RESTART_AUDIT_RPT THRU RESTART_AUDIT_RPT_EXIT.

	PERFORM RESTART_IMPOUND_RPT THRU RESTART_IMPOUND_RPT_EXIT.

	PERFORM RESTART_REJECT_RPT THRU RESTART_REJECT_RPT_EXIT.

	PERFORM RESTART_SUMMARY_RPT THRU RESTART_SUMMARY_RPT_EXIT.

	PERFORM RESTART_SUMMARY_IN_DATA THRU RESTART_SUMMARY_IN_DATA_EXIT.

	DISPLAY " ".

RESTART_THIS_JOB_EXIT.
	EXIT.

/
****************************
ROLLBACK_TRAN.
****************************

&RDB& ROLLBACK

      SET TRANS_NOT_ACTIVE TO TRUE.

****************************
ROLLBACK_TRAN_EXIT.	exit.
****************************

/
SEND_MAIL.

	MOVE "PHASE_PROCESSING_BY_RES_NUM" TO ERR_FUNCTION.
        CALL "GET_CURRENT_DATE_TIME" USING GET_CURRENT_DATE_TIME_LKG.
	MOVE DISP_DATE IN GET_CURRENT_DATE_TIME_LKG TO
             ERR_DATE IN ERR_COMMON.
	MOVE DISP_TIME IN GET_CURRENT_DATE_TIME_LKG TO
	     ERR_TIME IN ERR_COMMON.
	CALL "SEND_ERR_MAIL".

SEND_MAIL_EXIT.
	EXIT.

/
****************************
START_TRANS.
****************************

	IF RW_TRANS
&RDB&		START_TRANSACTION ON PROPERTY USING (READ_WRITE)
&RDB&           AND ON NEXTIS USING (READ_WRITE)
&RDB&		   ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS
				GIVING RETURN_STATUS
		      	MOVE "ERROR STARTING TRANSACTION." TO
					ERR_FUNCTION_DETAIL
	   		GO TO RDB_ERROR
&RDB&		   END_ERROR
	ELSE
&RDB&		START_TRANSACTION ON PROPERTY USING (READ_ONLY)
&RDB&           AND ON NEXTIS USING (READ_ONLY)
&RDB&		   ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS
				GIVING RETURN_STATUS
		      	MOVE "ERROR STARTING TRANSACTION." TO
					ERR_FUNCTION_DETAIL
			GO TO RDB_ERROR
&RDB&		   END_ERROR
	END-IF.

	SET TRANS_ACTIVE TO TRUE.

****************************
START_TRANS_EXIT.	exit.
****************************

/
************************
* STORE_MTG_CO_REFUNDS *
************************

STORE_MTG_CO_REFUNDS.
	MOVE "STORE_MTG_CO_REFUNDS" TO ERR_FUNCTION_LOC.
	DISPLAY "START STORE_MTG_CO_REFUNDS".

	SET RW_TRANS TO TRUE.
	PERFORM START_TRANS THRU START_TRANS_EXIT.

	MOVE WS_RES_PHASE_NUM TO PHASE_NUM OF STORE_MTG_CO_REFUNDS_LKG.
	MOVE WS_RES_DATE  TO RES_DATE  OF STORE_MTG_CO_REFUNDS_LKG.
	MOVE WS_TAX_YEAR  TO TAX_YEAR  OF STORE_MTG_CO_REFUNDS_LKG.
	IF WS_TAX_YEAR = CURRENT_YEAR IN GBL_PARAM_VALUES
		SET CTX_PHASE OF STORE_MTG_CO_REFUNDS_LKG TO TRUE
	ELSE
		SET BTX_PHASE OF STORE_MTG_CO_REFUNDS_LKG TO TRUE
	END-IF.
	MOVE "RS " TO RES_CLERK_ID OF STORE_MTG_CO_REFUNDS_LKG.
        MOVE WS_REFUND_SLIP_ID TO SLIP_ID IN STORE_MTG_CO_REFUNDS_LKG.
	CALL "STORE_MTG_CO_REFUNDS" USING STORE_MTG_CO_REFUNDS_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO STORE_MTG_CO_REFUNDS
		END-IF
		MOVE "STORE_MTG_CO_REFUNDS" TO ERR_FUNCTION_LOC
		MOVE "Error from STORE_MTG_CO_REFUNDS" TO ERR_FUNCTION_DETAIL
		GO TO HANDLE_ERRORS
	END-IF.

	perform COMMIT_TRAN thru COMMIT_TRAN_EXIT.

STORE_MTG_CO_REFUNDS_EXIT.
	EXIT.

/
*********************
* STORE_RES_BAL_REC *
*********************

STORE_RES_BAL_REC.
	MOVE "STORE_RES_BAL_REC" TO ERR_FUNCTION_LOC.
	DISPLAY "STARTING STORE_RES_BAL_REC".

	SET RW_TRANS TO TRUE.
	PERFORM START_TRANS THRU START_TRANS_EXIT.

        ADD TOT_RES_AMT OF WRITE_TO_IMPOUND_LKG,
	    TOT_REF_AMT OF WRITE_TO_IMPOUND_LKG
		GIVING WS_TOT_RES_IMPOUND.
        MOVE TOT_LIT_AMT OF WRITE_TO_IMPOUND_LKG TO
             WS_TOT_LIT_IMPOUND.
	MOVE TOT_PREPMT_AMT OF WRITE_TO_IMPOUND_LKG TO
		WS_TOT_PREPMT_IMPOUND.
        MOVE TOT_OVER_UNDER OF WRITE_TO_IMPOUND_LKG TO
                WS_TOT_OVER_UNDER_IMPOUND.
	SUBTRACT WS_TOT_RES_FEE_AMT FROM WS_TOT_REAPPLIED_PMTS
		     GIVING WS_TMP_AMT.

&RDB&   store RB in PROPERTY.RES_BAL USING
&RDB&         on error
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			PERFORM HANDLE_DEADLOCK THRU
				HANDLE_DEADLOCK_EXIT
			GO TO STORE_RES_BAL_REC
		END-IF
                 MOVE "STORE_RES_BAL_REC" TO ERR_FUNCTION_LOC
                 MOVE "Error storing RES_BAL" TO ERR_FUNCTION_DETAIL
                 GO TO RDB_ERROR
&RDB&         end_error
&RDB&      RB.RES_PHASE_NUM    = WS_RES_PHASE_NUM;
&RDB&      RB.RESTORED_AMT     = WS_TOT_RESTORED_PMTS;
&RDB&      RB.PMT_AMT          = WS_TMP_AMT;
&RDB&	   RB.PREPMT_IMPOUND_AMT = WS_TOT_PREPMT_IMPOUND;
&RDB&      RB.RES_IMPOUND_AMT  = WS_TOT_RES_IMPOUND;
&RDB&      RB.LIT_IMPOUND_AMT  = WS_TOT_LIT_IMPOUND;
&RDB&      RB.RES_INTEREST_AMT = WS_TOT_RES_INTEREST;
&RDB&      RB.BTX_CTX_FLG      = WS_BTX_CTX_FLG;
&RDB&	   RB.FEES_PMT_AMT     = WS_TOT_RES_FEE_AMT;
&RDB&	   RB.OVER_UNDER_IMPOUND_AMT = WS_TOT_OVER_UNDER_IMPOUND
&RDB&   end_store

	perform COMMIT_TRAN thru COMMIT_TRAN_EXIT.

        open output RES_CSH_TOTALS_RPT.

        write CSH_TOTALS_RPT_REC from CSH_HEADER_1.
	write CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_HEADER_2.
	write CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_HEADER_3.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET CTX_FLG OF CSH_DETAIL_LINE TO TRUE.
        IF WS_BTX_CTX_FLG = "C"
		MOVE WS_TMP_AMT TO TRANS_AMT OF CSH_DETAIL_LINE
        ELSE
		MOVE 0 TO TRANS_AMT OF CSH_DETAIL_LINE
        END-IF.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET BTX_FLG OF CSH_DETAIL_LINE TO TRUE.
        IF WS_BTX_CTX_FLG = "B"
		MOVE WS_TMP_AMT TO TRANS_AMT OF CSH_DETAIL_LINE
        ELSE
		MOVE 0 TO TRANS_AMT OF CSH_DETAIL_LINE
        END-IF.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET RES_FEE OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_RES_FEE_AMT TO TRANS_AMT OF CSH_DETAIL_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET PREPMT_IMP OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_PREPMT_IMPOUND TO TRANS_AMT OF CSH_DETAIL_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET RES_IMP OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_RES_IMPOUND TO TRANS_AMT OF CSH_DETAIL_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET LIT_IMP OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_LIT_IMPOUND TO TRANS_AMT OF CSH_DETAIL_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET OVER_UNDER_IMP OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_OVER_UNDER_IMPOUND TO TRANS_AMT OF CSH_DETAIL_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET RES_CTR OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_CTR_NUM TO CTR_NUM OF CSH_DETAIL_LINE.

        ADD WS_TOT_RESTORED_PMTS TO WS_TOT_RES_INTEREST GIVING
            TRANS_AMT OF CSH_DETAIL_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

	MOVE SPACES TO CSH_DETAIL_LINE.
	SET RESTORE_TOT OF CSH_DETAIL_LINE TO TRUE.
	MOVE WS_TOT_RESTORED_PMTS TO TRANS_AMT OF CSH_DETAIL_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET RES_INT OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_RES_INTEREST TO TRANS_AMT OF CSH_DETAIL_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
	WRITE CSH_TOTALS_RPT_REC FROM BLANK_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET RES_CAN OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_CANCELLED_TAX TO TRANS_AMT OF CSH_DETAIL_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        MOVE spaces TO CSH_DETAIL_LINE.
        SET RES_NEW OF CSH_DETAIL_LINE TO TRUE.
        MOVE WS_TOT_NEW_TAX TO TRANS_AMT OF CSH_DETAIL_LINE.
        write CSH_TOTALS_RPT_REC from CSH_DETAIL_LINE.

        close RES_CSH_TOTALS_RPT.

STORE_RES_BAL_REC_EXIT.
	EXIT.

/
********************
UPDATE_BTX_CP_CODES.
********************

     IF EDIT_MODE_RUN THEN GO TO UPDATE_BTX_CP_CODES_EXIT.

     IF WS_SKIP_THIS_PARCEL = "YES" THEN GO TO UPDATE_BTX_CP_CODES_EXIT.

     MOVE CURRENT_YEAR IN GBL_PARAM_VALUES TO
	  CURR_YEAR in DETERMINE_BTX_CP_CODE_LKG.
     MOVE PARCEL_BOOK_MAP_ITEM in GET_PARCEL_LKG TO
          PARCEL_BOOK_MAP_ITEM in DETERMINE_BTX_CP_CODE_LKG.
     MOVE PARCEL_SPLIT in GET_PARCEL_LKG TO
          PARCEL_SPLIT in DETERMINE_BTX_CP_CODE_LKG.
     MOVE TAX_YEAR in GET_PARCEL_LKG TO
          TAX_YEAR in DETERMINE_BTX_CP_CODE_LKG.
     CALL "DETERMINE_BTX_CP_CODE" USING DETERMINE_BTX_CP_CODE_LKG
        GIVING RETURN_STATUS.
     IF RETURN_STATUS < 1
        STRING "Error from DETERMINE_BTX_CP_CODE - " delimited by size
		PARCEL_NUM OF DETERMINE_BTX_CP_CODE_LKG delimited by size
			inTO ERR_FUNCTION_DETAIL
        MOVE "UPDATE_BTX_CP_CODES" TO ERR_FUNCTION_LOC
        go TO HANDLE_ERRORS
     END-IF.
     MOVE BTX_CP_CODE in DETERMINE_BTX_CP_CODE_LKG TO
          BTX_CP_CODE in GET_PARCEL_LKG.
     perform UPDATE_PARCEL_MASTER thru UPDATE_PARCEL_MASTER_EXIT.
                    
     IF TAX_YEAR IN GET_PARCEL_LKG = CURRENT_YEAR IN GBL_PARAM_VALUES
           go TO UPDATE_BTX_CP_CODES_EXIT
     END-IF.

&RDB&   FOR P IN PROPERTY.PARCEL_MASTER WITH
&RDB&        P.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG
&RDB&    AND P.PARCEL_SPLIT = PARCEL_SPLIT IN GET_PARCEL_LKG
&RDB&    AND P.TAX_YEAR = CURRENT_YEAR IN GBL_PARAM_VALUES
&RDB&    AND P.PARCEL_SEQ_NUM = "0"
&RDB&      on error
                 STRING "Error with FOR stmt on PARCEL_MASTER - " delimited
			by size PARCEL_NUM OF GET_PARCEL_LKG delimited 
			by size inTO ERR_FUNCTION_DETAIL
                 MOVE "UPDATE_BTX_CP_CODES" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&      END_error
              
&RDB&    MODIFY P USING
&RDB&      on error     
                 STRING "Error with MODIFY stmt on PARCEL_MASTER" delimited
			by size PARCEL_NUM OF GET_PARCEL_LKG delimited by
			size inTO ERR_FUNCTION_DETAIL
                 MOVE "UPDATE_BTX_CP_CODES" TO ERR_FUNCTION_LOC
                 GO TO RDB_ERROR
&RDB&      END_error
&RDB&     P.BTX_CP_CODE = CURR_YEAR_BTX_CP_CODE in DETERMINE_BTX_CP_CODE_LKG
&RDB&    END_MODIFY

&RDB&   END_FOR.

UPDATE_BTX_CP_CODES_EXIT.
	EXIT.

/
************************
* UPDATE_PARCEL_MASTER *
************************

UPDATE_PARCEL_MASTER.
	MOVE "UPDATE_PARCEL_MASTER" TO ERR_FUNCTION_LOC.

	CALL "MOD_PARCEL" USING GET_PARCEL_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		IF RDB_DEADLOCK
			GO TO UPDATE_PARCEL_MASTER_EXIT
		END-IF
		STRING
			"Error modifying PARCEL_MASTER record - " delimited by size
			WS_CURR_PARCEL_NUM delimited by size
		    INTO ERR_FUNCTION_DETAIL
		MOVE "UPDATE_PARCEL_MASTER" TO ERR_FUNCTION_LOC
		GO TO HANDLE_ERRORS
	END-IF.

UPDATE_PARCEL_MASTER_EXIT.
	EXIT.

/
****************************
UPDATE_RESOLUTION_REC.
****************************

     IF WS_SKIP_THIS_PARCEL = "YES" THEN GO TO UPDATE_RESOLUTION_REC_EXIT.

     MOVE GET_RESOLUTIONS_REC_LKG          TO MOD_RESOLUTIONS_REC_LKG.
     MOVE WS_RES_DATE TO RES_PEND_FLG_DATE OF MOD_RESOLUTIONS_REC_LKG.
     MOVE "C" TO RES_CODE OF MOD_RESOLUTIONS_REC_LKG.
     CALL "MOD_RESOLUTIONS_REC" USING MOD_RESOLUTIONS_REC_LKG GIVING RETURN_STATUS.
     IF RETURN_STATUS < 1
        MOVE "Error ModIFying RESOLUTIONS_REC" TO ERR_FUNCTION_DETAIL
        MOVE "UPDATE_RESOLUTION_REC" TO ERR_FUNCTION_LOC
        GO TO HANDLE_ERRORS
     END-IF.

****************************
UPDATE_RESOLUTION_REC_EXIT.	exit.
****************************

/
********************
* WRITE_REJ_HEADER *
********************

WRITE_REJ_HEADER.
	MOVE "WRITE_REJ_HEADER" TO ERR_FUNCTION_LOC.

	MOVE 0 TO REJ_CTR.
	ADD 1 TO REJ_PAGE_CTR.

	IF REJ_PAGE_CTR > 1 THEN
		WRITE REJ_RPT_REC FROM FF_LINE
	END-IF.
	WRITE REJ_RPT_REC FROM REJ_HEADER_1.

	MOVE REJ_PAGE_CTR TO PAGE_NUM OF REJ_HEADER_2.
	WRITE REJ_RPT_REC FROM BLANK_LINE.
	WRITE REJ_RPT_REC FROM REJ_HEADER_2.

	WRITE REJ_RPT_REC FROM BLANK_LINE.
	WRITE REJ_RPT_REC FROM REJ_HEADER_3.

WRITE_REJ_HEADER_EXIT.
	EXIT.

/
********************
* WRITE_REJECT_RPT *
********************

WRITE_REJECT_RPT.

* THIS CODE NEEDS TO BE CHECKED OUT.
* PROBLEMS WITH THE POST_NEW_TAX_LKG.

	MOVE "WRITE_REJECT_RPT" TO ERR_FUNCTION_LOC.

	IF REJECT_RPT_NOT_OPEN
		OPEN OUTPUT RES_REJECT_RPT
		SET REJECT_RPT_OPEN TO TRUE
		MOVE 0 TO REJ_PAGE_CTR
		PERFORM WRITE_REJ_HEADER THRU WRITE_REJ_HEADER_EXIT
	END-IF.

	IF REJ_CTR > MAX_REJ_CTR
		PERFORM WRITE_REJ_HEADER THRU WRITE_REJ_HEADER_EXIT
	END-IF.

	ADD 1 TO REJ_CTR.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_1H1.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_1H2.

	MOVE "-" TO DASH1 OF REJ_RPT_LINE_1, DASH2 OF REJ_RPT_LINE_1.
	MOVE PARCEL_BOOK_MAP_ITEM OF GET_PARCEL_LKG TO WS_BOOK_MAP_ITEM.
	MOVE WS_PARCEL_BOOK TO
		PARCEL_BOOK          OF REJ_RPT_LINE_1.
	MOVE WS_PARCEL_MAP  TO
		PARCEL_MAP           OF REJ_RPT_LINE_1.
	MOVE WS_PARCEL_ITEM TO
		PARCEL_ITEM          OF REJ_RPT_LINE_1.
	MOVE PARCEL_SPLIT         OF GET_PARCEL_LKG TO
		PARCEL_SPLIT         OF REJ_RPT_LINE_1.
	MOVE TAX_YEAR             OF GET_PARCEL_LKG TO
		TAX_YEAR             OF REJ_RPT_LINE_1.
	MOVE AREA_CODE            OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG TO
		AREA_CODE            OF REJ_RPT_LINE_1.
	MOVE LAND_CLASS_CODE      OF POST_NEW_TAX_LKG TO
		LAND_CLASS_CODE      OF REJ_RPT_LINE_1.
	MOVE IMPROVE_CLASS_CODE   OF POST_NEW_TAX_LKG TO
		IMPROVE_CLASS_CODE   OF REJ_RPT_LINE_1.
	MOVE RESID_PCT            OF LAND_IMPROVE_VALUE_REC 
                                  OF POST_NEW_TAX_LKG TO RESID_PCT            OF REJ_RPT_LINE_1.
	MOVE AC_PRIMARY_TAX       OF POST_NEW_TAX_LKG TO
		PRIMARY_TAX          OF REJ_RPT_LINE_1.
	MOVE AC_SECONDARY_TAX     OF POST_NEW_TAX_LKG TO
		OTHER_TAX            OF REJ_RPT_LINE_1.
	MOVE FLOOD_TAX            OF POST_NEW_TAX_LKG TO
		FLOOD_TAX            OF REJ_RPT_LINE_1.
	MOVE THE_REJECT_REASON TO
		 REJ_RPT_REASON   OF REJ_RPT_LINE_1.
	MOVE SPACES TO THE_REJECT_REASON.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_1.

	WRITE REJ_RPT_REC FROM BLANK_LINE.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_2H1.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_2H2.

	MOVE SPACES TO REJ_RPT_LINE_2.
	SET LAND_TYPE OF REJ_RPT_LINE_2 TO TRUE.
	MOVE PRIMARY_LAND_FCV             OF POST_NEW_TAX_LKG TO
		PRI_FCV                      OF REJ_RPT_LINE_2.
	MOVE PRIMARY_LAND_RATIO           OF POST_NEW_TAX_LKG TO
		PRI_RATIO                    OF REJ_RPT_LINE_2.
	MOVE PRIMARY_LAND_ASSD_VALUE      OF POST_NEW_TAX_LKG TO
		PRI_ASSD_VALUE               OF REJ_RPT_LINE_2.
	MOVE PRIMARY_WID_VET_EXEMPT_AMT   OF LAND_IMPROVE_VALUE_REC
						OF POST_NEW_TAX_LKG TO
		PRI_EXEMPT_AMT               OF REJ_RPT_LINE_2.

	MOVE SECONDARY_LAND_FCV           OF POST_NEW_TAX_LKG TO
		SEC_FCV                      OF REJ_RPT_LINE_2.
	MOVE SECONDARY_LAND_RATIO         OF POST_NEW_TAX_LKG TO
		SEC_RATIO                    OF REJ_RPT_LINE_2.
	MOVE SECONDARY_LAND_ASSD_VALUE    OF POST_NEW_TAX_LKG TO
		SEC_ASSD_VALUE               OF REJ_RPT_LINE_2.
	MOVE SECONDARY_WID_VET_EXEMPT_AMT OF LAND_IMPROVE_VALUE_REC
						OF POST_NEW_TAX_LKG TO
		SEC_EXEMPT_AMT               OF REJ_RPT_LINE_2.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_2.

	MOVE SPACES TO REJ_RPT_LINE_2.
	SET IMPROVE_TYPE OF REJ_RPT_LINE_2 TO TRUE.
	MOVE PRIMARY_IMPROVE_FCV           OF POST_NEW_TAX_LKG TO
		PRI_FCV                       OF REJ_RPT_LINE_2.
	MOVE PRIMARY_IMPROVE_RATIO         OF POST_NEW_TAX_LKG TO
		PRI_RATIO                     OF REJ_RPT_LINE_2.
	MOVE PRIMARY_IMPROVE_ASSD_VALUE    OF POST_NEW_TAX_LKG TO
		PRI_ASSD_VALUE                OF REJ_RPT_LINE_2.

	MOVE SECONDARY_IMPROVE_FCV         OF POST_NEW_TAX_LKG TO
		SEC_FCV                       OF REJ_RPT_LINE_2.
	MOVE SECONDARY_IMPROVE_RATIO       OF POST_NEW_TAX_LKG TO
		SEC_RATIO                     OF REJ_RPT_LINE_2.
	MOVE SECONDARY_IMPROVE_ASSD_VALUE  OF POST_NEW_TAX_LKG TO
		SEC_ASSD_VALUE                OF REJ_RPT_LINE_2.
	WRITE REJ_RPT_REC FROM REJ_RPT_LINE_2.

	MOVE spaces TO REJ_RPT_LINE_2.
	SET PERS_PROP_TYPE OF REJ_RPT_LINE_2 TO TRUE.
*	MOVE PRIMARY_ASSESSED_FCV          OF LAND_IMPROVE_VALUE_REC 
*                                           OF POST_NEW_TAX_LKG TO PRI_FCV                       OF REJ_RPT_LINE_2.
*	MOVE PRIMARY_ASSESSED_VALUE        OF LAND_IMPROVE_VALUE_REC
*                                           OF POST_NEW_TAX_LKG TO PRI_ASSD_VALUE                OF REJ_RPT_LINE_2.
*	MOVE PRIMARY_WID_VET_EXEMPT_AMT    OF PERSONAL_PROPERTY_REC
*						OF POST_NEW_TAX_LKG TO
*		PRI_EXEMPT_AMT                OF REJ_RPT_LINE_2.
*
*	MOVE SECONDARY_ASSESSED_FCV        OF POST_NEW_TAX_LKG TO
*		SEC_FCV                       OF REJ_RPT_LINE_2.
*	MOVE SECONDARY_ASSESSED_VALUE      OF POST_NEW_TAX_LKG TO
*		SEC_ASSD_VALUE                OF REJ_RPT_LINE_2.
*	MOVE SECONDARY_WID_VET_EXEMPT_AMT  OF PERSONAL_PROPERTY_REC
*                                           OF POST_NEW_TAX_LKG TO
*		SEC_EXEMPT_AMT                OF REJ_RPT_LINE_2.
	write REJ_RPT_REC from REJ_RPT_LINE_2.

	WRITE REJ_RPT_REC FROM BLANK_LINE.
	write REJ_RPT_REC from REJ_RPT_LINE_3H1.
	write REJ_RPT_REC from REJ_RPT_LINE_3H2.

	MOVE spaces TO REJ_RPT_LINE_3.
	MOVE 1 TO SD_IX.
	MOVE 1 TO REJ_SD_IX.
	perform with test before until
			(SD_IX > WS_MAX_NUM_SD) or 
			(DIST OF SPEC_DIST_TABLE OF POST_NEW_TAX_LKG(SD_IX) = spaces)
		IF REJ_SD_IX > MAX_REJ_SD_VALUE
			write REJ_RPT_REC from REJ_RPT_LINE_3
			MOVE 1 TO REJ_SD_IX
		END-IF
		MOVE DIST OF SPEC_DIST_TABLE OF POST_NEW_TAX_LKG(SD_IX) TO
		     DIST OF REJ_RPT_LINE_3(SD_IX)
		MOVE ASSR_ACRES_VALUE OF POST_NEW_TAX_LKG(SD_IX) TO
		     ASSR_ACRES_VALUE OF REJ_RPT_LINE_3(SD_IX)
		MOVE ASSR_ACRES_FLG   OF POST_NEW_TAX_LKG(SD_IX) TO
		     ASSR_ACRES_FLG   OF REJ_RPT_LINE_3(SD_IX)
		MOVE SPEC_DIST_TAX_AMT OF POST_NEW_TAX_LKG(SD_IX) TO
		     SPEC_DIST_TAX_AMT OF REJ_RPT_LINE_3(SD_IX)
		ADD 1 TO SD_IX
		ADD 1 TO REJ_SD_IX
	END-perform.
	write REJ_RPT_REC from REJ_RPT_LINE_3.

WRITE_REJECT_RPT_EXIT.
	EXIT.

/
***************************
* WRITE_SUMMARY_BY_PARCEL *
***************************

WRITE_SUMMARY_BY_PARCEL.
	MOVE "WRITE_SUMMARY_BY_PARCEL" TO ERR_FUNCTION_LOC.

	OPEN INPUT SUMMARY_OUT_FIL.
	OPEN OUTPUT SUMMARY_PARCEL_RPT.

	MOVE ZERO TO SUM_PAGE_CTR.
	PERFORM WRITE_SUMMARY_PARCEL_HEADER THRU
		WRITE_SUMMARY_PARCEL_HDR_EXIT.

WRITE_SUMMARY_LOOP.
	MOVE "WRITE_SUMMARY_LOOP" TO ERR_FUNCTION_LOC.

	READ SUMMARY_OUT_FIL
		AT END GO TO WRITE_SUMMARY_LOOP_END.

	ADD 1 TO SUM_LINE_CTR.
	IF SUM_LINE_CTR > MAX_SUM_LINE_CTR
		perform WRITE_SUMMARY_PARCEL_HEADER thru
			WRITE_SUMMARY_PARCEL_HDR_EXIT
	END-IF.

	MOVE SUMMARY_RPT_DETAIL IN SUMMARY_OUT_REC TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	GO TO WRITE_SUMMARY_LOOP.

WRITE_SUMMARY_LOOP_END.
	MOVE "WRITE_SUMMARY_LOOP_END" TO ERR_FUNCTION_LOC.

	CLOSE SUMMARY_OUT_FIL.
	CLOSE SUMMARY_PARCEL_RPT.

WRITE_SUMMARY_BY_PARCEL_EXIT.
	EXIT.

/
*******************************
* WRITE_SUMMARY_PARCEL_HEADER *
*******************************

WRITE_SUMMARY_PARCEL_HEADER.
	MOVE "WRITE_SUMMARY_PARCEL_HEADER" TO ERR_FUNCTION_LOC.

	ADD 1 TO SUM_PAGE_CTR.

	IF SUM_PAGE_CTR > 1 THEN
		WRITE SUMMARY_PARCEL_LINE FROM FF_LINE
	END-IF.
	MOVE SUM_HEADER_1 TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	MOVE SUM_PAGE_CTR TO PAGE_NUM OF SUM_HEADER_2.
	WRITE SUMMARY_PARCEL_LINE FROM BLANK_LINE.
	MOVE SUM_HEADER_2 TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	WRITE SUMMARY_PARCEL_LINE FROM BLANK_LINE.
	MOVE SUM_PARCEL_HEADER_3 TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	WRITE SUMMARY_PARCEL_LINE FROM BLANK_LINE.
	WRITE SUMMARY_PARCEL_LINE FROM BLANK_LINE.
	MOVE SUM_HEADER_4 TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	MOVE SUM_HEADER_5 TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	MOVE SUM_HEADER_6 TO SUMMARY_PARCEL_LINE.
	write SUMMARY_PARCEL_LINE.

	MOVE 10 TO SUM_LINE_CTR.

WRITE_SUMMARY_PARCEL_HDR_EXIT.
	EXIT.

/
****************************
* WRITE_SUMMARY_RPT_HEADER *
****************************

WRITE_SUMMARY_RPT_HEADER.
	MOVE "WRITE_SUMMARY_RPT_HEADER" TO ERR_FUNCTION_LOC.

	ADD 1 TO SUM_PAGE_CTR.

	IF SUM_PAGE_CTR > 1 THEN
		WRITE SUMMARY_LINE FROM FF_LINE
	END-IF.
	MOVE SUM_HEADER_1 TO SUMMARY_LINE.
	write SUMMARY_LINE.

	MOVE SUM_PAGE_CTR TO PAGE_NUM OF SUM_HEADER_2.
	WRITE SUMMARY_LINE FROM BLANK_LINE.
	MOVE SUM_HEADER_2 TO SUMMARY_LINE.
	write SUMMARY_LINE.

	WRITE SUMMARY_LINE FROM BLANK_LINE.
	MOVE SUM_HEADER_3 TO SUMMARY_LINE.
	write SUMMARY_LINE.

	WRITE SUMMARY_LINE FROM BLANK_LINE.
	WRITE SUMMARY_LINE FROM BLANK_LINE.
	MOVE SUM_HEADER_4 TO SUMMARY_LINE.
	write SUMMARY_LINE.

	MOVE SUM_HEADER_5 TO SUMMARY_LINE.
	write SUMMARY_LINE.

	MOVE SUM_HEADER_6 TO SUMMARY_LINE.
	write SUMMARY_LINE.

	MOVE 10 TO SUM_LINE_CTR.

WRITE_SUMMARY_RPT_HEADER_EXIT.
	EXIT.

/
********************************
* WRITE_SUMMARY_RPT_LINE *
********************************

WRITE_SUMMARY_RPT_LINE.
	MOVE "WRITE_SUMMARY_RPT_LINE" TO ERR_FUNCTION_LOC.

	IF WS_SKIP_THIS_PARCEL = "YES"
		GO TO WRITE_SUMMARY_RPT_LINE_EXIT
	END-IF.

	ADD 1 TO SUM_LINE_CTR.
	IF SUM_LINE_CTR > MAX_SUM_LINE_CTR
		perform WRITE_SUMMARY_RPT_HEADER thru
			WRITE_SUMMARY_RPT_HEADER_EXIT
	END-IF.

	ADD RESTORED_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_TOT_RESTORED_PMTS, WS_RES_NUM_RESTORE_AMT.

	ADD REAPPLY_FEE_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_TOT_RES_FEE_AMT.

	ADD PREV_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_TOT_CANCELLED_TAX.
	ADD REAPPLY_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_TOT_REAPPLIED_PMTS, WS_RES_NUM_REAPPLY_AMT.
	ADD RES_INT_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_TOT_RES_INTEREST, WS_RES_NUM_RESTORE_AMT.
	ADD NEW_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_TOT_NEW_TAX.

	ADD IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		WS_RES_NUM_REAPPLY_AMT.

	MOVE spaces TO SUMMARY_RPT_LINE.
	MOVE "-" TO DASH1 OF SUMMARY_RPT_LINE, DASH2 OF SUMMARY_RPT_LINE.
	MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)(1:3) TO
		BOOK     OF SUMMARY_RPT_LINE.
	MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)(4:2) TO
		MAP      OF SUMMARY_RPT_LINE.
	MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)(6:3) TO
		ITEM     OF SUMMARY_RPT_LINE.
	MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		SPLIT    OF SUMMARY_RPT_LINE.
	MOVE WS_TAX_YEAR                            TO TAX_YEAR OF SUMMARY_RPT_LINE.
	MOVE WS_CURR_RES_NUM                             TO RES_NUM  OF SUMMARY_RPT_LINE.
	MOVE RES_REASON IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		REASON_CODE IN SUMMARY_RPT_LINE.
	MOVE PREV_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		CANCELED_TAX OF SUMMARY_RPT_LINE.
	MOVE NEW_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		NEW_TAX OF SUMMARY_RPT_LINE.

	IF NEW_ASSESSED_TAX IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) = ZRO
		ADD RESTORED_TAX_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX),
		    RESTORED_INT_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
			GIVING RESTORED_PMTS OF SUMMARY_RPT_LINE
	ELSE
		MOVE RESTORED_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			RESTORED_PMTS  OF SUMMARY_RPT_LINE
	END-IF.

	MOVE REAPPLY_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		REAPPLIED_PMTS OF SUMMARY_RPT_LINE.
	MOVE RES_INT_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		RES_INTEREST   OF SUMMARY_RPT_LINE.

	EVALUATE TRUE
	    WHEN UNDER_PAYMENT_RESULT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
		MOVE AMT_DUE IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PMT_DIFF OF SUMMARY_RPT_LINE
		SET UNDER_PAYMENT_RESULT OF SUMMARY_RPT_LINE TO TRUE
	    WHEN REFUND_RESULT OF RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
		MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_BMI           OF WRITE_TO_IMPOUND_LKG
		MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_SPLIT         OF WRITE_TO_IMPOUND_LKG
		MOVE WS_TAX_YEAR TO
			TAX_YEAR             OF WRITE_TO_IMPOUND_LKG
		MOVE WS_CURR_RES_NUM TO
			RES_NUM              OF WRITE_TO_IMPOUND_LKG
		MOVE RES_REASON	IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			RES_REASON IN WRITE_TO_IMPOUND_LKG
		MOVE WS_RES_PHASE_NUM TO
			PHASE_NUM            OF WRITE_TO_IMPOUND_LKG
		MOVE IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PMT_DIFF OF SUMMARY_RPT_LINE,
			IMPOUND_AMT OF WRITE_TO_IMPOUND_LKG
		SET REFUND_RESULT OF SUMMARY_RPT_LINE TO TRUE
		SET REF_IMPOUND_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE
		CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
			GIVING RETURN_STATUS
	    WHEN LIT_IMPOUND_RESULT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
		MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_BMI           OF WRITE_TO_IMPOUND_LKG
		MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_SPLIT         OF WRITE_TO_IMPOUND_LKG
		MOVE WS_TAX_YEAR TO
			TAX_YEAR             OF WRITE_TO_IMPOUND_LKG
		MOVE WS_CURR_RES_NUM TO
			RES_NUM              OF WRITE_TO_IMPOUND_LKG
		MOVE RES_REASON	IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			RES_REASON IN WRITE_TO_IMPOUND_LKG
		MOVE WS_RES_PHASE_NUM TO
			PHASE_NUM            OF WRITE_TO_IMPOUND_LKG
		MOVE IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PMT_DIFF OF SUMMARY_RPT_LINE,
			IMPOUND_AMT OF WRITE_TO_IMPOUND_LKG
		SET LIT_IMPOUND_RESULT OF SUMMARY_RPT_LINE TO TRUE
		SET LIT_IMPOUND_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE
		CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
			GIVING RETURN_STATUS
	    WHEN NO_EFFECT_RESULT OF RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
		SET NO_EFFECT_RESULT OF SUMMARY_RPT_LINE TO TRUE
            WHEN OVER_UNDER_RESULT OF RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
		MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_BMI           OF WRITE_TO_IMPOUND_LKG
		MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_SPLIT         OF WRITE_TO_IMPOUND_LKG
		MOVE WS_TAX_YEAR TO
			TAX_YEAR             OF WRITE_TO_IMPOUND_LKG
		MOVE WS_CURR_RES_NUM TO
			RES_NUM              OF WRITE_TO_IMPOUND_LKG
		MOVE RES_REASON	IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			RES_REASON IN WRITE_TO_IMPOUND_LKG
		MOVE WS_RES_PHASE_NUM TO
			PHASE_NUM            OF WRITE_TO_IMPOUND_LKG
		MOVE IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PMT_DIFF OF SUMMARY_RPT_LINE,
			IMPOUND_AMT OF WRITE_TO_IMPOUND_LKG
                SET OVER_UNDER_RESULT OF SUMMARY_RPT_LINE TO TRUE
		SET OVER_UNDER_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE
		CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
			GIVING RETURN_STATUS
	    WHEN PREPMT_RESULT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX)
		MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_BMI           OF WRITE_TO_IMPOUND_LKG
		MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_SPLIT         OF WRITE_TO_IMPOUND_LKG
		MOVE WS_TAX_YEAR TO
			TAX_YEAR             OF WRITE_TO_IMPOUND_LKG
		MOVE WS_CURR_RES_NUM TO
			RES_NUM              OF WRITE_TO_IMPOUND_LKG
		MOVE RES_REASON	IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			RES_REASON IN WRITE_TO_IMPOUND_LKG
		MOVE WS_RES_PHASE_NUM TO
			PHASE_NUM            OF WRITE_TO_IMPOUND_LKG
		MOVE IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PMT_DIFF OF SUMMARY_RPT_LINE,
			IMPOUND_AMT OF WRITE_TO_IMPOUND_LKG
		SET PREPMT_IMPOUND_RESULT OF SUMMARY_RPT_LINE TO TRUE
		SET PREPMT_IMPOUND_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE
		CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
			GIVING RETURN_STATUS
	    WHEN OTHER
		MOVE PARCEL_BMI IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_BMI           OF WRITE_TO_IMPOUND_LKG
		MOVE PARCEL_SPLIT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PARCEL_SPLIT         OF WRITE_TO_IMPOUND_LKG
		MOVE WS_TAX_YEAR TO
			TAX_YEAR             OF WRITE_TO_IMPOUND_LKG
		MOVE WS_CURR_RES_NUM TO
			RES_NUM              OF WRITE_TO_IMPOUND_LKG
		MOVE RES_REASON	IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			RES_REASON IN WRITE_TO_IMPOUND_LKG
		MOVE WS_RES_PHASE_NUM TO
			PHASE_NUM            OF WRITE_TO_IMPOUND_LKG
		MOVE IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
			PMT_DIFF OF SUMMARY_RPT_LINE,
			IMPOUND_AMT OF WRITE_TO_IMPOUND_LKG
		SET RES_IMPOUND_RESULT OF SUMMARY_RPT_LINE TO TRUE
		SET RES_IMPOUND_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE
		CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
			GIVING RETURN_STATUS
	END-EVALUATE.

	write SUMMARY_LINE from SUMMARY_RPT_LINE.

	INITIALIZE SUMMARY_IN_REC.
	MOVE PARCEL_NUM IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
		PARCEL_NUM IN SUMMARY_IN_REC.
	MOVE SUMMARY_RPT_LINE TO SUMMARY_RPT_DETAIL IN SUMMARY_IN_REC.
	WRITE SUMMARY_IN_REC.

WRITE_SUMMARY_RPT_LINE_EXIT.
	EXIT.



/
****************
* WRITE_TOTALS *
****************

WRITE_TOTALS.
	MOVE "WRITE_TOTALS" TO ERR_FUNCTION_LOC.

	SET TOTALS_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE.
	CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		MOVE "WRITE_TOTALS" TO ERR_FUNCTION_LOC
		MOVE "Error from WRITE_TO_IMPOUND (Report)" TO
			ERR_FUNCTION_DETAIL
		GO TO HANDLE_ERRORS
	END-IF.

	SET COUNTERS_TYPE OF WRITE_TO_IMPOUND_LKG TO TRUE.
	CALL "WRITE_TO_IMPOUND" USING WRITE_TO_IMPOUND_LKG
              GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		MOVE "WRITE_TOTALS" TO ERR_FUNCTION_LOC
		MOVE "ERROR FROM WRITE_TO_IMPOUND (COUNTERS)" TO
			ERR_FUNCTION_DETAIL
		GO TO HANDLE_ERRORS
	END-IF.

	IF SUM_LINE_CTR > MAX_SUM_LINE_CTR
		perform WRITE_SUMMARY_RPT_HEADER thru
			WRITE_SUMMARY_RPT_HEADER_EXIT
	END-IF.
	write SUMMARY_LINE from SUMMARY_DASHES.

	INITIALIZE SUMMARY_IN_REC.
	MOVE "99999999Y" TO PARCEL_NUM IN SUMMARY_IN_REC.
	MOVE SUMMARY_DASHES TO SUMMARY_RPT_DETAIL IN SUMMARY_IN_REC.
	WRITE SUMMARY_IN_REC.

	IF SUM_LINE_CTR > MAX_SUM_LINE_CTR
		perform WRITE_SUMMARY_RPT_HEADER thru
			WRITE_SUMMARY_RPT_HEADER_EXIT
	END-IF.
	MOVE WS_TOT_CANCELLED_TAX  TO TOT_CAN_TAX   OF SUMMARY_TOTAL_LINE.
	MOVE WS_TOT_NEW_TAX        TO TOT_NEW_TAX   OF SUMMARY_TOTAL_LINE.
	MOVE WS_TOT_RESTORED_PMTS  TO TOT_REST_PMTS OF SUMMARY_TOTAL_LINE.
	MOVE WS_TOT_REAPPLIED_PMTS TO TOT_REAP_PMTS OF SUMMARY_TOTAL_LINE.
	MOVE WS_TOT_RES_INTEREST   TO TOT_RES_INT   OF SUMMARY_TOTAL_LINE.
	write SUMMARY_LINE from SUMMARY_TOTAL_LINE.

	INITIALIZE SUMMARY_IN_REC.
	MOVE "99999999Z" TO PARCEL_NUM IN SUMMARY_IN_REC.
	MOVE SUMMARY_TOTAL_LINE TO SUMMARY_RPT_DETAIL IN SUMMARY_IN_REC.
	WRITE SUMMARY_IN_REC.

	MOVE WS_PARCELS_PROCESSED TO TOTS_PARCELS.
	WRITE SUMMARY_LINE FROM SUMMARY_PCOUNT_LINE.
	INITIALIZE SUMMARY_IN_REC.
	MOVE "99999999Z" TO PARCEL_NUM IN SUMMARY_IN_REC.
	MOVE SUMMARY_PCOUNT_LINE TO SUMMARY_RPT_DETAIL IN SUMMARY_IN_REC.
	WRITE SUMMARY_IN_REC.	

&RDB& store X in PROPERTY.RES_QUEUE USING
&RDB&         on error
                 MOVE "WRITE_TOTALS" TO ERR_FUNCTION_LOC
                 MOVE "Error storing RES_QUEUE" TO ERR_FUNCTION_DETAIL
                 GO TO RDB_ERROR
&RDB&         END_error
&RDB&    X.SUBSYSTEM_CODE = "0";
&RDB&    X.STATUS_CODE    = "0";
&RDB&    X.STATUS_DATE    = WS_RES_DATE;
&RDB&    X.RES_PHASE_NUM  = WS_RES_PHASE_NUM;
&RDB&    X.CLERK_ID       = "RS"
&RDB& END_store.

WRITE_TOTALS_EXIT.
	EXIT.

/
***************
* ZERO_FIELDS *
***************

ZERO_FIELDS.

*
*  Initializing Data
*

        initialize RESTORE_PMTS_LKG, CANCEL_TAX_LKG,
                   POST_NEW_TAX_LKG, REAPPLY_PMTS_LKG, GET_CP_LKG.
        MOVE spaces TO WS_RESTORE_PMTS_ERROR, WS_CANCEL_TAX_ERROR.
        MOVE 0.00   TO WS_ASSESSED_TAX_CANCELED.

ZERO_FIELDS_EXIT.
	EXIT.

/
******************************************
******************************************
**********  BIG FOUR FOLLOW:  ************
******************************************
******************************************

/
****************
* RESTORE_PMTS *
****************

RESTORE_PMTS.
	MOVE "RESTORE_PMTS" TO ERR_FUNCTION_LOC.

	MOVE WS_RES_PHASE_NUM TO PHASE_NUM  OF RESTORE_PMTS_LKG.
	MOVE WS_CURR_RES_NUM   TO RES_NUM    OF RESTORE_PMTS_LKG.
        MOVE WS_RES_DATE TO RES_DATE OF RESTORE_PMTS_LKG.
	MOVE WS_CTR_NUM   TO CTR_NUM    OF RESTORE_PMTS_LKG.
	MOVE PARCEL_MASTER_REC          OF GET_PARCEL_LKG TO
		PARCEL_MASTER_REC          OF RESTORE_PMTS_LKG.
	MOVE "RS " TO
		RES_CLERK_ID               OF RESTORE_PMTS_LKG.
	CALL "RESTORE_PMTS" USING RESTORE_PMTS_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
                EVALUATE RETURN_STATUS

                   WHEN RDB_DEADLOCK_ERR_CODE
                      GO TO RESTORE_PMTS_EXIT

                   WHEN PMT_DISTRIBUTION_ERR_CODE
	 		display "*** RESTORE_PMTS ERROR: RES_APP_INPUT amt <> Payment amt - "
				WS_CURR_PARCEL_NUM
			STRING
				"TOTAL RES_APP_INPUT AMT <> PAYMENT AMT - "
                                        delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "RESTORE_PMTS" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE

                   WHEN OTHER
	 		display "Error returned from RESTORE_PMTS Subroutine on "
				WS_CURR_PARCEL_NUM
			STRING
				"Error from RESTORE_PMTS - " delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "RESTORE_PMTS" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE

		END-EVALUATE
	END-IF.

	MOVE PARCEL_MASTER_REC OF RESTORE_PMTS_LKG TO
		PARCEL_MASTER_REC OF GET_PARCEL_LKG.

RESTORE_PMTS_EXIT.
	EXIT.

/
**************
* CANCEL_TAX *
**************

CANCEL_TAX.
	MOVE "CANCEL_TAX" TO ERR_FUNCTION_LOC.

	MOVE ASSESSED_TAX OF PARCEL_MASTER_REC OF GET_PARCEL_LKG TO
		WS_ASSESSED_TAX_CANCELED.
	MOVE WS_CURR_RES_NUM   TO RES_NUM    OF CANCEL_TAX_LKG.
	MOVE WS_RES_PHASE_NUM TO PHASE_NUM  OF CANCEL_TAX_LKG.
        MOVE WS_RES_DATE TO RES_DATE OF CANCEL_TAX_LKG.
	MOVE PARCEL_MASTER_REC          OF GET_PARCEL_LKG TO
		PARCEL_MASTER_REC          OF CANCEL_TAX_LKG.
        IF ASSESSED_TAX IN PARCEL_MASTER_REC OF CANCEL_TAX_LKG = ZEROS
                 DISPLAY "Canceling assessed tax of zero on "
                         WS_CURR_PARCEL_NUM.
	MOVE "RS " TO
		RES_CLERK_ID               OF CANCEL_TAX_LKG.
	CALL "CANCEL_TAX" USING CANCEL_TAX_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		EVALUATE RETURN_STATUS

		   WHEN RDB_DEADLOCK_ERR_CODE
			GO TO CANCEL_TAX_EXIT

		   WHEN PMT_DISTRIBUTION_ERR_CODE
	 		display "*** CANCEL_TAX ERROR: RES_APP_INPUT amt <> Tax amt - "
				WS_CURR_PARCEL_NUM
			STRING
				"TOTAL RES_APP_INPUT AMT <> TAX AMT - "
                                        delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "CANCEL_TAX" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE

		   WHEN OTHER
			display "Error returned from CANCEL_TAX Subroutine on "
				WS_CURR_PARCEL_NUM
			STRING
				"Error from CANCEL_TAX - " delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "CANCEL_TAX" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE

		END-EVALUATE
	END-IF.

	MOVE PARCEL_MASTER_REC OF CANCEL_TAX_LKG TO
		PARCEL_MASTER_REC OF GET_PARCEL_LKG.

CANCEL_TAX_EXIT.
	EXIT.

/
***********
* ARCHIVE *
***********

ARCHIVE.
	MOVE "ARCHIVE" TO ERR_FUNCTION_LOC.

	MOVE WS_CURR_PARCEL_BMI   TO PARCEL_BOOK_MAP_ITEM OF ARCHIVE_LKG.
	MOVE WS_CURR_PARCEL_SPLIT TO PARCEL_SPLIT         OF ARCHIVE_LKG.
	MOVE WS_TAX_YEAR     TO TAX_YEAR             OF ARCHIVE_LKG.
	perform varying ws_indx from 1 by 1 until (ws_indx > WS_MAX_NUM_SD)
		MOVE spaces TO dist in archive_lkg(ws_indx)
		MOVE zero TO spec_dist_pct in archive_lkg(ws_indx)
	END-perform.
	MOVE WS_RUN_MODE_FLG TO RUN_MODE IN ARCHIVE_LKG.
	CALL "ARCHIVE" USING ARCHIVE_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		IF RDB_DEADLOCK
			GO TO ARCHIVE_EXIT
		END-IF
		display "Error returned from ARCHIVE Subroutine on "
			WS_CURR_PARCEL_NUM
		STRING
			"Error from ARCHIVE - " delimited by size
			WS_CURR_PARCEL_NUM DELIMITED BY SIZE
		    INTO ERR_FUNCTION_DETAIL
		MOVE "ARCHIVE" TO ERR_FUNCTION_LOC
		PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
		MOVE "YES" TO WS_SKIP_THIS_PARCEL
		SET REJECT_RES_NUM TO TRUE
	END-IF.

ARCHIVE_EXIT.
	EXIT.

/
****************
* POST_NEW_TAX *
****************

POST_NEW_TAX.
	MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC.

	MOVE 0.00 TO
		ASSESSED_TAX_PAID_1ST_HALF OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG,
		ASSESSED_TAX_PAID_2ND_HALF OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.
	MOVE "N" TO
		INT_PAID_1ST_HALF_FLG      OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG,
		INT_PAID_2ND_HALF_FLG      OF PARCEL_MASTER_REC OF POST_NEW_TAX_LKG.

	SET CREATE_RES_ACT OF POST_NEW_TAX_LKG TO TRUE.
	MOVE WS_CURR_RES_NUM   TO RES_NUM   OF POST_NEW_TAX_LKG.
	MOVE WS_RES_PHASE_NUM TO PHASE_NUM OF POST_NEW_TAX_LKG.
        MOVE WS_RES_DATE TO RES_DATE OF POST_NEW_TAX_LKG.
	MOVE DB_KEY OF GET_PARCEL_LKG TO PM_DB_KEY OF POST_NEW_TAX_LKG.
	MOVE "RS" TO RES_CLERK_ID OF POST_NEW_TAX_LKG.
	CALL "POST_NEW_TAX" USING POST_NEW_TAX_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		EVALUATE RETURN_STATUS
		   WHEN RDB_DEADLOCK_ERR_CODE
			GO TO POST_NEW_TAX_EXIT

		   WHEN PMT_DISTRIBUTION_ERR_CODE
	 		display "*** POST_NEW_TAX ERROR: RES_APP_INPUT amt <> Tax amt - "
				WS_CURR_PARCEL_NUM
			STRING
				"TOTAL RES_APP_INPUT AMT <> TAX AMT - "
                                        delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE

		   WHEN OTHER
			DISPLAY "ERROR RETURNED FROM POST_NEW_TAX SUBROUTINE - "
				WS_CURR_PARCEL_NUM
			STRING
				"Error Posting Tax Information" delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE

		END-EVALUATE
	END-IF.

	MOVE PARCEL_MASTER_REC OF POST_NEW_TAX_LKG TO
		PARCEL_MASTER_REC OF GET_PARCEL_LKG.
	MOVE PM_DB_KEY OF POST_NEW_TAX_LKG TO DB_KEY OF GET_PARCEL_LKG.

* Handle any change in the Prop 117 status of the parcel/account.  See if
* there is a row in RES_PROP117_CHANGE for this parcel, tax year, and
* phase #.  If a record is not found, then the Prop 117 status is not
* being changed.  If a record is returned, then a change to the
* parcel/account's Prop 117 is being made by this resolution.  If the
* RES_PROP117_CHANGE.CHANGE_CODE = "A", then insert a PARCEL_FLAGS row with
* FLAG_ID = 1 to indicate the parcel is now subject to Prop 117.  If the
* RES_PROP117_CHANGE.CHANGE_CODE = "D", then delete the existing PARCEL_FLAGS
* row with FLAG_ID = 1 to indicate the parcel is no longer subject to Prop 117.

	MOVE WS_TAX_YEAR TO TAX_YEAR IN GET_RES_PROP117_CHANGE_LKG.
	MOVE WS_RES_PHASE_NUM TO RES_PHASE_NUM IN GET_RES_PROP117_CHANGE_LKG.
	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
		PARCEL_BOOK_MAP_ITEM IN GET_RES_PROP117_CHANGE_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN GET_RES_PROP117_CHANGE_LKG.
	CALL "GET_RES_PROP117_CHANGE" USING GET_RES_PROP117_CHANGE_LKG
		GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		EVALUATE RETURN_STATUS
		   WHEN RDB_DEADLOCK_ERR_CODE
			GO TO POST_NEW_TAX_EXIT

		   WHEN REC_NOT_FOUND_ERR_CODE
			MOVE 1 TO RETURN_STATUS
			GO TO POST_NEW_TAX_EXIT

		   WHEN OTHER
			DISPLAY "ERROR RETURNED FROM GET_RES_PROP117_CHANGE SUBROUTINE - "
				WS_CURR_PARCEL_NUM
			STRING
				"Error getting RES_PROP117_CHANGE - " delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE
			GO TO POST_NEW_TAX_EXIT
		END-EVALUATE
	END-IF.

* If we get here, then a change is being made to the Prop 117 status of this
* parcel/account.  If the CHANGE_CODE column value is "A", then insert a
* PARCEL_FLAGS row with FLAG_ID=1.  This is the Prop 117 flag indicator.  If
* the CHANGE_CODE column value is "D", then delete the existing PARCEL_FLAGS
* row with FLAG_ID=1.

	EVALUATE TRUE
	    WHEN CHANGE_CODE IN GET_RES_PROP117_CHANGE_LKG = "A"

&RDB&		STORE F IN PARCEL_FLAGS USING
&RDB&		    ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
			IF RDB_DEADLOCK THEN
				GO TO POST_NEW_TAX_EXIT
			END-IF
			MOVE "ERROR IN PARCEL_FLAGS STORE" TO
				ERR_FUNCTION_DETAIL
			MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
			GO TO RDB_ERROR
&RDB&		    END_ERROR
&RDB&		  F.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN
&RDB&				GET_RES_PROP117_CHANGE_LKG;
&RDB&		  F.PARCEL_SPLIT = PARCEL_SPLIT IN GET_RES_PROP117_CHANGE_LKG;
&RDB&		  F.TAX_YEAR = TAX_YEAR IN GET_RES_PROP117_CHANGE_LKG;
&RDB&		  F.FLAG_ID = 1
&RDB&		END_STORE

		DISPLAY "*** PROP 117 STATUS CHANGE (ADD) - ",
			WS_CURR_PARCEL_NUM

	    WHEN CHANGE_CODE IN GET_RES_PROP117_CHANGE_LKG = "D"

&RDB&		FOR F IN PARCEL_FLAGS WITH
&RDB&			F.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN
&RDB&						GET_RES_PROP117_CHANGE_LKG AND
&RDB&			F.PARCEL_SPLIT = PARCEL_SPLIT IN
&RDB&						GET_RES_PROP117_CHANGE_LKG AND
&RDB&			F.TAX_YEAR = TAX_YEAR IN GET_RES_PROP117_CHANGE_LKG AND
&RDB&			F.FLAG_ID = 1
&RDB&		    ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
			IF RDB_DEADLOCK THEN
				GO TO POST_NEW_TAX_EXIT
			END-IF
			MOVE "ERROR IN PARCEL_FLAGS FOR" TO
				ERR_FUNCTION_DETAIL
			MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
			GO TO RDB_ERROR
&RDB&		    END_ERROR

&RDB&		ERASE F
&RDB&		    ON ERROR
			CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
			IF RDB_DEADLOCK THEN
				GO TO POST_NEW_TAX_EXIT
			END-IF
			MOVE "ERROR IN PARCEL_FLAGS ERASE" TO
				ERR_FUNCTION_DETAIL
			MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
			GO TO RDB_ERROR
&RDB&		    END_ERROR

		DISPLAY "*** PROP 117 STATUS CHANGE (DELETE) - ",
			WS_CURR_PARCEL_NUM

&RDB&		END_FOR

	    WHEN OTHER
		DISPLAY "INVALID CHANGE_CODE VALUE IN RES_PROP117_CHANGE - "
				WS_CURR_PARCEL_NUM
		STRING
			"INVALID CHANGE_CODE VALUE IN RES_PROP117_CHANGE - "
				delimited by size
			WS_CURR_PARCEL_NUM DELIMITED BY SIZE
		    INTO ERR_FUNCTION_DETAIL
		MOVE "POST_NEW_TAX" TO ERR_FUNCTION_LOC
		MOVE INVALID_ARGUMENT_ERR_CODE TO RETURN_STATUS
		PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
		MOVE "YES" TO WS_SKIP_THIS_PARCEL
		SET REJECT_RES_NUM TO TRUE
		GO TO POST_NEW_TAX_EXIT

	END-EVALUATE.

POST_NEW_TAX_EXIT.
	EXIT.

/
****************
* REAPPLY_PMTS *
****************

REAPPLY_PMTS.

	MOVE "REAPPLY_PMTS" TO ERR_FUNCTION_LOC.

	IF WS_TAX_YEAR = CURRENT_YEAR IN GBL_PARAM_VALUES
		SET CTX_PHASE OF REAPPLY_PMTS_LKG TO TRUE
	ELSE
		SET BTX_PHASE OF REAPPLY_PMTS_LKG TO TRUE
	END-IF.
	MOVE RES_GRACE_PERIOD IN GBL_PARAM_VALUES TO
		GRACE_PERIOD              OF REAPPLY_PMTS_LKG.
*       We used to use the RES_INT_RATE from GBL_PARAM_VALUES here.
*       Now, the performing paragraph is responsible for giving us the
*       rate to use in ReapplyPmts.  
        MOVE WS_RES_INT_RATE TO RES_INTEREST_RATE OF REAPPLY_PMTS_LKG.
	MOVE WS_CURR_RES_NUM TO RES_NUM     OF REAPPLY_PMTS_LKG.
	MOVE WS_RES_DATE TO RES_DATE   OF REAPPLY_PMTS_LKG.
	MOVE WS_RES_PHASE_NUM TO PHASE_NUM OF REAPPLY_PMTS_LKG.
	MOVE WS_RES_REASON TO RESO_REASON OF REAPPLY_PMTS_LKG.
	MOVE WS_ASSESSED_TAX_CANCELED  TO PREV_ASSESSED_TAX OF REAPPLY_PMTS_LKG.
	MOVE PMT_TABLE                 OF RESTORE_PMTS_LKG TO
		PMT_TABLE                 OF REAPPLY_PMTS_LKG.
	MOVE PARCEL_MASTER_REC         OF GET_PARCEL_LKG TO
		PARCEL_MASTER_REC         OF REAPPLY_PMTS_LKG.
	MOVE "RS" TO
		RES_CLERK_ID              OF REAPPLY_PMTS_LKG.
	MOVE MINIMUM_FULL_TAX IN GET_MINIMUM_FULL_TAX_LKG TO
		MINIMUM_FULL_TAX_AMT IN REAPPLY_PMTS_LKG.

* Pass the nexTIS Refund Slip ID to reapply_pmts since that is where
* the refunds will be created.
        MOVE WS_REFUND_SLIP_ID TO REF_SLIP_ID IN REAPPLY_PMTS_LKG.
	CALL "REAPPLY_PMTS" USING REAPPLY_PMTS_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
                EVALUATE RETURN_STATUS

                   WHEN RDB_DEADLOCK_ERR_CODE
			GO TO REAPPLY_PMTS_EXIT

		   WHEN PMT_DISTRIBUTION_ERR_CODE
	 		display "*** REAPPLY_PMTS ERROR: RES_APP_INPUT amt <> Payment amt - "
				WS_CURR_PARCEL_NUM
			STRING
				"TOTAL RES_APP_INPUT AMT <> PAYMENT AMT - "
                                        delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "REAPPLY_PMTS" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE
			GO TO REAPPLY_PMTS_EXIT

                   WHEN OTHER
			DISPLAY "ERROR RETURNED FROM REAPPLY_PMTS SUBROUTINE - "
				WS_CURR_PARCEL_NUM
			STRING
				"Error FROM REAPPLY_PMTS SUBROUTINE " delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "REAPPLY_PMTS" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE
			GO TO REAPPLY_PMTS_EXIT

		END-EVALUATE
	END-IF.             

	MOVE AMT_PAYED IN REAPPLY_PMTS_LKG TO
		REAPPLY_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE AMT_RES_INT IN REAPPLY_PMTS_LKG TO
		RES_INT_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE AMT_IMPOUNDED IN REAPPLY_PMTS_LKG TO
		IMPOUND_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE AMT_DUE IN REAPPLY_PMTS_LKG TO
		AMT_DUE IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).
	MOVE RESULT_TYPE IN REAPPLY_PMTS_LKG TO
		RESULT_TYPE IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).

	initialize RESOLUTIONS_REAPPLY_REC.
	MOVE PARCEL_BOOK_MAP_ITEM in PARCEL_MASTER_REC in REAPPLY_PMTS_LKG TO
		PARCEL_BOOK_MAP_ITEM in RESOLUTIONS_REAPPLY_REC.
	MOVE PARCEL_SPLIT in PARCEL_MASTER_REC in REAPPLY_PMTS_LKG TO
		PARCEL_SPLIT in RESOLUTIONS_REAPPLY_REC.
	MOVE TAX_YEAR in PARCEL_MASTER_REC in REAPPLY_PMTS_LKG TO
		TAX_YEAR in RESOLUTIONS_REAPPLY_REC.
	MOVE PHASE_NUM in REAPPLY_PMTS_LKG TO
		RES_PHASE_NUM in RESOLUTIONS_REAPPLY_REC.
	MOVE RES_NUM in REAPPLY_PMTS_LKG TO
		RES_NUM in RESOLUTIONS_REAPPLY_REC.
	ADD
		ASSESSED_TAX_PAID_1ST_HALF in PARCEL_MASTER_REC in REAPPLY_PMTS_LKG,
		ASSESSED_TAX_PAID_2ND_HALF in PARCEL_MASTER_REC in REAPPLY_PMTS_LKG
	    GIVING REAPPLY_TAX_AMT in RESOLUTIONS_REAPPLY_REC.
	MOVE REAPPLY_TAX_AMT IN RESOLUTIONS_REAPPLY_REC TO
		REAPPLY_TAX_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT).

* bobjuan April 2008.  Here's the deal.  We are not going to assume
* that the fees passed into ReapplyPmts from the RestorePmts processing
* were reapplied.  Check the AmtPayed field in the linkage.  It is updated
* whenever ReapplyPmts actually reapplies restored payments.  This is a bug
* fix.  When restored fees are passed in for a parcel that is "going away"
* we do not reapply any restored payments/fees.
* We will keep them out of ReapplyFeeAmt in the
* ResNumParcel Table so they don't mess up the final reporting (CshTotalsRpt
* and ResBal row).

	IF AMT_PAYED IN REAPPLY_PMTS_LKG > 0 THEN
	    MOVE TOT_PMT_FEE IN REAPPLY_PMTS_LKG TO
		    REAPPLY_FEE_AMT IN RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_CNT)
	END-IF.

	IF UPDATE_MODE_RUN and
	   REAPPLY_TAX_AMT in RESOLUTIONS_REAPPLY_REC > ZERO and
	   TAX_YEAR in RESOLUTIONS_REAPPLY_REC = CURRENT_YEAR IN GBL_PARAM_VALUES
*
*	Store a RESOLUTIONS_REAPPLY record IF this is a current year
*	resolution and IF payments were reapplied.  These records will
*	be read by the CREATE_BILL_DATA program that creates the resolution
*	tax bills.  These amounts will be used TO reflect the actual amount
*	due on the tax bills (after payments were reapplied).
*
&RDB&		STORE X IN PROPERTY.RESOLUTIONS_REAPPLY USING
&RDB&		   on error
			CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
			IF RDB_DEADLOCK
				GO TO REAPPLY_PMTS_EXIT
			END-IF
			MOVE "REAPPLY_PMTS" TO ERR_FUNCTION_LOC
			MOVE "Error storing RESOLUTIONS_REAPPLY" TO ERR_FUNCTION_DETAIL
			GO TO RDB_ERROR
&RDB&		   END_ERROR
&RDB&		  X.* = RESOLUTIONS_REAPPLY_REC
&RDB&		END_sTOre                                    
	END-IF.

	MOVE PARCEL_MASTER_REC OF REAPPLY_PMTS_LKG TO
		PARCEL_MASTER_REC OF GET_PARCEL_LKG.
	SET RES_COMPLETED OF GET_PARCEL_LKG TO TRUE.

	MOVE AMT_RES_INT OF REAPPLY_PMTS_LKG TO WS_RES_INT_TMP.

REAPPLY_PMTS_EXIT.
	EXIT.

/
**********************
* REAPPLY_SPLIT_PMTS *
**********************

REAPPLY_SPLIT_PMTS.
	MOVE "REAPPLY_SPLIT_PMTS" TO ERR_FUNCTION_LOC.

	MOVE "RS" TO
		RES_CLERK_ID              OF REAPPLY_SPLIT_PMTS_LKG.
	MOVE WS_CURR_RES_NUM TO RES_NUM     OF REAPPLY_SPLIT_PMTS_LKG.
	MOVE WS_RES_PHASE_NUM TO PHASE_NUM OF REAPPLY_SPLIT_PMTS_LKG.
	MOVE WS_RES_DATE TO RES_DATE   OF REAPPLY_SPLIT_PMTS_LKG.
	IF WS_TAX_YEAR = CURRENT_YEAR IN GBL_PARAM_VALUES
		SET CTX_PHASE OF REAPPLY_SPLIT_PMTS_LKG TO TRUE
	ELSE
		SET BTX_PHASE OF REAPPLY_SPLIT_PMTS_LKG TO TRUE
	END-IF.
	MOVE WS_RES_NUM_PMT_TABLE TO
		RES_NUM_PMT_TABLE IN REAPPLY_SPLIT_PMTS_LKG.
	MOVE WS_REAPPLY_SPLIT_PMT_FLG TO
		REAPPLY_FLG IN REAPPLY_SPLIT_PMTS_LKG.
	MOVE MINIMUM_FULL_TAX IN GET_MINIMUM_FULL_TAX_LKG TO
		MINIMUM_FULL_TAX_AMT IN REAPPLY_SPLIT_PMTS_LKG.
	CALL "REAPPLY_SPLIT_PMTS" USING REAPPLY_SPLIT_PMTS_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1
		EVALUATE RETURN_STATUS

		   WHEN RDB_DEADLOCK_ERR_CODE
			GO TO REAPPLY_SPLIT_PMTS_EXIT

		   WHEN PMT_DISTRIBUTION_ERR_CODE
	 		display "*** REAPPLY_SPLIT_PMTS ERROR: RES_APP_INPUT amt <> Payment amt - "
				WS_CURR_PARCEL_NUM
			STRING
				"TOTAL RES_APP_INPUT AMT <> PAYMENT AMT - "
                                        delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "REAPPLY_SPLIT_PMTS" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE
			GO TO REAPPLY_SPLIT_PMTS_EXIT

		   WHEN OTHER
			DISPLAY "ERROR RETURNED FROM REAPPLY_SPLIT_PMTS SUBROUTINE - "
				WS_CURR_PARCEL_NUM
			STRING
				"Error FROM REAPPLY_SPLIT_PMTS SUBROUTINE " delimited by size
				WS_CURR_PARCEL_NUM DELIMITED BY SIZE
			    INTO ERR_FUNCTION_DETAIL
			MOVE "REAPPLY_SPLIT_PMTS" TO ERR_FUNCTION_LOC
			PERFORM HANDLE_ERRORS THROUGH HANDLE_ERRORS_EXIT
			MOVE "YES" TO WS_SKIP_THIS_PARCEL
			SET REJECT_RES_NUM TO TRUE
			GO TO REAPPLY_SPLIT_PMTS_EXIT

		END-EVALUATE
	END-IF.

*
*	Store a RESOLUTIONS_REAPPLY record IF this is a current year
*	resolution and IF payments were reapplied.  These records will
*	be read by the CREATE_BILL_DATA program that creates the resolution
*	tax bills.  These amounts will be used TO reflect the actual amount
*	due on the tax bills (after payments were reapplied).
*
	MOVE 1 TO RES_NUM_PARCEL_IX.
	PERFORM WITH TEST BEFORE UNTIL RES_NUM_PARCEL_IX > RES_NUM_PARCEL_CNT
		IF REAPPLY_TAX_AMT IN
		   RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) > ZERO AND
		   UPDATE_MODE_RUN AND
		   WS_TAX_YEAR = CURRENT_YEAR IN GBL_PARAM_VALUES
			initialize RESOLUTIONS_REAPPLY_REC
			MOVE PARCEL_BMI IN
					RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
				PARCEL_BOOK_MAP_ITEM in RESOLUTIONS_REAPPLY_REC
			MOVE PARCEL_SPLIT IN
					RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
				PARCEL_SPLIT in RESOLUTIONS_REAPPLY_REC
			MOVE WS_TAX_YEAR TO
				TAX_YEAR IN RESOLUTIONS_REAPPLY_REC
			MOVE PHASE_NUM in REAPPLY_SPLIT_PMTS_LKG TO
				RES_PHASE_NUM in RESOLUTIONS_REAPPLY_REC
			MOVE RES_NUM in REAPPLY_SPLIT_PMTS_LKG TO
				RES_NUM in RESOLUTIONS_REAPPLY_REC
			MOVE REAPPLY_TAX_AMT IN
					RES_NUM_PARCEL_TABLE(RES_NUM_PARCEL_IX) TO
				REAPPLY_TAX_AMT IN RESOLUTIONS_REAPPLY_REC
&RDB&			STORE X IN PROPERTY.RESOLUTIONS_REAPPLY USING
&RDB&			   on error
				CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
				IF RDB_DEADLOCK
					GO TO REAPPLY_SPLIT_PMTS_EXIT
				END-IF
				MOVE "REAPPLY_SPLIT_PMTS" TO ERR_FUNCTION_LOC
				MOVE "Error storing RESOLUTIONS_REAPPLY" TO ERR_FUNCTION_DETAIL
				GO TO RDB_ERROR
&RDB&			   END_ERROR
&RDB&			  X.* = RESOLUTIONS_REAPPLY_REC
&RDB&			END_STORE
		END-IF
		ADD 1 TO RES_NUM_PARCEL_IX
	END-PERFORM.

REAPPLY_SPLIT_PMTS_EXIT.
	EXIT.

/
********************
UPDATE_RESTART.
********************

&RDB&	FOR P IN PROG_RESTART WITH
&RDB&		P.RDB$DB_KEY = WS_PROG_RESTART_DBKEY
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO UPDATE_RESTART_EXIT
		END-IF
		MOVE "ERROR IN PROG_RESTART FOR" TO ERR_FUNCTION_DETAIL
		MOVE "UPDATE_RESTART" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR

&RDB&	GET
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO UPDATE_RESTART_EXIT
		END-IF
		MOVE "ERROR IN PROG_RESTART GET" TO ERR_FUNCTION_DETAIL
		MOVE "UPDATE_RESTART" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR
&RDB&	  PROG_RESTART_REC IN PROG_RESTART_LKG = P.*;
&RDB&	END_GET

	MOVE WS_RESTART_BUFFER TO RESTART_BUFFER IN PROG_RESTART_LKG
	MOVE "Y" TO JOB_BUSY_FLG IN PROG_RESTART_LKG

&RDB&	MODIFY P USING
&RDB&	    ON ERROR
		CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
		IF RDB_DEADLOCK THEN
			GO TO UPDATE_RESTART_EXIT
		END-IF
		MOVE "ERROR IN PROG_RESTART MODIFY" TO ERR_FUNCTION_DETAIL
		MOVE "UPDATE_RESTART" TO ERR_FUNCTION_LOC
		GO TO RDB_ERROR
&RDB&	    END_ERROR
&RDB&	  P.RESTART_BUFFER = RESTART_BUFFER IN PROG_RESTART_LKG;
&RDB&	  P.JOB_BUSY_FLG = JOB_BUSY_FLG IN PROG_RESTART_LKG
&RDB&	END_MODIFY

&RDB&	END_FOR.

UPDATE_RESTART_EXIT.
	EXIT.

/

* ******************* *
* GET_EDIT_RUN_PARCEL *
* ******************* *

GET_EDIT_RUN_PARCEL.

    MOVE "GET_EDIT_RUN_PARCEL" TO ERR_FUNCTION_LOC.

* If this is a new parcel, the seq num will be "R" in an edit run.
* Otherwise it will be a "0".  We'll try zero first, then "R" and return
* with the parcel for edit runs.

      MOVE "X" TO PARCEL_SEQ_NUM IN GET_PARCEL_LKG.
      MOVE 1 TO RETURN_STATUS.

&RDB& FOR P IN PARCEL_MASTER WITH
&RDB&     P.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG AND
&RDB&     P.PARCEL_SPLIT = PARCEL_SPLIT IN GET_PARCEL_LKG AND
&RDB&     P.TAX_YEAR = TAX_YEAR IN GET_PARCEL_LKG AND
&RDB&     P.PARCEL_SEQ_NUM = "0"
&RDB& ON ERROR
         MOVE "ERROR STARTING FOR ON 0" TO ERR_FUNCTION_DETAIL
         GO TO RDB_ERROR
&RDB& END_ERROR
&RDB& GET
&RDB& ON ERROR
         MOVE "ERROR GETTING ON 0" TO ERR_FUNCTION_DETAIL
         GO TO RDB_ERROR
&RDB& END_ERROR
&RDB& PARCEL_MASTER_REC IN GET_PARCEL_LKG = P.*
&RDB& END_GET
&RDB& END_FOR.
                                 
    IF PARCEL_SEQ_NUM IN GET_PARCEL_LKG = "0" THEN
        GO TO GET_EDIT_RUN_PARCEL_EXIT
    END-IF.

&RDB& FOR P IN PARCEL_MASTER WITH
&RDB&     P.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN GET_PARCEL_LKG AND
&RDB&     P.PARCEL_SPLIT = PARCEL_SPLIT IN GET_PARCEL_LKG AND
&RDB&     P.TAX_YEAR = TAX_YEAR IN GET_PARCEL_LKG AND
&RDB&     P.PARCEL_SEQ_NUM = "R"
&RDB& ON ERROR
         MOVE "ERROR STARTING FOR ON R" TO ERR_FUNCTION_DETAIL
         GO TO RDB_ERROR
&RDB& END_ERROR
&RDB& GET
&RDB& ON ERROR
         MOVE "ERROR GETTING ON R" TO ERR_FUNCTION_DETAIL
         GO TO RDB_ERROR
&RDB& END_ERROR
&RDB& PARCEL_MASTER_REC IN GET_PARCEL_LKG = P.*
&RDB& END_GET
&RDB& END_FOR.

    IF PARCEL_SEQ_NUM IN GET_PARCEL_LKG = "R" THEN
        GO TO GET_EDIT_RUN_PARCEL_EXIT
    END-IF.

    MOVE REC_NOT_FOUND_ERR_CODE TO RETURN_STATUS.

GET_EDIT_RUN_PARCEL_EXIT.

/
* ******************************* *
* Resolution Letter Routines Here *
* ******************************* *
* Res letters are written to a file based upon the RESULT_TYPE in the 
* REAPPLY_PMTS_LKG (refund, impound, over/under, no effect, underpayment).
* But in addition to the monetary affect of a resolution
* there can be many resolution reasons. Example: a refund can result
* from a full tax exemption, a partial exemption or for many other 
* resolution reasons. For each of these situations we have the same data that 
* we want to show on the letter: Name and address, res no, parcel no, tax year, 
* refund amount, etc.  But the verbage we want to use to explain the resolution 
* changes. To facilitate this a table in the database, 
* RES_LETTER_TEXT has been created to store the text for easy modification 
* and retrieval later on. At this time there is a 1:1 relationship between 
* a letter and a row in the RES_LETTER_TEXT table.   


*********************
* FETCH_LETTER_TEXT *
*********************
* OK girls here is where we get the text we need for the letters. Here we spin
* through the stream and load up a table with all the text.  We retrieve this 
* text by WS_RES_LETTER_TYPE later on.   

FETCH_LETTER_TEXT.

        MOVE "FETCH_LETTER_TEXT" TO ERR_FUNCTION_LOC.
	
	INITIALIZE WS_RES_LETTER_TEXT.	

	SET RO_TRANS TO TRUE.
	perform START_TRANS thru START_TRANS_EXIT. 

&RDB&   START_STREAM LETTER_TEXT_STREAM USING R IN PROPERTY.RES_LETTER_TEXT
&RDB&   SORTED BY R.LETTER_ID 
&RDB&   ON ERROR
		MOVE "FETCH_LETTER_TEXT" TO ERR_FUNCTION_LOC
		MOVE "ERROR STARTING STREAM." TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR                                           
&RDB&   END_ERROR.

	MOVE 1 TO WS_TEXT_INDEX.

LT_FETCH.

&RDB&   FETCH LETTER_TEXT_STREAM 
&RDB&   ON ERROR
		MOVE "FETCH_LETTER_TEXT" TO ERR_FUNCTION_LOC
       	     	MOVE "ERROR FETCHING STREAM" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR                                           
&RDB&   END_ERROR

&RDB&   AT END 
		GO TO END_LETTER_TEXT_STREAM
&RDB&   END_FETCH

&RDB&   GET
&RDB&   ON ERROR
		MOVE "FETCH_LETTER_TEXT" TO ERR_FUNCTION_LOC
	        MOVE "ERROR IN GET" TO ERR_FUNCTION_DETAIL
		GO TO RDB_ERROR                                           
&RDB&   END_ERROR

&RDB&   MY_TABLE(WS_TEXT_INDEX) = R.*
&RDB&   END_GET

        ADD 1 TO WS_TEXT_INDEX.	
        GO TO LT_FETCH.

END_LETTER_TEXT_STREAM.

&RDB&   END_STREAM LETTER_TEXT_STREAM.

	PERFORM COMMIT_TRAN THRU COMMIT_TRAN_EXIT.
 
* now that we have the letter text let's get the 'enclosed is your taxbill' 
* text that we will use for just about every CTX letter's second paragraph.
* I get this text up front because TAX_BILL isn't a letter type it actually 
* describes the type of text I want to get. this text can be used for many 
* different types of letters not any one letter specifically.  
* You see, typically I use the WS_RES_LETTER_TYPE to specify 
* what letter text I want, but I also use it to help me keep track of what type 
* of letter I am processing and to help increment the appropriate counter after
* the letter has been stored.  It's easier to get the taxbill text up front 
* before I start processing letters. 
* If I retrieved the taxbill text during processing I'd have to save the 
* WS_RES_LETTER_TYPE of the letter I'm currently processing, switch the 
* WS_RES_LETTER_TYPE to TAX_BILL to get this text and then switch the 
* letter type back to the letter type I saved.  Here I just put it in 
* working storage so I don't have to switch my letter type back and forth.
* Remember the reason why this tax bill text is in the DB is so we can 
* easily change it later without recompiling any programs.   
	
	SET TAX_BILL IN WS_RES_LETTER_TYPE TO TRUE.	
        PERFORM MOVE_LETTER_TEXT THRU MOVE_LETTER_TEXT_EXIT.

FETCH_LETTER_TEXT_EXIT.


/
*****************
* GET_DATE_FULL *
*****************
* this is a little didy that retrieves a user-friendly date like this:
* September 5, 2002. this is only for purposes of display on our letters.

GET_DATE_FULL.

        MOVE "GET_DATE_FULL" TO ERR_FUNCTION_LOC.
 	
        INITIALIZE DATE_CONVERT_LKG.
	SET USE_CURRENT_DATE IN INPUT_DATE_TYPE IN DATE_CONVERT_LKG TO TRUE.
	CALL "DATE_CONVERT" USING DATE_CONVERT_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN DISPLAY "ERROR GETTING DATE FULL.".
	MOVE DATE_FULL IN DATE_CONVERT_LKG TO WS_DATE_FULL. 	

GET_DATE_FULL_EXIT.
        

/
*******************
* INIT_RES_LETTER *
*******************
* this paragraph grabs information needed to discern the type of letter to 
* print and moves it into WS_PROC_LETTER.
                 
INIT_RES_LETTER.

        MOVE "INIT_RES_LETTER" TO ERR_FUNCTION_LOC.

	INITIALIZE WS_PROC_LETTER.
	INITIALIZE WS_RES_LETTER_TYPE.
       
* let's record the res and parcel number for this letter so we can easily
* display these values if we come accross an error
	
	MOVE RES_NUM IN RES_PHASE_LIST_REC TO WS_ERR_RES_NUM.
	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO WS_ERR_BMI. 
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO WS_ERR_SPLIT. 
	
	MOVE RES_REASON IN RES_PHASE_LIST_REC TO
	     RES_REASON IN WS_PROC_LETTER.

	MOVE ASSR_EXEMPT_CODE IN POST_NEW_TAX_LKG TO
	     ASSR_EXEMPT_CODE IN WS_PROC_LETTER.
         
	MOVE AMT_IMPOUNDED IN REAPPLY_PMTS_LKG TO 
	     AMT_IMPOUNDED IN WS_PROC_LETTER.

	MOVE CLERK_ID IN REAPPLY_PMTS_LKG TO 
	     REFUND_CLERK_ID IN WS_PROC_LETTER.
 
        MOVE RESULT_TYPE IN REAPPLY_PMTS_LKG TO
	     RESULT_TYPE IN WS_PROC_LETTER. 
        	
	IF TAX_YEAR IN RES_PHASE_LIST_REC = CURRENT_YEAR
      	    IN GBL_PARAM_VALUES THEN
		SET CTX IN WS_PROC_LETTER TO TRUE
	ELSE        
		SET BTX IN WS_PROC_LETTER TO TRUE          
        END-IF.                                         
        
	IF UNDER_PAYMENT_RESULT IN REAPPLY_PMTS_LKG THEN
	     IF PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC >= 90000000 THEN 
	          PERFORM GET_UPPS_DUE THRU
			  GET_UPPS_DUE_EXIT
	     ELSE
		  PERFORM GET_SECURED_DUE THRU
			  GET_SECURED_DUE_EXIT
	     END-IF
	END-IF.

	IF REFUND_RESULT IN REAPPLY_PMTS_LKG THEN 
		PERFORM CHECK_FOR_TITLE_CO THRU 
 			CHECK_FOR_TITLE_CO_EXIT
	END-IF.
                      
INIT_RES_LETTER_EXIT.


/
**********************
* CHECK_FOR_TITLE_CO *
**********************
CHECK_FOR_TITLE_CO.	

	MOVE "CHECK_FOR_TITLE_CO" TO ERR_FUNCTION_LOC.
	
	MOVE "N" TO TITLE_CO_FLG IN WS_PROC_LETTER.

&RDB& GET 
&RDB& ON ERROR
	 DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		 "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - "       
	         "RDB GET RECORD COUNT FOR RES TITLE COMPANY."              	
&RDB& END_ERROR 
&RDB& WS_RTC_COUNT = COUNT OF R IN RES_TITLE_COMPANY WITH 
&RDB&     R.TAX_YEAR = TAX_YEAR IN 
&RDB&                  RES_PHASE_LIST_REC AND
&RDB&     R.RES_PHASE_NUM = RES_PHASE_NUM IN 
&RDB&	                    RES_PHASE_LIST_REC AND 
&RDB&     R.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN 
&RDB&                              RES_PHASE_LIST_REC AND
&RDB&     R.PARCEL_SPLIT = PARCEL_SPLIT IN 
&RDB&                      RES_PHASE_LIST_REC    
&RDB& END_GET

	IF WS_RTC_COUNT > 0 THEN MOVE "Y" TO TITLE_CO_FLG IN WS_PROC_LETTER.

CHECK_FOR_TITLE_CO_EXIT.


/ 
****************
* GET_UPPS_DUE *
****************
GET_UPPS_DUE.

	MOVE "GET_UPPS_DUE" TO ERR_FUNCTION_LOC.
	
	INITIALIZE CALC_PERS_PROP_DUE_LKG. 

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO       
             PARCEL_BOOK_MAP_ITEM IN CALC_PERS_PROP_DUE_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
             PARCEL_SPLIT IN CALC_PERS_PROP_DUE_LKG.
	MOVE TAX_YEAR IN RES_PHASE_LIST_REC TO 
	     TAX_YEAR IN CALC_PERS_PROP_DUE_LKG.
 	MOVE PARCEL_SEQ_NUM IN GET_PARCEL_LKG TO 
	     PARCEL_SEQ_NUM IN CALC_PERS_PROP_DUE_LKG.	
                  
* if the day of the month is before the 15th then use today  
* as the payment date.  

	MOVE DISP_DAY IN GET_CURRENT_DATE_TIME_LKG TO WS_DAY_X.        
  	  
	IF WS_DAY < 15 THEN
              MOVE JUL_DATE IN GET_CURRENT_DATE_TIME_LKG TO 
	              PMT_DATE IN CALC_PERS_PROP_DUE_LKG

* if the day of the month is the 15th or later, then use the  
* last day of next month as the payment date.

	ELSE 
	      PERFORM GET_NEXT_MONTH_PMT_DATE THRU
	              GET_NEXT_MONTH_PMT_DATE_EXIT
              MOVE WS_NEXT_MONTH_PMT_DATE TO 
                   PMT_DATE IN CALC_PERS_PROP_DUE_LKG 
	END-IF.
	MOVE PMT_DATE IN CALC_PERS_PROP_DUE_LKG TO WS_LETTER_CALC_DATE.

	MOVE "P" TO GLOBAL_DATABASE_FLG IN CALC_PERS_PROP_DUE_LKG.
        CALL "CALC_PERS_PROP_DUE" USING CALC_PERS_PROP_DUE_LKG
              GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
	      DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		      "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - "
		      "ERROR CALCULATING UPPS TAX DUE. "               
	               ERR_FUNCTION_DETAIL 	
	END-IF.                  
                       
* If REAPPLY_PMTS_LKG flagged this as an UNDER_PAYMENT_RESULT but there is 
* nothing due then we need to write to the log baby!
             
	IF TOTAL_DUE IN CALC_PERS_PROP_DUE_LKG = ZERO THEN
	      DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		      "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - "       
	              "UNDERPAYMENT WITH ZERO TAX DUE. "              
        END-IF.    

* if this is a back tax then treat the underpayment as a second half due.
* this is done for the purpose of our letter processing since the
* 2nd half due letter has one AMT_DUE and one DUE_DATE attribute. 
* this works well since back taxes only have one due amount and one 
* due date.
 
        IF BTX IN WS_PROC_LETTER THEN
	     SET SECOND_HALF IN WS_PROC_LETTER TO TRUE
	     GO TO OVERRIDE_HALF_FLG_UPPS
	END-IF.                      
	
	IF TAX_DUE_1ST_HALF IN CALC_PERS_PROP_DUE_LKG = 0 AND 
	   TAX_DUE_2ND_HALF IN CALC_PERS_PROP_DUE_LKG > 0 THEN 
       	     SET SECOND_HALF IN WS_PROC_LETTER TO TRUE
	ELSE
	     SET FULL_YEAR IN WS_PROC_LETTER TO TRUE 
	END-IF.
	
OVERRIDE_HALF_FLG_UPPS.
     
        IF TAX_DUE_1ST_HALF IN CALC_PERS_PROP_DUE_LKG > ZERO THEN
	     MOVE FEES_DUE IN CALC_PERS_PROP_DUE_LKG TO
	          WS_FEES_DUE_1ST_HALF
	     MOVE ZERO TO WS_FEES_DUE_2ND_HALF
	ELSE 
	     MOVE ZERO TO WS_FEES_DUE_1ST_HALF
             MOVE FEES_DUE IN CALC_PERS_PROP_DUE_LKG TO 
	          WS_FEES_DUE_2ND_HALF
        END-IF.
	
	ADD TAX_DUE_1ST_HALF IN CALC_PERS_PROP_DUE_LKG 
            INT_DUE_1ST_HALF IN CALC_PERS_PROP_DUE_LKG 
            WS_FEES_DUE_1ST_HALF GIVING AMT_DUE_1ST_HALF IN WS_PROC_LETTER.

	ADD TAX_DUE_2ND_HALF IN CALC_PERS_PROP_DUE_LKG
            INT_DUE_2ND_HALF IN CALC_PERS_PROP_DUE_LKG
            WS_FEES_DUE_2ND_HALF GIVING AMT_DUE_2ND_HALF IN WS_PROC_LETTER.
	     
        MOVE DUE_DATE_1ST_HALF_FULL IN CALC_PERS_PROP_DUE_LKG TO 
	     DUE_DATE_1ST_HALF IN WS_PROC_LETTER.	
	     
        MOVE DUE_DATE_2ND_HALF_FULL IN CALC_PERS_PROP_DUE_LKG TO 
	     DUE_DATE_2ND_HALF IN WS_PROC_LETTER.
	     
	MOVE TOTAL_DUE IN CALC_PERS_PROP_DUE_LKG TO 
             TOTAL_DUE IN WS_PROC_LETTER.                        
        
* we need some additional breakdown for the tax due statement

	MOVE TAX_DUE_1ST_HALF IN CALC_PERS_PROP_DUE_LKG TO 
             TAX_DUE_1ST_HALF IN WS_PROC_LETTER.
	
	MOVE TAX_DUE_2ND_HALF IN CALC_PERS_PROP_DUE_LKG TO 
	     TAX_DUE_2ND_HALF IN WS_PROC_LETTER.

	MOVE TAX_DUE IN CALC_PERS_PROP_DUE_LKG TO 
	     TAX_DUE IN WS_PROC_LETTER.

	MOVE INT_DUE_1ST_HALF IN CALC_PERS_PROP_DUE_LKG TO 
	     INT_DUE_1ST_HALF IN WS_PROC_LETTER.

	MOVE INT_DUE_2ND_HALF IN CALC_PERS_PROP_DUE_LKG TO 
	     INT_DUE_2ND_HALF IN WS_PROC_LETTER.

	MOVE INT_DUE IN CALC_PERS_PROP_DUE_LKG TO 
	     INT_DUE IN WS_PROC_LETTER.
		
	MOVE WS_FEES_DUE_1ST_HALF TO 
                FEES_DUE_1ST_HALF IN WS_PROC_LETTER.

	MOVE WS_FEES_DUE_2ND_HALF TO 
		FEES_DUE_2ND_HALF IN WS_PROC_LETTER.

	ADD WS_FEES_DUE_1ST_HALF WS_FEES_DUE_2ND_HALF
	GIVING FEES_DUE IN WS_PROC_LETTER.

	MOVE SPEC_INT_FLG IN CALC_PERS_PROP_DUE_LKG TO 
	     SPEC_INT_FLG IN WS_PROC_LETTER.

	MOVE SPEC_INT_EXPIRE_DATE IN CALC_PERS_PROP_DUE_LKG TO 
	     SPEC_INT_EXPIRE_DATE IN WS_PROC_LETTER.         

GET_UPPS_DUE_EXIT.

/
*******************
* GET_SECURED_DUE *
*******************
GET_SECURED_DUE.

        MOVE "GET_SECURED_DUE" TO ERR_FUNCTION_LOC.
	
	INITIALIZE CALC_SECURED_DUE_LKG. 	
	
        MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO       
             PARCEL_BOOK_MAP_ITEM IN KEY_DATA IN CALC_SECURED_DUE_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
             PARCEL_SPLIT IN KEY_DATA IN CALC_SECURED_DUE_LKG.
	MOVE TAX_YEAR IN RES_PHASE_LIST_REC TO 
	     TAX_YEAR IN KEY_DATA IN CALC_SECURED_DUE_LKG.
	MOVE PARCEL_SEQ_NUM IN GET_PARCEL_LKG TO 
	     PARCEL_SEQ_NUM IN KEY_DATA IN CALC_SECURED_DUE_LKG. 
	                  
* if the day of the month is before the 15th then use today  
* as the payment date.  

	MOVE DISP_DAY IN GET_CURRENT_DATE_TIME_LKG TO WS_DAY_X.        
  	  
	IF WS_DAY < 15 THEN
              MOVE JUL_DATE IN GET_CURRENT_DATE_TIME_LKG TO 
              PMT_DATE IN KEY_DATA IN CALC_SECURED_DUE_LKG

* if the day of the month is the 15th or later, then use the  
* last day of next month as the payment date.

	ELSE 
	      PERFORM GET_NEXT_MONTH_PMT_DATE THRU
	              GET_NEXT_MONTH_PMT_DATE_EXIT
              MOVE WS_NEXT_MONTH_PMT_DATE TO 
                   PMT_DATE IN KEY_DATA IN CALC_SECURED_DUE_LKG 
	END-IF.
	MOVE PMT_DATE IN KEY_DATA IN CALC_SECURED_DUE_LKG TO
		WS_LETTER_CALC_DATE.

	SET PM_INCLUDED IN KEY_DATA IN CALC_SECURED_DUE_LKG TO TRUE.     
	MOVE PARCEL_MASTER_REC IN REAPPLY_PMTS_LKG TO 
             PARCEL_MASTER_REC IN CALC_SECURED_DUE_LKG.                  
	SET RES_INCLUDED IN KEY_DATA IN CALC_SECURED_DUE_LKG TO TRUE.
	MOVE RESOLUTIONS_REC IN MOD_RESOLUTIONS_REC_LKG TO 
	     RESOLUTIONS_REC IN CALC_SECURED_DUE_LKG. 
	MOVE "P" TO GLOBAL_DATABASE_FLG IN CALC_SECURED_DUE_LKG.

        CALL "CALC_SECURED_DUE" USING CALC_SECURED_DUE_LKG
              GIVING RETURN_STATUS.
        IF RETURN_STATUS < 1 THEN
	      DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		      "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - "     
	              "ERROR CALCULATING SECURED TAX DUE. "
	END-IF.                                  
             
* If REAPPLY_PMTS_LKG flagged this as an UNDER_PAYMENT_RESULT but there is 
* nothing due then we need to write to the log baby!
             
	IF TOTAL_DUE IN CALC_SECURED_DUE_LKG = ZERO THEN
              DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		      "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
	              "UNDERPAYMENT WITH ZERO TAX DUE. "    	     		
	END-IF.

* if this is a back tax then treat the underpayment as a second half due.
* this is done for the purpose of our letter processing since the
* 2nd half due letter has one AMT_DUE and one DUE_DATE attribute. 
* this works well since back taxes only have one due amount and one 
* due date.
        
	IF BTX IN WS_PROC_LETTER THEN
	     SET SECOND_HALF IN WS_PROC_LETTER TO TRUE
	     GO TO OVERRIDE_HALF_FLG_SECURED
	END-IF.                      
	
        IF TAX_DUE_1ST_HALF IN CALC_SECURED_DUE_LKG = 0 AND 
           TAX_DUE_2ND_HALF IN CALC_SECURED_DUE_LKG > 0 THEN 
	       SET SECOND_HALF IN WS_PROC_LETTER TO TRUE
	ELSE
	       SET FULL_YEAR IN WS_PROC_LETTER TO TRUE 
	END-IF.
	
OVERRIDE_HALF_FLG_SECURED.
     
        IF TAX_DUE_1ST_HALF IN CALC_SECURED_DUE_LKG > ZERO THEN
	     MOVE FEES_DUE IN DUE_DATA IN CALC_SECURED_DUE_LKG TO
	          WS_FEES_DUE_1ST_HALF
	     MOVE ZERO TO WS_FEES_DUE_2ND_HALF
	ELSE 
	     MOVE ZERO TO WS_FEES_DUE_1ST_HALF
             MOVE FEES_DUE IN DUE_DATA IN CALC_SECURED_DUE_LKG TO 
	          WS_FEES_DUE_2ND_HALF
        END-IF.
	
	ADD TAX_DUE_1ST_HALF IN CALC_SECURED_DUE_LKG 
            INT_DUE_1ST_HALF IN CALC_SECURED_DUE_LKG 
            WS_FEES_DUE_1ST_HALF GIVING AMT_DUE_1ST_HALF IN WS_PROC_LETTER.

	ADD TAX_DUE_2ND_HALF IN CALC_SECURED_DUE_LKG
            INT_DUE_2ND_HALF IN CALC_SECURED_DUE_LKG
            WS_FEES_DUE_2ND_HALF GIVING AMT_DUE_2ND_HALF IN WS_PROC_LETTER.
	     
        MOVE DUE_DATE_1ST_HALF_FULL IN CALC_SECURED_DUE_LKG TO 
	     DUE_DATE_1ST_HALF IN WS_PROC_LETTER.	
	     
        MOVE DUE_DATE_2ND_HALF_FULL IN CALC_SECURED_DUE_LKG TO 
	     DUE_DATE_2ND_HALF IN WS_PROC_LETTER.
	     
	MOVE TOTAL_DUE IN CALC_SECURED_DUE_LKG TO 
             TOTAL_DUE IN WS_PROC_LETTER.                         

* we need some additional breakdown for the tax due statement

	MOVE TAX_DUE_1ST_HALF IN CALC_SECURED_DUE_LKG TO 
             TAX_DUE_1ST_HALF IN WS_PROC_LETTER.
	
	MOVE TAX_DUE_2ND_HALF IN CALC_SECURED_DUE_LKG TO 
	     TAX_DUE_2ND_HALF IN WS_PROC_LETTER.

	MOVE TAX_DUE IN CALC_SECURED_DUE_LKG TO 
	     TAX_DUE IN WS_PROC_LETTER.

	MOVE INT_DUE_1ST_HALF IN CALC_SECURED_DUE_LKG TO 
	     INT_DUE_1ST_HALF IN WS_PROC_LETTER.

	MOVE INT_DUE_2ND_HALF IN CALC_SECURED_DUE_LKG TO 
	     INT_DUE_2ND_HALF IN WS_PROC_LETTER.

	MOVE INT_DUE IN CALC_SECURED_DUE_LKG TO 
	     INT_DUE IN WS_PROC_LETTER.
		
	MOVE WS_FEES_DUE_1ST_HALF TO 
                FEES_DUE_1ST_HALF IN WS_PROC_LETTER.

	MOVE WS_FEES_DUE_2ND_HALF TO 
		FEES_DUE_2ND_HALF IN WS_PROC_LETTER.

	ADD WS_FEES_DUE_1ST_HALF WS_FEES_DUE_2ND_HALF
	GIVING FEES_DUE IN WS_PROC_LETTER.

	MOVE SPEC_INT_FLG IN DUE_DATA IN CALC_SECURED_DUE_LKG TO 
	     SPEC_INT_FLG IN WS_PROC_LETTER.

	MOVE SPEC_INT_EXPIRE_DATE IN CALC_SECURED_DUE_LKG TO 
	     SPEC_INT_EXPIRE_DATE IN WS_PROC_LETTER.         

GET_SECURED_DUE_EXIT.

/
***************************
* GET_NEXT_MONTH_PMT_DATE *
***************************
* Tar #39232 Change
* Here we figure out what the last day of next month is in julian date format.
* We calculate the 1st day of the month two months ahead and then subtract
* 1 to get the last day of the next month.  This approach will work for all
* months regardless of the number of days in the month and leap years, etc...
*
* For example, assume that the current date is 4/20/2013.  This paragraph first
* calculates the julian date for 6/1/2013 and then subtracts 1 to get the
* date for 5/31/2013.

GET_NEXT_MONTH_PMT_DATE.
	
	MOVE "GET_NEXT_MONTH_PMT_DATE" TO ERR_FUNCTION_LOC.

*set year
        MOVE DISP_YEAR IN GET_CURRENT_DATE_TIME_LKG TO WS_YEAR_X.
	IF DISP_MONTH IN GET_CURRENT_DATE_TIME_LKG = "NOV" OR
	   DISP_MONTH IN GET_CURRENT_DATE_TIME_LKG = "DEC" THEN
		ADD 1, WS_YEAR GIVING SYS_YEAR IN CALJUL_LKG
	ELSE
		MOVE WS_YEAR TO SYS_YEAR IN CALJUL_LKG
	END-IF.

*set month

	EVALUATE DISP_MONTH IN GET_CURRENT_DATE_TIME_LKG
	
	   WHEN "JAN"
	        MOVE "MAR" TO SYS_MONTH IN CALJUL_LKG
	  
	   WHEN "FEB"
	        MOVE "APR" TO SYS_MONTH IN CALJUL_LKG
	  
	   WHEN "MAR"
	        MOVE "MAY" TO SYS_MONTH IN CALJUL_LKG

	   WHEN "APR"
	        MOVE "JUN" TO SYS_MONTH IN CALJUL_LKG

	   WHEN "MAY"
	        MOVE "JUL" TO SYS_MONTH IN CALJUL_LKG
 
	   WHEN "JUN"
		MOVE "AUG" TO SYS_MONTH IN CALJUL_LKG

           WHEN "JUL"
		MOVE "SEP" TO SYS_MONTH IN CALJUL_LKG

	   WHEN "AUG"
		MOVE "OCT" TO SYS_MONTH IN CALJUL_LKG

           WHEN "SEP"
		MOVE "NOV" TO SYS_MONTH IN CALJUL_LKG

	   WHEN "OCT"
		MOVE "DEC" TO SYS_MONTH IN CALJUL_LKG

	   WHEN "NOV"
		MOVE "JAN" TO SYS_MONTH IN CALJUL_LKG

	   WHEN "DEC"
		MOVE "FEB" TO SYS_MONTH IN CALJUL_LKG
	
        END-EVALUATE.	       

*set day 

	MOVE 1 TO SYS_DAY IN CALJUL_LKG.
        
	CALL "CALJUL" USING CALJUL_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN 
		DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		        "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
			"ERROR CONVERTING FROM CALENDAR TO JULIAN."         
	END-IF.
	SUBTRACT 1 FROM OUT_JUL_DATE IN CALJUL_LKG
		GIVING WS_NEXT_MONTH_PMT_DATE.

GET_NEXT_MONTH_PMT_DATE_EXIT.

/


* ***************** *
* GET_RES_PHASE_REC *
* ***************** *

GET_RES_PHASE_REC.

    SET RO_TRANS TO TRUE.
    PERFORM START_TRANS THRU START_TRANS_EXIT.

&RDB& FOR L IN PROPERTY.RES_PHASE WITH
&RDB&     L.RES_PHASE_NUM = WS_RES_PHASE_NUM AND
&RDB&     L.TAX_YEAR = WS_TAX_YEAR
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         MOVE "GET_RES_PHASE_REC" TO ERR_FUNCTION_LOC
         MOVE "ERR START FOR ON RES_PHASE" TO ERR_FUNCTION_DETAIL
         GO TO RDB_ERROR
&RDB& END_ERROR
&RDB& GET
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         MOVE "GET_RES_PHASE_REC" TO ERR_FUNCTION_LOC
         MOVE "ERR GETTING RES_PHASE ROW" TO ERR_FUNCTION_DETAIL
         GO TO RDB_ERROR
&RDB& END_ERROR
&RDB& TAX_YEAR IN RES_PHASE_REC = L.TAX_YEAR;
&RDB& RES_PHASE_NUM IN RES_PHASE_REC = L.RES_PHASE_NUM;
&RDB& EDIT_RUN_DATE IN RES_PHASE_REC = L.EDIT_RUN_DATE;
&RDB& UPDATE_RUN_DATE IN RES_PHASE_REC = L.UPDATE_RUN_DATE;
&RDB& DOR_RATE_PCT IN RES_PHASE_REC = L.DOR_RATE_PCT
&RDB& END_GET
&RDB& END_FOR.

    PERFORM COMMIT_TRAN THRU COMMIT_TRAN_EXIT.

GET_RES_PHASE_REC_EXIT.

/

* ***************** *
* GET_JUDGMENT_RATE *
* ***************** *

GET_JUDGMENT_RATE.

    MOVE "NO" TO WS_ITEM_FOUND.

&RDB& FOR P IN JUDGMENT_PARCEL WITH
&RDB&     P.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC
&RDB& AND P.PARCEL_SPLIT = PARCEL_SPLIT IN RES_PHASE_LIST_REC
&RDB& AND P.TAX_YEAR = TAX_YEAR IN RES_PHASE_LIST_REC
&RDB& AND P.RES_PHASE_NUM = RES_PHASE_NUM IN RES_PHASE_LIST_REC
&RDB& AND P.RES_NUM = RES_NUM IN RES_PHASE_LIST_REC
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO GET_JUDGMENT_RATE_EXIT
         ELSE
             MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
             MOVE "ERR STARTING FOR ON JUDGMENT_PARCEL" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& GET
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO GET_JUDGMENT_RATE_EXIT
         ELSE
             MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
             MOVE "ERR GETTING CASE_NUMBER" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& CASE_NUMBER IN JUDGMENT_PARCEL_REC = P.CASE_NUMBER
&RDB& END_GET
      MOVE "YES" TO WS_ITEM_FOUND
&RDB& END_FOR.

    IF WS_ITEM_FOUND = "NO" THEN
*       we got some real problems with the data here.  A Judgment
*       must have a row in JUDGMENT_PARCEL.
*       let's blow up.
        STRING "JUDGMENT W/O JUDGMENT_PARCEL_ROW " DELIMITED BY SIZE,
               WS_CURR_PARCEL_NUM DELIMITED BY SIZE INTO ERR_FUNCTION_DETAIL
        DISPLAY ERR_FUNCTION_DETAIL
        MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
	MOVE REC_NOT_FOUND_ERR_CODE TO RETURN_STATUS
        GO TO HANDLE_ERRORS
    END-IF

* First, let's see if we need to use the JUDGMENT_CASE_EXCEPTION table
    MOVE "NO" TO WS_ITEM_FOUND.

&RDB& FOR JE IN JUDGMENT_CASE_EXCEPTION WITH
&RDB&     JE.CASE_NUMBER = CASE_NUMBER IN JUDGMENT_PARCEL_REC AND
&RDB&     JE.TAX_YEAR = TAX_YEAR IN RES_PHASE_LIST_REC AND
&RDB&     JE.RES_PHASE_NUM = RES_PHASE_NUM IN RES_PHASE_LIST_REC
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO GET_JUDGMENT_RATE_EXIT
         ELSE
             MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
             MOVE "ERR STARTING FOR ON JUDGMENT_CASE_EXCEPTION" TO
                  ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& GET
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO GET_JUDGMENT_RATE_EXIT
         ELSE
             MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
             MOVE "ERR GETTING JUDGMENT_CASE_EXCEPTION" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& JUDGMENT_RATE_PCT IN JUDGMENT_CASE_REC = JE.JUDGMENT_RATE_PCT
&RDB& END_GET
      MOVE "YES" TO WS_ITEM_FOUND
&RDB& END_FOR.

    IF WS_ITEM_FOUND = "NO" THEN

&RDB&   FOR C IN JUDGMENT_CASE WITH
&RDB&       C.CASE_NUMBER = CASE_NUMBER IN JUDGMENT_PARCEL_REC
&RDB&   ON ERROR
           CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
           IF RDB_DEADLOCK THEN
               GO TO GET_JUDGMENT_RATE_EXIT
           ELSE
               MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
               MOVE "ERR STARTING FOR ON JUDGMENT_CASE" TO ERR_FUNCTION_DETAIL
               GO TO RDB_ERROR
           END-IF
&RDB&   END_ERROR
&RDB&   GET
&RDB&   ON ERROR
            CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
            IF RDB_DEADLOCK THEN
                GO TO GET_JUDGMENT_RATE_EXIT
            ELSE
                MOVE "GET_JUDGMENT_RATE" TO ERR_FUNCTION_LOC
                MOVE "ERR GETTING CASE INFO" TO ERR_FUNCTION_DETAIL
                GO TO RDB_ERROR
            END-IF
&RDB&   END_ERROR
&RDB&   JUDGMENT_RATE_PCT IN JUDGMENT_CASE_REC = C.JUDGMENT_RATE_PCT
&RDB&   END_GET
&RDB&   END_FOR

    END-IF.

     DIVIDE JUDGMENT_RATE_PCT IN JUDGMENT_CASE_REC BY 100
         GIVING WS_RES_INT_RATE.

GET_JUDGMENT_RATE_EXIT.



* ************** *
* UPDATE_LIT_FLG *
* ************** *

UPDATE_LIT_FLG.

&RDB& FOR P IN PARCEL_MASTER WITH
&RDB&     P.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC
&RDB& AND P.PARCEL_SPLIT = PARCEL_SPLIT IN RES_PHASE_LIST_REC
&RDB& AND P.TAX_YEAR = TAX_YEAR IN RES_PHASE_LIST_REC
&RDB& AND (P.PARCEL_SEQ_NUM = "0")
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO UPDATE_LIT_FLG_EXIT
         ELSE
             MOVE "UPDATE_LIT_FLG" TO ERR_FUNCTION_LOC
             MOVE "ERR STARTING FOR ON PM" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& MODIFY P USING
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO UPDATE_LIT_FLG_EXIT
         ELSE
             MOVE "UPDATE_LIT_FLG" TO ERR_FUNCTION_LOC
             MOVE "ERR UPDATE PM" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& P.LITIG_PEND_FLG = " "
&RDB& END_MODIFY
&RDB& END_FOR.

UPDATE_LIT_FLG_EXIT.

/

* ********************** *
* UPDATE_LCV_PENALTY_REC *
* ********************** *

UPDATE_LCV_PENALTY_REC.

* Tar 41897, Civil Penalty.
* Let's update the RES_LCV_PENALTY row for this guy.
* We will update the RES_DATE and NA_SEQ_NUM columns here.

	DISPLAY "UPDATE PENALTY INFO FOR PARCEL: ", WS_CURR_PARCEL_NUM.

	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO
	     PARCEL_BOOK_MAP_ITEM IN GET_CURRENT_PARCEL_NA_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
	     PARCEL_SPLIT IN GET_CURRENT_PARCEL_NA_LKG.
*	This routine will return DEADLOCK, pass along to "caller".
	CALL "GET_CURRENT_PARCEL_NA" USING GET_CURRENT_PARCEL_NA_LKG
	                             GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
	    GO TO UPDATE_LCV_PENALTY_REC_EXIT
	END-IF.

	MOVE "NO" TO WS_ITEM_FOUND.

&RDB& FOR R IN RES_LCV_PENALTY WITH
&RDB&     R.PARCEL_BOOK_MAP_ITEM = PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC AND
&RDB&     R.PARCEL_SPLIT = PARCEL_SPLIT IN RES_PHASE_LIST_REC AND
&RDB&     R.TAX_YEAR = TAX_YEAR IN RES_PHASE_LIST_REC AND
&RDB&     R.RES_PHASE_NUM = RES_PHASE_NUM IN RES_PHASE_LIST_REC AND
&RDB&     R.RES_REASON = RES_REASON IN RES_PHASE_LIST_REC
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO UPDATE_LCV_PENALTY_REC_EXIT
         ELSE
             MOVE "UPDATE_LCV_PENALTY_REC" TO ERR_FUNCTION_LOC
             MOVE "ERR START FOR" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& MODIFY R USING
&RDB& ON ERROR
         CALL "CHK_RDB_ERROR" USING RDB$STATUS GIVING RETURN_STATUS
         IF RDB_DEADLOCK THEN
             GO TO UPDATE_LCV_PENALTY_REC_EXIT
         ELSE
             MOVE "UPDATE_LCV_PENALTY_REC" TO ERR_FUNCTION_LOC
             MOVE "ERR ON MODIFY" TO ERR_FUNCTION_DETAIL
             GO TO RDB_ERROR
         END-IF
&RDB& END_ERROR
&RDB& R.RES_DATE = WS_TODAY_ANSI;
&RDB& R.NA_SEQ_NUM = NA_SEQ_NUM IN GET_CURRENT_PARCEL_NA_LKG;
&RDB& END_MODIFY
      MOVE "YES" TO WS_ITEM_FOUND
&RDB& END_FOR.

    IF WS_ITEM_FOUND = "NO" THEN
*       SOMETHING AINT RIGHT, LET'S STOP THE SHOW
        MOVE SPACES TO ERR_FUNCTION_DETAIL
        STRING "LCV PENALTY RESO W/NO RES_LCV_PENALTY ROW " DELIMITED BY SIZE,
            WS_CURR_PARCEL_NUM DELIMITED BY SIZE INTO ERR_FUNCTION_DETAIL
        DISPLAY ERR_FUNCTION_DETAIL
        MOVE "UPDATE_LCV_PENALTY_REC" TO ERR_FUNCTION_LOC
        MOVE REC_NOT_FOUND_ERR_CODE TO RETURN_STATUS
        GO TO HANDLE_ERRORS
    END-IF.


UPDATE_LCV_PENALTY_REC_EXIT.


/
*************************
* PROCESS_SINGLE_LETTER *
*************************
* ok, let's figure out what type of letter we need to write out. 
* this code is specifically for exemptions and other single parcel resos. 

PROCESS_SINGLE_LETTER.
              	
	PERFORM INIT_RES_LETTER THRU INIT_RES_LETTER_EXIT.

	MOVE "PROCESS_SINGLE_LETTER" TO ERR_FUNCTION_LOC.

*       SKIP THOSE JUDGEMENTS
	IF JUDGEMENT IN WS_PROC_LETTER THEN
		GO TO PROCESS_SINGLE_LETTER_EXIT 
	END-IF.

PROCESS_EXEMPTION_STATUS_CHG.

	IF EXEMPT_STATUS_CHG IN WS_PROC_LETTER THEN

*  FULL EXEMPTS
		IF FULL_EXEMPT IN WS_PROC_LETTER THEN
		
		    EVALUATE TRUE 
			
			WHEN NO_EFFECT_RESULT IN WS_PROC_LETTER  
		        WHEN OVER_UNDER_RESULT IN WS_PROC_LETTER  
			    SET EXEMPT IN WS_RES_LETTER_TYPE TO TRUE 
                            PERFORM WRITE_EXEMPT_LETTER THRU
			    	    WRITE_EXEMPT_LETTER_EXIT
 	        
		        WHEN REFUND_RESULT IN WS_PROC_LETTER 
			    IF REFUND_CLERK_ID IN WS_PROC_LETTER = "MO" OR
			       TITLE_CO_FLG IN WS_PROC_LETTER = "Y" THEN
                                SET EXEMPT_3RD_PARTY_REFUND IN 
			            WS_RES_LETTER_TYPE TO TRUE 
				PERFORM WRITE_3RD_PTY_REF_LETTER THRU
				 	WRITE_3RD_PTY_REF_LETTER_EXIT
                            ELSE                                            
	                        SET EXEMPT_REFUND IN 
			            WS_RES_LETTER_TYPE TO TRUE
			        PERFORM WRITE_REFUND_LETTER THRU
				        WRITE_REFUND_LETTER_EXIT 
		            END-IF

                        WHEN LIT_IMPOUND_RESULT IN WS_PROC_LETTER 
		        WHEN RES_IMPOUND_RESULT IN WS_PROC_LETTER 
		        WHEN PREPMT_RESULT IN WS_PROC_LETTER           
			    SET EXEMPT_REFUND_CHECK IN 
				WS_RES_LETTER_TYPE TO TRUE
			    PERFORM WRITE_REFUND_CHECK_LETTER THRU
				    WRITE_REFUND_CHECK_LETTER_EXIT
                        			
		    END-EVALUATE
			
		    GO TO PROCESS_SINGLE_LETTER_EXIT
		
		END-IF

*  NON-EXEMPTS 
  		IF NOT PART_EXEMPT IN WS_PROC_LETTER THEN
			GO TO PROCESS_NON_EXEMPT_RESO
		END-IF

*  PART EXEMPTS
		                      
		EVALUATE TRUE

		    WHEN UNDER_PAYMENT_RESULT IN WS_PROC_LETTER	
			IF FULL_YEAR IN WS_PROC_LETTER THEN
		    	    SET PART_EXEMPT_FULL_YEAR IN 
			        WS_RES_LETTER_TYPE TO TRUE 
       	        	    PERFORM WRITE_FULL_YEAR_LETTER THRU
				    WRITE_FULL_YEAR_LETTER_EXIT        
			ELSE 
			    SET PART_EXEMPT_2ND_HALF IN 
				WS_RES_LETTER_TYPE TO TRUE
			    PERFORM WRITE_2ND_HALF_LETTER THRU
				    WRITE_2ND_HALF_LETTER_EXIT
	      		END-IF                  

		    WHEN NO_EFFECT_RESULT IN WS_PROC_LETTER 
		    WHEN OVER_UNDER_RESULT IN WS_PROC_LETTER
			SET PART_EXEMPT_ZERO IN 
			    WS_RES_LETTER_TYPE TO TRUE
			PERFORM WRITE_ZERO_LETTER THRU 
		        	WRITE_ZERO_LETTER_EXIT 
	       	    	
		    WHEN REFUND_RESULT IN WS_PROC_LETTER
			IF REFUND_CLERK_ID IN WS_PROC_LETTER = "MO" OR
			   TITLE_CO_FLG IN WS_PROC_LETTER = "Y" THEN
                            SET PART_EXEMPT_3RD_PARTY_REFUND IN 
			        WS_RES_LETTER_TYPE TO TRUE 
			    PERFORM WRITE_3RD_PTY_REF_LETTER THRU
				    WRITE_3RD_PTY_REF_LETTER_EXIT
                        ELSE                                            
			    SET PART_EXEMPT_REFUND IN 
			        WS_RES_LETTER_TYPE TO TRUE
			    PERFORM WRITE_REFUND_LETTER THRU
				    WRITE_REFUND_LETTER_EXIT
			END-IF
		
	            WHEN LIT_IMPOUND_RESULT IN WS_PROC_LETTER 
	            WHEN RES_IMPOUND_RESULT IN WS_PROC_LETTER
		    WHEN PREPMT_RESULT IN WS_PROC_LETTER
			SET PART_EXEMPT_REFUND_CHECK IN 
			    WS_RES_LETTER_TYPE TO TRUE
			PERFORM WRITE_REFUND_CHECK_LETTER THRU
				WRITE_REFUND_CHECK_LETTER_EXIT
	                                               
		END-EVALUATE 

		GO TO PROCESS_SINGLE_LETTER_EXIT
                                      
	END-IF. 


PROCESS_NON_EXEMPT_RESO.
                                                                     	
        EVALUATE TRUE

	    WHEN UNDER_PAYMENT_RESULT IN WS_PROC_LETTER 	
	 	IF FULL_YEAR IN WS_PROC_LETTER THEN
		    SET FULL_YEAR IN WS_RES_LETTER_TYPE TO TRUE
		    PERFORM WRITE_FULL_YEAR_LETTER THRU
		            WRITE_FULL_YEAR_LETTER_EXIT            
		ELSE    
		    SET 2ND_HALF IN WS_RES_LETTER_TYPE TO TRUE
	            PERFORM WRITE_2ND_HALF_LETTER THRU
		            WRITE_2ND_HALF_LETTER_EXIT 
	      	END-IF                  
	
	    WHEN NO_EFFECT_RESULT IN WS_PROC_LETTER 
	    WHEN OVER_UNDER_RESULT IN WS_PROC_LETTER  
		SET ZERO_DUE IN WS_RES_LETTER_TYPE TO TRUE
		PERFORM WRITE_ZERO_LETTER THRU
			WRITE_ZERO_LETTER_EXIT      

	    WHEN REFUND_RESULT IN WS_PROC_LETTER
		IF REFUND_CLERK_ID IN WS_PROC_LETTER = "MO" OR
		   TITLE_CO_FLG IN WS_PROC_LETTER = "Y" THEN
                    SET 3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE TO TRUE 
		    PERFORM WRITE_3RD_PTY_REF_LETTER THRU
			    WRITE_3RD_PTY_REF_LETTER_EXIT
                ELSE                                            
		    SET REFUND IN WS_RES_LETTER_TYPE TO TRUE  
		    PERFORM WRITE_REFUND_LETTER THRU
			    WRITE_REFUND_LETTER_EXIT
		END-IF

	    WHEN LIT_IMPOUND_RESULT IN WS_PROC_LETTER 
	    WHEN RES_IMPOUND_RESULT IN WS_PROC_LETTER
	    WHEN PREPMT_RESULT IN WS_PROC_LETTER 
		SET REFUND_CHECK IN WS_RES_LETTER_TYPE TO TRUE
		PERFORM WRITE_REFUND_CHECK_LETTER THRU
			WRITE_REFUND_CHECK_LETTER_EXIT	
                        	                   
	END-EVALUATE.   
                       
PROCESS_SINGLE_LETTER_EXIT.


/
***********************
* MOVE_ENCLOSURE_DATA *
***********************
* the reso team has been manually printing tax due printouts from nexTIS parcel 
* inquiry to supplement all BTX letters and CTX exempt letters (all CTX exempt
* varieties). This is very time-consuming and lame.  Res letters to the rescue!
* Before the letter record is written out we are going to add some data to it
* to support the tax due statement.  If the letter is a 3rd Party refund  
* we are also going to send a statement with the taxpayer's 
* parcel number and current name address to the 3rd party.  This data 
* is already in the record at this point, so we don't have to add any 
* additional processing.  Note: it is possible to derive 3 documents from
* one LP record: res letter, tax due statement and a cna verify statement. 
* We already have most of the data we need, what you will see below 
* relates mostly to the breakdown of tax, interest and fees due.   

MOVE_ENCLOSURE_DATA.

	MOVE "MOVE_ENCLOSURE_DATA" TO ERR_FUNCTION_LOC.

* if we have a current tax letter and it isn't exempt then we don't want to 
* include any enclosures; else, lets do it!

	IF CTX_BTX_VAL IN LETTER_INPUT_REC = "CTX" AND 
           RESO_TYPE IN LETTER_INPUT_REC NOT = "EXEMPT" THEN 
               GO TO MOVE_ENCLOSURE_DATA_EXIT
	END-IF. 
        
* we may already have this data, but we may not depending on the letter.
* let's just move it in again anyway it shouldn't hurt anything and it's not
* worth it to add processing that moves only what the rec doesn't have.   
* --------------------------------------------------------------------------
        	
	MOVE AMT_DUE_1ST_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_DUE_1ST_HALF IN LETTER_INPUT_REC.

        MOVE AMT_DUE_2ND_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_DUE_2ND_HALF IN LETTER_INPUT_REC. 
	
	MOVE DUE_DATE_1ST_HALF IN WS_PROC_LETTER TO
	     DUE_DATE_1ST_HALF IN LETTER_INPUT_REC.     

	MOVE DUE_DATE_2ND_HALF IN WS_PROC_LETTER TO 
	     DUE_DATE_2ND_HALF IN LETTER_INPUT_REC.     
                                                               
	MOVE TOTAL_DUE IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO TOTAL_DUE IN LETTER_INPUT_REC.
* --------------------------------------------------------------------------   
	
	EVALUATE TRUE
 
           WHEN FULL_EXEMPT IN WS_PROC_LETTER  
	       MOVE "Full" TO EXEMPT_CODE_DESC IN LETTER_INPUT_REC
	
           WHEN PART_EXEMPT IN WS_PROC_LETTER
	       MOVE "Partial" TO EXEMPT_CODE_DESC IN LETTER_INPUT_REC
           
	   WHEN OTHER 
               MOVE SPACES TO EXEMPT_CODE_DESC IN LETTER_INPUT_REC
	
	END-EVALUATE.

	MOVE AREA_CODE IN POST_NEW_TAX_LKG TO 
	     AREA_CODE IN LETTER_INPUT_REC. 

	MOVE MTG_CODE IN POST_NEW_TAX_LKG TO 
	     MTG_CODE IN LETTER_INPUT_REC.
	
	MOVE LOAN_NUM IN POST_NEW_TAX_LKG TO 
 	     LOAN_NUM IN LETTER_INPUT_REC. 
       
	MOVE ASSESSED_TAX IN POST_NEW_TAX_LKG TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO ASSESSED_TAX IN LETTER_INPUT_REC. 
	
	IF ASSESSED_TAX IN POST_NEW_TAX_LKG > 
           MINIMUM_FULL_TAX IN GET_MINIMUM_FULL_TAX_LKG THEN 
		DIVIDE ASSESSED_TAX IN POST_NEW_TAX_LKG BY 2 
                GIVING WS_TEMP_AMT ROUNDED
		MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z 
		MOVE WS_LP_AMT TO HALF_TAX IN LETTER_INPUT_REC
        END-IF. 

	MOVE TAX_DUE_1ST_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO TAX_DUE_1ST_HALF IN LETTER_INPUT_REC. 

	MOVE TAX_DUE_2ND_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO TAX_DUE_2ND_HALF IN LETTER_INPUT_REC. 

	MOVE TAX_DUE IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO TAX_DUE IN LETTER_INPUT_REC. 

	MOVE INT_DUE_1ST_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO INT_DUE_1ST_HALF IN LETTER_INPUT_REC. 

	MOVE INT_DUE_2ND_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO INT_DUE_2ND_HALF IN LETTER_INPUT_REC. 

	MOVE INT_DUE IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO INT_DUE IN LETTER_INPUT_REC. 

        MOVE FEES_DUE_1ST_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO FEES_DUE_1ST_HALF IN LETTER_INPUT_REC. 

	MOVE FEES_DUE_2ND_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO FEES_DUE_2ND_HALF IN LETTER_INPUT_REC. 

	MOVE FEES_DUE IN WS_PROC_LETTER TO WS_TEMP_AMT. 
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO FEES_DUE IN LETTER_INPUT_REC. 

        IF SPEC_INT_FLG IN WS_PROC_LETTER = "Y" THEN 
           MOVE INT_DUE IN LETTER_INPUT_REC TO 
                SPEC_INT_AMT IN LETTER_INPUT_REC
	   
	   INITIALIZE DATE_CONVERT_LKG
	   SET IN_JULIAN IN INPUT_DATE_TYPE IN DATE_CONVERT_LKG TO TRUE
  	   MOVE SPEC_INT_EXPIRE_DATE IN WS_PROC_LETTER TO 
		JUL_DATE IN DATE_CONVERT_LKG  
	   CALL "DATE_CONVERT" USING DATE_CONVERT_LKG GIVING RETURN_STATUS
	   IF RETURN_STATUS < 1 THEN 
		DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		        "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
			"ERROR CONVERTING FROM JULIAN TO FULL."         
	   END-IF		          
	   MOVE DATE_FULL IN DATE_CONVERT_LKG TO 
	        SPEC_INT_EXPIRE_DATE IN LETTER_INPUT_REC
	END-IF.  

	ADD 1 TO WS_TDS_COUNT.   
		                     	               
MOVE_ENCLOSURE_DATA_EXIT. 

/
**************************
* WRITE_FULL_YEAR_LETTER *
**************************
WRITE_FULL_YEAR_LETTER.
                            
	MOVE "WRITE_FULL_YEAR_LETTER" TO ERR_FUNCTION_LOC.

	INITIALIZE LETTER_INPUT_REC. 

	MOVE "FULLYEAR" TO LP_TYPE IN LETTER_INPUT_REC.
	
	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		FETCH_CURRENT_NAME_ADDR_EXIT.       
        
	IF WS_DEADLOCK = "Y" THEN GO TO WRITE_FULL_YEAR_LETTER_EXIT.
                        	
	IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       PERFORM MOVE_PAYER_NAME_ADDR THRU
		       MOVE_PAYER_NAME_ADDR_EXIT
	END-IF.

        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.
   
        PERFORM MOVE_LETTER_TEXT THRU 
		MOVE_LETTER_TEXT_EXIT.
	
	MOVE "WRITE_FULL_YEAR_LETTER" TO ERR_FUNCTION_LOC.
                           
        MOVE AMT_DUE_1ST_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT.
        MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_DUE_1ST_HALF IN LETTER_INPUT_REC.

	MOVE AMT_DUE_2ND_HALF IN WS_PROC_LETTER TO WS_TEMP_AMT.
        MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_DUE_2ND_HALF IN LETTER_INPUT_REC. 
	
	MOVE DUE_DATE_1ST_HALF IN WS_PROC_LETTER TO          
             DUE_DATE_1ST_HALF IN LETTER_INPUT_REC.

	MOVE DUE_DATE_2ND_HALF IN WS_PROC_LETTER TO 
	     DUE_DATE_2ND_HALF IN LETTER_INPUT_REC.

* TAR #66733 - The new full year balance should only reflect tax and fees
*	due when computing for dates prior to the full year interest date.
*	Otherwise, use the total amount due including interest.

	IF CTX IN WS_PROC_LETTER AND
	   WS_LETTER_CALC_DATE < WS_FULL_YEAR_INT_DATE_JUL THEN
		ADD TAX_DUE IN WS_PROC_LETTER,
		    FEES_DUE IN WS_PROC_LETTER
			GIVING WS_TEMP_AMT
	ELSE
	        MOVE TOTAL_DUE IN WS_PROC_LETTER TO WS_TEMP_AMT
	END-IF.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO TOTAL_DUE IN LETTER_INPUT_REC.
	
	PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.

	PERFORM STORE_LETTER THRU
		STORE_LETTER_EXIT.
        
        IF WS_DEADLOCK = "Y" THEN GO TO WRITE_FULL_YEAR_LETTER_EXIT.
	           	                                               
WRITE_FULL_YEAR_LETTER_EXIT.


/
*************************
* WRITE_2ND_HALF_LETTER *
*************************
        
WRITE_2ND_HALF_LETTER.

        MOVE "WRITE_2ND_HALF_LETTER" TO ERR_FUNCTION_LOC.

	INITIALIZE LETTER_INPUT_REC. 

	MOVE "2NDHALF" TO LP_TYPE IN LETTER_INPUT_REC.
	
	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		FETCH_CURRENT_NAME_ADDR_EXIT.       
        
	IF WS_DEADLOCK = "Y" THEN GO TO WRITE_2ND_HALF_LETTER_EXIT.  
                       	
	IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       PERFORM MOVE_PAYER_NAME_ADDR THRU
		       MOVE_PAYER_NAME_ADDR_EXIT
	END-IF
                                                      	
        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.
   
        PERFORM MOVE_LETTER_TEXT THRU 
		MOVE_LETTER_TEXT_EXIT.
	
	MOVE "WRITE_2ND_HALF_LETTER" TO ERR_FUNCTION_LOC.
               
        MOVE TOTAL_DUE IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
        MOVE WS_LP_AMT TO TOTAL_DUE IN LETTER_INPUT_REC. 
                         
        MOVE DUE_DATE_2ND_HALF IN WS_PROC_LETTER TO
	     DUE_DATE_2ND_HALF IN LETTER_INPUT_REC. 
                       
	PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.

        PERFORM STORE_LETTER THRU
	 	STORE_LETTER_EXIT.
        
	IF WS_DEADLOCK = "Y" THEN GO TO WRITE_2ND_HALF_LETTER_EXIT.
                                              
WRITE_2ND_HALF_LETTER_EXIT.


/
*********************
* WRITE_ZERO_LETTER *
*********************
WRITE_ZERO_LETTER.
        
        MOVE "WRITE_ZERO_LETTER" TO ERR_FUNCTION_LOC.

	INITIALIZE LETTER_INPUT_REC. 
        	
	MOVE "ZERO" TO LP_TYPE IN LETTER_INPUT_REC.
        	
	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		FETCH_CURRENT_NAME_ADDR_EXIT.       
        
	IF WS_DEADLOCK = "Y" THEN GO TO WRITE_ZERO_LETTER_EXIT.                 
                       	
	IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       PERFORM MOVE_PAYER_NAME_ADDR THRU
		       MOVE_PAYER_NAME_ADDR_EXIT
	END-IF

        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.
   
        PERFORM MOVE_LETTER_TEXT THRU 
		MOVE_LETTER_TEXT_EXIT.
	                       
	PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.
              
        PERFORM STORE_LETTER THRU
 		STORE_LETTER_EXIT.
                                        		
        IF WS_DEADLOCK = "Y" THEN GO TO WRITE_ZERO_LETTER_EXIT.
	               	
WRITE_ZERO_LETTER_EXIT.


/
***********************
* WRITE_REFUND_LETTER *
***********************
WRITE_REFUND_LETTER.

	MOVE "WRITE_REFUND_LETTER" TO ERR_FUNCTION_LOC.

	INITIALIZE LETTER_INPUT_REC. 

	MOVE "REFUND" TO LP_TYPE IN LETTER_INPUT_REC.
        	
	PERFORM MOVE_PAYER_NAME_ADDR THRU
		MOVE_PAYER_NAME_ADDR_EXIT.        
        	
	IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		   	FETCH_CURRENT_NAME_ADDR_EXIT
		IF WS_DEADLOCK = "Y" THEN
		   GO TO WRITE_REFUND_LETTER_EXIT
		END-IF 
	END-IF. 	

        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.
   
        PERFORM MOVE_LETTER_TEXT THRU 
		MOVE_LETTER_TEXT_EXIT.

	MOVE "WRITE_REFUND_LETTER" TO ERR_FUNCTION_LOC.
              
	MOVE AMT_IMPOUNDED IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_IMPOUNDED IN LETTER_INPUT_REC.
                                               
        PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.
	                     
        PERFORM STORE_LETTER THRU
 		STORE_LETTER_EXIT.
                                        		
        IF WS_DEADLOCK = "Y" THEN GO TO WRITE_REFUND_LETTER_EXIT.  

WRITE_REFUND_LETTER_EXIT.


/
****************************
* WRITE_3RD_PTY_REF_LETTER *
****************************
WRITE_3RD_PTY_REF_LETTER.

	MOVE "WRITE_3RD_PTY_REF_LETTER" TO ERR_FUNCTION_LOC.
        
	INITIALIZE LETTER_INPUT_REC. 
	
	MOVE "3PTYREF" TO LP_TYPE IN LETTER_INPUT_REC.
               	
	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		FETCH_CURRENT_NAME_ADDR_EXIT.

	IF WS_DEADLOCK = "Y" THEN GO TO WRITE_3RD_PTY_REF_LETTER_EXIT.	

	IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       PERFORM MOVE_PAYER_NAME_ADDR THRU
		       MOVE_PAYER_NAME_ADDR_EXIT
	END-IF
                                                 
        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.
	
	PERFORM MOVE_LETTER_TEXT THRU
		MOVE_LETTER_TEXT_EXIT.

        MOVE "WRITE_3RD_PTY_REF_LETTER" TO ERR_FUNCTION_LOC. 
	
	MOVE AMT_IMPOUNDED IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_IMPOUNDED IN LETTER_INPUT_REC.
                                               
	PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.
                  
        PERFORM STORE_LETTER THRU
 		STORE_LETTER_EXIT.
        
        IF WS_DEADLOCK = "Y" THEN GO TO WRITE_3RD_PTY_REF_LETTER_EXIT.    

WRITE_3RD_PTY_REF_LETTER_EXIT.

/
*****************************
* WRITE_REFUND_CHECK_LETTER *
*****************************
WRITE_REFUND_CHECK_LETTER.

        MOVE "WRITE_REFUND_CHECK_LETTER" TO ERR_FUNCTION_LOC. 

	INITIALIZE LETTER_INPUT_REC. 
	
	MOVE "REFCHECK" TO LP_TYPE IN LETTER_INPUT_REC.
	
	PERFORM MOVE_PAYER_NAME_ADDR THRU
		MOVE_PAYER_NAME_ADDR_EXIT.
        
	IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		   	FETCH_CURRENT_NAME_ADDR_EXIT
		IF WS_DEADLOCK = "Y" THEN
		   GO TO WRITE_REFUND_CHECK_LETTER_EXIT
		END-IF 
	END-IF. 

        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.

	PERFORM MOVE_LETTER_TEXT THRU
		MOVE_LETTER_TEXT_EXIT.
	
        MOVE "WRITE_REFUND_CHECK_LETTER" TO ERR_FUNCTION_LOC. 
	
	MOVE AMT_IMPOUNDED IN WS_PROC_LETTER TO WS_TEMP_AMT.
	MOVE WS_TEMP_AMT TO WS_TEMP_AMT_Z.
	MOVE WS_LP_AMT TO AMT_IMPOUNDED IN LETTER_INPUT_REC.
                                               
	PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.
                  
        PERFORM STORE_LETTER THRU
 		STORE_LETTER_EXIT.
        
        IF WS_DEADLOCK = "Y" THEN GO TO WRITE_REFUND_CHECK_LETTER_EXIT.
	          
WRITE_REFUND_CHECK_LETTER_EXIT.
 

/
***********************
* WRITE_EXEMPT_LETTER *
***********************              	
WRITE_EXEMPT_LETTER.

	MOVE "WRITE_EXEMPT_LETTER" TO ERR_FUNCTION_LOC.

	INITIALIZE LETTER_INPUT_REC. 

	MOVE "EXEMPT" TO LP_TYPE IN LETTER_INPUT_REC.
	                                  
	PERFORM FETCH_CURRENT_NAME_ADDR THRU
		FETCH_CURRENT_NAME_ADDR_EXIT.
	
	IF WS_DEADLOCK = "Y" THEN GO TO WRITE_EXEMPT_LETTER_EXIT.

        IF PAYER_NA_1 IN LETTER_INPUT_REC = SPACES AND 
	   PAYER_NA_2 IN LETTER_INPUT_REC = SPACES THEN
	       PERFORM MOVE_PAYER_NAME_ADDR THRU
		       MOVE_PAYER_NAME_ADDR_EXIT
	END-IF

        PERFORM MOVE_THE_COMMON_STUFF THRU
		MOVE_THE_COMMON_STUFF_EXIT.
                                       
	PERFORM MOVE_ENCLOSURE_DATA THRU
		MOVE_ENCLOSURE_DATA_EXIT.	
                                                    
        PERFORM STORE_LETTER THRU
 		STORE_LETTER_EXIT.
                                        		
        IF WS_DEADLOCK = "Y" THEN GO TO WRITE_EXEMPT_LETTER_EXIT.       

WRITE_EXEMPT_LETTER_EXIT.


/
*************************
* MOVE_THE_COMMON_STUFF *
*************************
MOVE_THE_COMMON_STUFF.
	
	MOVE "MOVE_THE_COMMON_STUFF" TO ERR_FUNCTION_LOC.

	MOVE WS_DATE_FULL TO CREATE_DATE IN LETTER_INPUT_REC.    

* =============================================================================
* we need to make sure the tax year and phase num values are trimmed 
* before we put them in the rec.  This allows us to be more specific 
* in the where clause of our Access queries. (ie allowing us to check
* for exact tax year and phase values versus a like clause with wildcards).  
	
* trim the year

        MOVE TAX_YEAR IN RES_PHASE_LIST_REC TO WS_TAX_YR_INT.
	CALL "STR$FIND_FIRST_NOT_IN_SET"
	      USING BY DESCRIPTOR WS_TAX_YR
              	    BY DESCRIPTOR SPACE
	      GIVING WS_POS.                                 
	
	MOVE WS_TAX_YR(WS_POS:4) TO 
	     TAX_YEAR IN LETTER_INPUT_REC. 

* trim the phase left side

	MOVE RES_PHASE_NUM IN RES_PHASE_LIST_REC TO WS_PHASE_Z.
	CALL "STR$FIND_FIRST_NOT_IN_SET"
	      USING BY DESCRIPTOR WS_PHASE	
              	    BY DESCRIPTOR SPACE
	      GIVING WS_POS. 
	
	COMPUTE WS_LENGTH = 6 - WS_POS.  
        MOVE WS_PHASE(WS_POS:WS_LENGTH) TO WS_PHASE.   
                                      
* trim the phase right side  

	CALL "STR$TRIM" USING BY DESCRIPTOR WS_PHASE
                              BY DESCRIPTOR WS_PHASE 
                              BY REFERENCE  WS_LENGTH
                        GIVING RETURN_STATUS.          
	
        MOVE WS_PHASE(1:WS_LENGTH) TO
	     RES_PHASE_NO IN LETTER_INPUT_REC.    

* =============================================================================
		
	MOVE RES_NUM IN RES_PHASE_LIST_REC TO 
	     RES_NUM IN LETTER_INPUT_REC.
        
	MOVE RES_REASON IN WS_PROC_LETTER TO 
             RES_REASON IN LETTER_INPUT_REC.
  
	MOVE "Parcel Number:" TO PARCEL_LABEL_1 IN LETTER_INPUT_REC.

	MOVE BOOK IN SUMMARY_RPT_LINE TO BOOK IN WS_PARCEL_NO.
	MOVE DASH1 IN SUMMARY_RPT_LINE TO DASH1 IN WS_PARCEL_NO.
	MOVE MAP IN SUMMARY_RPT_LINE TO MAP IN WS_PARCEL_NO.
	MOVE DASH2 IN SUMMARY_RPT_LINE TO DASH2 IN WS_PARCEL_NO.
	MOVE ITEM IN SUMMARY_RPT_LINE TO ITEM IN WS_PARCEL_NO.

	MOVE WS_PARCEL_NO TO PARCEL_BMI_1 IN LETTER_INPUT_REC.

	MOVE SPLIT IN SUMMARY_RPT_LINE TO PARCEL_SPLIT_1 IN LETTER_INPUT_REC.   

	MOVE TCD IN GET_PARCEL_LKG TO TCD_1 IN LETTER_INPUT_REC. 

* if this is a current tax and the new tax is greater than or equal to the 
* mimimum payment threshold (currently $2.00) and delinquent notices have 
* not been sent then we want to show "enclosed is your corrected tax 
* statement...".
* the issue here is that we are essentially hardcoding a date of June 1st of 
* the year because delinquent notices are not sent on any set date.  The date
* varies from year to year, but it is usually "around" June 1st.   
                                         	        
	ADD 1, CURRENT_YEAR IN GBL_PARAM_VALUES GIVING 
               SYS_YEAR IN CALJUL_LKG. 
	MOVE "JUN" TO SYS_MONTH IN CALJUL_LKG. 
	MOVE 1 TO SYS_DAY IN CALJUL_LKG. 
	CALL "CALJUL" USING CALJUL_LKG GIVING RETURN_STATUS.
	IF RETURN_STATUS < 1 THEN
		DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		        "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
			"ERROR CONVERTING FROM CALENDAR TO JULIAN."          
	END-IF.		      
        MOVE OUT_JUL_DATE IN CALJUL_LKG TO WS_DELINQ_NOTICE_DATE. 

	IF CTX IN WS_PROC_LETTER AND
	   (ASSESSED_TAX IN REAPPLY_PMTS_LKG >= CTX_PMT_THRESHOLD 
           IN GBL_PARAM_VALUES) AND 
           (JUL_DATE IN GET_CURRENT_DATE_TIME_LKG < WS_DELINQ_NOTICE_DATE) THEN
	       MOVE WS_TAX_BILL_TEXT TO PARAGRAPH_2 IN LETTER_INPUT_REC
	END-IF. 


	EVALUATE TRUE

	    WHEN FULL_YEAR IN WS_RES_LETTER_TYPE 
   	    WHEN 2ND_HALF IN WS_RES_LETTER_TYPE
	    WHEN ZERO_DUE IN WS_RES_LETTER_TYPE
	    WHEN REFUND IN WS_RES_LETTER_TYPE
	    WHEN 3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE
	    WHEN REFUND_CHECK IN WS_RES_LETTER_TYPE 
    	         MOVE "STANDARD" TO RESO_TYPE IN LETTER_INPUT_REC
	
	    WHEN PART_EXEMPT_FULL_YEAR IN WS_RES_LETTER_TYPE
	    WHEN PART_EXEMPT_2ND_HALF IN WS_RES_LETTER_TYPE	
	    WHEN PART_EXEMPT_ZERO IN WS_RES_LETTER_TYPE	
	    WHEN PART_EXEMPT_REFUND IN WS_RES_LETTER_TYPE	
	    WHEN PART_EXEMPT_3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE
	    WHEN PART_EXEMPT_REFUND_CHECK IN WS_RES_LETTER_TYPE	 
		 MOVE "PART EXEMPT" TO RESO_TYPE IN LETTER_INPUT_REC
            	    
	    WHEN EXEMPT_REFUND IN WS_RES_LETTER_TYPE
	    WHEN EXEMPT_3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE 	 
	    WHEN EXEMPT_REFUND_CHECK IN WS_RES_LETTER_TYPE	 
	    WHEN EXEMPT IN WS_RES_LETTER_TYPE      
		 MOVE "EXEMPT" TO RESO_TYPE IN LETTER_INPUT_REC
  	    
	END-EVALUATE.  
	  
        MOVE CTX_BTX_VAL IN WS_PROC_LETTER TO
	     CTX_BTX_VAL IN LETTER_INPUT_REC.
			
        MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO WS_PARCEL_NO_INT. 
	MOVE WS_PARCEL_NO_X TO LETTER_ACT_BMI IN LETTER_INPUT_REC.
	
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO 
             LETTER_ACT_SPLIT IN LETTER_INPUT_REC.

MOVE_THE_COMMON_STUFF_EXIT.


/                  
************************
* MOVE_PAYER_NAME_ADDR * 
************************
MOVE_PAYER_NAME_ADDR.

	MOVE "MOVE_PAYER_NAME_ADDR" TO ERR_FUNCTION_LOC.

	MOVE PAYER_NA_1 IN REAPPLY_PMTS_LKG(2:40) TO 
             PAYER_NA_1 IN LETTER_INPUT_REC.

	MOVE PAYER_NA_2 IN REAPPLY_PMTS_LKG(2:40) TO 
	     PAYER_NA_2 IN LETTER_INPUT_REC. 

	MOVE PAYER_NA_3 IN REAPPLY_PMTS_LKG(2:40) TO 
	     PAYER_NA_3 IN LETTER_INPUT_REC.

	MOVE PAYER_NA_4 IN REAPPLY_PMTS_LKG(2:40) TO 
	     PAYER_NA_4 IN LETTER_INPUT_REC.

	MOVE PAYER_NA_5 IN REAPPLY_PMTS_LKG(2:40) TO 
	     PAYER_NA_5 IN LETTER_INPUT_REC.

	MOVE CITY IN REAPPLY_PMTS_LKG TO 
	     CITY IN LETTER_INPUT_REC.
	
	MOVE STATE IN REAPPLY_PMTS_LKG TO 
	     STATE IN LETTER_INPUT_REC.

	MOVE ZIP IN REAPPLY_PMTS_LKG TO 
	     ZIP IN LETTER_INPUT_REC.
        
	MOVE "MOVE_PAYER_NAME_ADDR" TO ERR_FUNCTION_LOC.

MOVE_PAYER_NAME_ADDR_EXIT.


/
***************************
* FETCH_CURRENT_NAME_ADDR *
***************************

FETCH_CURRENT_NAME_ADDR.
	
	MOVE "FETCH_CURRENT_NAME_ADDR" TO ERR_FUNCTION_LOC.
        
	INITIALIZE GET_CURRENT_NAME_ADDR_LKG.
		
	MOVE PARCEL_BOOK_MAP_ITEM IN RES_PHASE_LIST_REC TO 
		PARCEL_BOOK_MAP_ITEM IN GET_CURRENT_NAME_ADDR_LKG.
	MOVE PARCEL_SPLIT IN RES_PHASE_LIST_REC TO
		PARCEL_SPLIT IN GET_CURRENT_NAME_ADDR_LKG.

        MOVE SPACE TO WS_DEADLOCK.
	
	CALL "GET_REAL_CURRENT_NAME_ADDR" USING GET_CURRENT_NAME_ADDR_LKG
		GIVING RETURN_STATUS.

        IF RETURN_STATUS < 1
                EVALUATE RETURN_STATUS

                   WHEN RDB_DEADLOCK_ERR_CODE
			MOVE "Y" TO WS_DEADLOCK
			GO TO FETCH_CURRENT_NAME_ADDR_EXIT
                   
		   WHEN REC_NOT_FOUND_ERR_CODE
			GO TO FETCH_CURRENT_NAME_ADDR_EXIT

		   WHEN OTHER
			DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		                "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
			        "ERROR GETTING CURRENT NAME ADDRESS."           
			     
		END-EVALUATE
	END-IF.             

	MOVE NAME_ADDR_TEXT IN GET_CURRENT_NAME_ADDR_LKG(1)(2:40) TO 
	     PAYER_NA_1 IN LETTER_INPUT_REC.     
		
	MOVE NAME_ADDR_TEXT IN GET_CURRENT_NAME_ADDR_LKG(2)(2:40) TO 
	     PAYER_NA_2 IN LETTER_INPUT_REC.

	MOVE NAME_ADDR_TEXT IN GET_CURRENT_NAME_ADDR_LKG(3)(2:40) TO
	     PAYER_NA_3 IN LETTER_INPUT_REC.   
	
	MOVE NAME_ADDR_TEXT IN GET_CURRENT_NAME_ADDR_LKG(4)(2:40) TO 
	     PAYER_NA_4 IN LETTER_INPUT_REC.     
	
	MOVE NAME_ADDR_TEXT IN GET_CURRENT_NAME_ADDR_LKG(5)(2:40) TO 
	     PAYER_NA_5 IN LETTER_INPUT_REC.
  
	MOVE CITY IN GET_CURRENT_NAME_ADDR_LKG TO
	     CITY IN LETTER_INPUT_REC.          
        
        MOVE STATE IN GET_CURRENT_NAME_ADDR_LKG TO
   	     STATE IN LETTER_INPUT_REC.                              
      	                                             
	MOVE ZIP IN GET_CURRENT_NAME_ADDR_LKG TO
     	     ZIP IN LETTER_INPUT_REC. 
      
FETCH_CURRENT_NAME_ADDR_EXIT.

/
********************
* MOVE_LETTER_TEXT *
********************
* OK ladies we have some semi-Ryan-Jitsu going on here according to bob juan.
* In order for our letters to have the ability to support muliple resolution 
* situations, they must morph the text.  This means that the first few 
* sentences in the first paragraph are "soft".  For example, the full year
* letter word document has a mailmerge field titled "paragraph_1". We need to 
* put the appropriate text in there, and that text is different for each
* full year letter type (standard, part exempt, common area, whatever...).
* So, basically all we are doing below is getting the text we need for a 
* specific letter out of the array. This is easily accomplished by 
* corresponding the LETTER_TEXT_ID field in the DB with a bunch of 88's in the
* WS_RES_LETTER_TYPE structure. Then comes the fun part! :-) Once we have the 
* appropriate text for our letter we still may have to fill it with some data. 
* This text may have any number of tags in it that must be filled in with data
* (currently just a tax year most times).  A special routine was written to 
* facilitate this replacement of tags with data, REPLACE_STRING. 
* Once the tag has been replaced with the corresponding data we are done.

* You might be asking yourself why the TAX_BILL type is in WS_RES_LETTER_TYPE.
* The TAX_BILL type isn't associated with a specific letter, it really
* designates the type of text we want to get. This was thrown in because this
* routine uses the letter type to access it. 
* Here's the scoop. Our letters not only morph by the type of resolution, they 
* also support both CTX (Current TaX) and BTX (Back TaX).  In CTX letters we 
* need to display something like this: 'enclosed is your tax bill...' in 
* the beginning of the second paragraph.  So, this tax bill text is stored in 
* the database, and it's in our table in WS_RES_LETTER_TEXT.             

MOVE_LETTER_TEXT.

	MOVE "MOVE_LETTER_TEXT" TO ERR_FUNCTION_LOC.

	SET LETTER_INDEX TO 1.

	SEARCH MY_TABLE IN WS_RES_LETTER_TEXT
	    
	    AT END
	       	DISPLAY "LETTER TEXT NOT FOUND!"
		DISPLAY "A CODE-SLINGER HAS GONE AWRY..."
	            
	    WHEN LETTER_ID(LETTER_INDEX) = WS_RES_LETTER_TYPE  
		IF TAX_BILL IN WS_RES_LETTER_TYPE THEN
		     MOVE LETTER_TEXT(LETTER_INDEX) TO WS_TAX_BILL_TEXT
		ELSE
		     INITIALIZE REPLACE_STRING_LKG
	             MOVE LETTER_TEXT(LETTER_INDEX) TO SOURCE_STRING IN 
		    	  REPLACE_STRING_LKG
	             MOVE 1 TO START_POSITION IN REPLACE_STRING_LKG
		     MOVE "<<taxyear>>" TO TAG_TO_FIND 
		     MOVE TAX_YEAR IN GET_PARCEL_LKG TO 
		    	  REPLACE_WITH IN REPLACE_STRING_LKG
	             CALL "REPLACE_STRING" USING REPLACE_STRING_LKG 
		     GIVING RETURN_STATUS 
		 
	             IF RETURN_STATUS < 1
		        DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		                "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
                      	        "ERROR RETURNED FROM REPLACE_STRING "
			        "SUBROUTINE. TRYING TO REPLACE <<taxyear>> "
				"IN LETTER " LETTER_DESC(LETTER_INDEX) 
                     END-IF             

                     MOVE SOURCE_STRING IN REPLACE_STRING_LKG TO 
		    	  PARAGRAPH_1 IN LETTER_INPUT_REC
               END-IF 

	END-SEARCH. 	
	
MOVE_LETTER_TEXT_EXIT.

/
****************
* STORE_LETTER *
****************
* The letter data is written to the data file and the appropriate letter
* counter is incremented.  No rocket science here.                      

STORE_LETTER.

  	MOVE "STORE_LETTER" TO ERR_FUNCTION_LOC.
	
* before we store, let's check to see if the record has a missing city,
* state or zip.  If so, let's write a friendly message in the log. 

	IF CITY IN LETTER_INPUT_REC = SPACES OR  
	   STATE IN LETTER_INPUT_REC = SPACES OR 
	   ZIP IN LETTER_INPUT_REC = SPACES THEN    
               DISPLAY "<**LETTER ERROR**> RES#:" WS_ERR_RES_NUM SPACE 
		       "PARCEL#:" WS_ERR_BMI WS_ERR_SPLIT " - " 
	               "MISSING CITY, STATE OR ZIPCODE." 
        END-IF.

	WRITE LETTER_INPUT_REC. 

	EVALUATE TRUE
	    
	    WHEN FULL_YEAR IN WS_RES_LETTER_TYPE
		 ADD 1 TO FULL_YEAR IN WS_LETTER_COUNTERS
            	                
	    WHEN 2ND_HALF IN WS_RES_LETTER_TYPE
		 ADD 1 TO 2ND_HALF IN WS_LETTER_COUNTERS
            
	    WHEN ZERO_DUE IN WS_RES_LETTER_TYPE
		 ADD 1 TO ZERO_DUE IN WS_LETTER_COUNTERS  

	    WHEN REFUND IN WS_RES_LETTER_TYPE      
		 ADD 1 TO REFUND IN WS_LETTER_COUNTERS   

	    WHEN 3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE
		 ADD 1 TO 3RD_PARTY_REFUND IN WS_LETTER_COUNTERS 

	    WHEN REFUND_CHECK IN WS_RES_LETTER_TYPE       
		 ADD 1 TO REFUND_CHECK IN WS_LETTER_COUNTERS    

            WHEN PART_EXEMPT_FULL_YEAR IN WS_RES_LETTER_TYPE
		 ADD 1 TO PART_EXEMPT_FULL_YEAR IN WS_LETTER_COUNTERS        
	    
	    WHEN PART_EXEMPT_2ND_HALF IN WS_RES_LETTER_TYPE
		 ADD 1 TO PART_EXEMPT_2ND_HALF IN WS_LETTER_COUNTERS
	    	
	    WHEN PART_EXEMPT_ZERO IN WS_RES_LETTER_TYPE
	         ADD 1 TO PART_EXEMPT_ZERO IN WS_LETTER_COUNTERS
            	
            WHEN PART_EXEMPT_REFUND IN WS_RES_LETTER_TYPE 
		 ADD 1 TO PART_EXEMPT_REFUND IN WS_LETTER_COUNTERS
	
	    WHEN PART_EXEMPT_3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE
		 ADD 1 TO PART_EXEMPT_3RD_PARTY_REFUND IN WS_LETTER_COUNTERS

	    WHEN PART_EXEMPT_REFUND_CHECK IN WS_RES_LETTER_TYPE
		 ADD 1 TO PART_EXEMPT_REFUND_CHECK IN WS_LETTER_COUNTERS   

	    WHEN EXEMPT IN WS_RES_LETTER_TYPE
		ADD 1 TO EXEMPT IN WS_LETTER_COUNTERS   

	    WHEN EXEMPT_REFUND IN WS_RES_LETTER_TYPE 			
		 ADD 1 TO EXEMPT_REFUND IN WS_LETTER_COUNTERS
            
	    WHEN EXEMPT_3RD_PARTY_REFUND IN WS_RES_LETTER_TYPE
		 ADD 1 TO EXEMPT_3RD_PARTY_REFUND IN WS_LETTER_COUNTERS
            		    
	    WHEN EXEMPT_REFUND_CHECK IN WS_RES_LETTER_TYPE
		 ADD 1 TO EXEMPT_REFUND_CHECK IN WS_LETTER_COUNTERS

* bob said to put this in even though this code will never execute as long as I
* (Ryan) am maintaining this code.   
 
	    WHEN OTHER 
	         ADD 1 TO UNKNOWN IN WS_LETTER_COUNTERS
		
	END-EVALUATE.                          
            	

STORE_LETTER_EXIT. 


/
*************************
* DISPLAY_LETTER_COUNTS *
*************************

DISPLAY_LETTER_COUNTS.

	OPEN OUTPUT LETTER_TOTAL_RPT.

	MOVE SPACES TO LETTER_TOTAL_RPT_REC.
	STRING
		"LETTER TOTALS FOR PHASE " DELIMITED BY SIZE,
		WS_TAX_YEAR DELIMITED BY SIZE,
		"-" DELIMITED BY SIZE,
		WS_RES_PHASE_NUM DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	DISPLAY " ".
	DISPLAY " ".
	DISPLAY "*******************".
	DISPLAY "* LETTER COUNTERS *".
 	DISPLAY "*******************".  
	DISPLAY " ".
	DISPLAY " ".                  
	DISPLAY "BREAKDOWN BY LETTER VARIATION".
	DISPLAY " ".
	MOVE "BREAKDOWN BY LETTER VARIATION" TO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	MOVE "-----------------------------" TO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	MOVE FULL_YEAR IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  FULL YEAR DUE".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  FULL YEAR DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

        MOVE 2ND_HALF IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  2ND HALF DUE".              
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  2ND HALF DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
        MOVE ZERO_DUE IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  ZERO DUE".              
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  ZERO DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
		
        MOVE REFUND IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  REFUND".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
        MOVE 3RD_PARTY_REFUND IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  3RD PARTY REFUND".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  3RD PARTY REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
	MOVE REFUND_CHECK IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  REFUND CHECK".                   
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  REFUND CHECK" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
	MOVE PART_EXEMPT_FULL_YEAR IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  PART EXEMPT FULL YEAR DUE".              
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  PART EXEMPT FULL YEAR DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

        MOVE PART_EXEMPT_2ND_HALF IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  PART EXEMPT 2ND HALF DUE".              
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  PART EXEMPT 2ND HALF DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

        MOVE PART_EXEMPT_ZERO IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  PART EXEMPT ZERO DUE".              
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  PART EXEMPT ZERO DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
        
	MOVE PART_EXEMPT_REFUND IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  PART EXEMPT REFUND".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  PART EXEMPT REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
	MOVE PART_EXEMPT_3RD_PARTY_REFUND IN WS_LETTER_COUNTERS TO
	     WS_DISPLAY_COUNTER.
        DISPLAY WS_DISPLAY_COUNTER "  PART EXEMPT 3RD PARTY REFUND".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  PART EXEMPT 3RD PARTY REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	MOVE PART_EXEMPT_REFUND_CHECK IN WS_LETTER_COUNTERS TO
	     WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  PART EXEMPT REFUND CHECK".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  PART EXEMPT REFUND CHECK" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

        MOVE EXEMPT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  EXEMPT".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  EXEMPT" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

       	MOVE EXEMPT_REFUND IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  EXEMPT REFUND".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  EXEMPT REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	MOVE EXEMPT_3RD_PARTY_REFUND IN WS_LETTER_COUNTERS TO 
	     WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  EXEMPT 3RD PARTY REFUND".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  EXEMPT 3RD PARTY REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
	MOVE EXEMPT_REFUND_CHECK IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  EXEMPT REFUND CHECK".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  EXEMPT REFUND CHECK" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	IF UNKNOWN IN WS_LETTER_COUNTERS > 0 THEN 
		MOVE UNKNOWN IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER
		DISPLAY WS_DISPLAY_COUNTER "  UNKNOWN"
		STRING
			WS_DISPLAY_COUNTER DELIMITED BY SIZE,
			"  UNKNOWN" DELIMITED BY SIZE
		    INTO LETTER_TOTAL_RPT_REC
		PERFORM WRITE_LETTER_RPT_REC THRU
			WRITE_LETTER_RPT_REC_EXIT
	END-IF.                                   
	
 
	DISPLAY " ".
	DISPLAY " ".  
        DISPLAY "BREAKDOWN BY LETTER CATEGORY".
	DISPLAY " ".
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	MOVE "BREAKDOWN BY LETTER CATEGORY" TO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	MOVE "----------------------------" TO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	ADD FULL_YEAR IN WS_LETTER_COUNTERS 
	    PART_EXEMPT_FULL_YEAR IN WS_LETTER_COUNTERS
        GIVING FULL_YEAR_TOT IN WS_LETTER_COUNTERS. 
	MOVE FULL_YEAR_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  FULL YEAR DUE".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  FULL YEAR DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
                                           
	ADD 2ND_HALF IN WS_LETTER_COUNTERS 
	    PART_EXEMPT_2ND_HALF IN WS_LETTER_COUNTERS
	GIVING 2ND_HALF_TOT IN WS_LETTER_COUNTERS. 
        MOVE 2ND_HALF_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  2ND HALF DUE".                  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  2ND HALF DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
                                           
	ADD ZERO_DUE IN WS_LETTER_COUNTERS 
	    PART_EXEMPT_ZERO IN WS_LETTER_COUNTERS
	GIVING ZERO_DUE_TOT IN WS_LETTER_COUNTERS. 	
        MOVE ZERO_DUE_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  ZERO DUE".                   
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  ZERO DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
		
	ADD REFUND IN WS_LETTER_COUNTERS 
	    PART_EXEMPT_REFUND IN WS_LETTER_COUNTERS 
	    EXEMPT_REFUND IN WS_LETTER_COUNTERS
	GIVING REFUND_TOT IN WS_LETTER_COUNTERS.
        MOVE REFUND_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  REFUND".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
	ADD 3RD_PARTY_REFUND IN WS_LETTER_COUNTERS 
	    PART_EXEMPT_3RD_PARTY_REFUND IN WS_LETTER_COUNTERS      
            EXEMPT_3RD_PARTY_REFUND IN WS_LETTER_COUNTERS
	GIVING 3RD_PARTY_REFUND_TOT IN WS_LETTER_COUNTERS.
	MOVE 3RD_PARTY_REFUND_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  3RD PARTY REFUND". 
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  3RD PARTY REFUND" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
   
        ADD REFUND_CHECK IN WS_LETTER_COUNTERS     
	    PART_EXEMPT_REFUND_CHECK IN WS_LETTER_COUNTERS  
	    EXEMPT_REFUND_CHECK IN WS_LETTER_COUNTERS
   	GIVING REFUND_CHECK_TOT IN WS_LETTER_COUNTERS. 
	MOVE REFUND_CHECK_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  REFUND CHECK"
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  REFUND CHECK" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	MOVE EXEMPT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  EXEMPT".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  EXEMPT" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
        
	IF UNKNOWN IN WS_LETTER_COUNTERS > 0 THEN 
		MOVE UNKNOWN IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER
		DISPLAY WS_DISPLAY_COUNTER "  UNKNOWN"
		STRING
			WS_DISPLAY_COUNTER DELIMITED BY SIZE,
			"  UNKNOWN" DELIMITED BY SIZE
		    INTO LETTER_TOTAL_RPT_REC
		PERFORM WRITE_LETTER_RPT_REC THRU
			WRITE_LETTER_RPT_REC_EXIT
	END-IF.                                   

 
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	DISPLAY " ".
	DISPLAY " ".  
	ADD FULL_YEAR_TOT IN WS_LETTER_COUNTERS
	    2ND_HALF_TOT IN WS_LETTER_COUNTERS
	    ZERO_DUE_TOT IN WS_LETTER_COUNTERS
	    REFUND_TOT IN WS_LETTER_COUNTERS
	    3RD_PARTY_REFUND_TOT IN WS_LETTER_COUNTERS
	    REFUND_CHECK_TOT IN WS_LETTER_COUNTERS
	    EXEMPT IN WS_LETTER_COUNTERS
	    UNKNOWN IN WS_LETTER_COUNTERS
	GIVING GRAND_TOT IN WS_LETTER_COUNTERS.
	MOVE GRAND_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  TOTAL LETTERS".
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  TOTAL LETTERS" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.


	DISPLAY " ".
	DISPLAY " ".
	DISPLAY "SUPPLEMENTARY STATEMENTS".
 	DISPLAY " ". 
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	MOVE "SUPPLEMENTARY STATEMENTS" TO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	MOVE "------------------------" TO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
	
	MOVE WS_TDS_COUNT TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  TAX DUE". 
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  TAX DUE" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.

	MOVE 3RD_PARTY_REFUND_TOT IN WS_LETTER_COUNTERS TO WS_DISPLAY_COUNTER.
	DISPLAY WS_DISPLAY_COUNTER "  CNA VERIFY".  
	STRING
		WS_DISPLAY_COUNTER DELIMITED BY SIZE,
		"  CNA VERIFY" DELIMITED BY SIZE
	    INTO LETTER_TOTAL_RPT_REC.
	PERFORM WRITE_LETTER_RPT_REC THRU
		WRITE_LETTER_RPT_REC_EXIT.
        
        DISPLAY " ".
	DISPLAY " ".
	DISPLAY "***********************".
	DISPLAY "* END LETTER COUNTERS *".
 	DISPLAY "***********************".  
	DISPLAY " ".
	DISPLAY " ".                  

	CLOSE LETTER_TOTAL_RPT.

DISPLAY_LETTER_COUNTS_EXIT.
 
/
WRITE_LETTER_RPT_REC.

	CALL "STR$TRIM" USING
		BY DESCRIPTOR LETTER_TOTAL_RPT_REC
		BY DESCRIPTOR LETTER_TOTAL_RPT_REC
		BY REFERENCE WS_LETTER_REC_LEN.
	WRITE LETTER_TOTAL_RPT_REC.
	MOVE SPACES TO LETTER_TOTAL_RPT_REC.

WRITE_LETTER_RPT_REC_EXIT.
	EXIT.

/
*******************
* HANDLE_DEADLOCK *
*******************

HANDLE_DEADLOCK.

&RDB&	ROLLBACK
&RDB&	    ON ERROR
		DISPLAY "ERROR RETURNED FROM ROLLBACK IN DEADLOCK HANDLER."
		DISPLAY "THIS IS PROBABLY AN ATTEMPT TO ROLLBACK A TRANSACTION"
		DISPLAY "WHEN ONE WAS NOT ACTIVE.  CONTINUING..."
&RDB&	    END_ERROR

	MOVE 3 TO WAIT_SECONDS IN MCT_WAIT_LKG.
	CALL "MCT_WAIT" USING MCT_WAIT_LKG GIVING RETURN_STATUS.

	DISPLAY " ".
	DISPLAY "*** DEADLOCK ENCOUNTERED AND HANDLED - RESTARTING TRANSACTION. ***".
	DISPLAY " ".

HANDLE_DEADLOCK_EXIT.
	EXIT.

*************
* FMS_ERROR *
*************

FMS_ERROR.
      MOVE RETURN_STATUS TO ERR_ERROR_CODE IN COM_ERR_STRUCTURE.
      CALL "FMS_ERR".
      GO TO HANDLE_ERRORS_EXIT.

*************
* RDB_ERROR *
*************

RDB_ERROR.
      MOVE RETURN_STATUS TO ERR_ERROR_CODE IN COM_ERR_STRUCTURE.
      CALL "RDB_ERR" USING RDB$MESSAGE_VECTOR.
      GO TO HANDLE_ERRORS_EXIT.

*****************
* SYSCALL_ERROR *
*****************

SYSCALL_ERROR.

      MOVE RETURN_STATUS TO ERR_ERROR_CODE.
      CALL "SYSCALL_ERR".
      GO TO HANDLE_ERRORS_EXIT.


*****************
* HANDLE_ERRORS *
*****************

HANDLE_ERRORS.

      IF FMSERR
            GO TO FMS_ERROR.
      IF SYSCALLERR
            GO TO SYSCALL_ERROR.

      IF RDBERR
            MOVE RETURN_STATUS TO ERR_ERROR_CODE IN COM_ERR_STRUCTURE
            CALL "RDB_ERR" USING RDB$MESSAGE_VECTOR
            GO TO HANDLE_ERRORS_EXIT.

*************
* APP_ERROR *
*************

APP_ERROR.

      MOVE RETURN_STATUS TO ERR_ERROR_CODE.
      CALL "APP_ERR".
      GO TO HANDLE_ERRORS_EXIT.

HANDLE_ERRORS_EXIT.
/
*****************
* ABORT_PROGRAM *
*****************

ABORT_PROGRAM.

	DISPLAY "THERE HAS BEEN A SERIOUS SYSTEM ERROR, AND THE PROGRAM".
	DISPLAY "IS TERMINATING.  CONTACT SYSTEM AMINISTRATOR.".
	DISPLAY "PROGRAM TERMINATED.".

&RDB&   ROLLBACK
&RDB&	   ON ERROR
              CONTINUE
&RDB&      END_ERROR

        CALL "SYS$EXIT" USING BY VALUE ZERO.

	STOP RUN.

END program PHASE_PROCESSING_BY_RES_NUM.
	
